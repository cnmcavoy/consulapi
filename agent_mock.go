package consulapi

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// AgentMock implements Agent
type AgentMock struct {
	t minimock.Tester

	funcForceLeave          func(ctx Ctx, node string) (err error)
	inspectFuncForceLeave   func(ctx Ctx, node string)
	afterForceLeaveCounter  uint64
	beforeForceLeaveCounter uint64
	ForceLeaveMock          mAgentMockForceLeave

	funcJoin          func(ctx Ctx, address string, wan bool) (err error)
	inspectFuncJoin   func(ctx Ctx, address string, wan bool)
	afterJoinCounter  uint64
	beforeJoinCounter uint64
	JoinMock          mAgentMockJoin

	funcLeave          func(ctx Ctx) (err error)
	inspectFuncLeave   func(ctx Ctx)
	afterLeaveCounter  uint64
	beforeLeaveCounter uint64
	LeaveMock          mAgentMockLeave

	funcMaintenanceMode          func(ctx Ctx, enabled bool, reason string) (err error)
	inspectFuncMaintenanceMode   func(ctx Ctx, enabled bool, reason string)
	afterMaintenanceModeCounter  uint64
	beforeMaintenanceModeCounter uint64
	MaintenanceModeMock          mAgentMockMaintenanceMode

	funcMembers          func(ctx Ctx, wan bool) (aa1 []AgentInfo, err error)
	inspectFuncMembers   func(ctx Ctx, wan bool)
	afterMembersCounter  uint64
	beforeMembersCounter uint64
	MembersMock          mAgentMockMembers

	funcMetrics          func(ctx Ctx) (m1 Metrics, err error)
	inspectFuncMetrics   func(ctx Ctx)
	afterMetricsCounter  uint64
	beforeMetricsCounter uint64
	MetricsMock          mAgentMockMetrics

	funcReload          func(ctx Ctx) (err error)
	inspectFuncReload   func(ctx Ctx)
	afterReloadCounter  uint64
	beforeReloadCounter uint64
	ReloadMock          mAgentMockReload

	funcSelf          func(ctx Ctx) (a1 AgentInfo, err error)
	inspectFuncSelf   func(ctx Ctx)
	afterSelfCounter  uint64
	beforeSelfCounter uint64
	SelfMock          mAgentMockSelf

	funcSetACLToken          func(ctx Ctx, kind string, token string) (err error)
	inspectFuncSetACLToken   func(ctx Ctx, kind string, token string)
	afterSetACLTokenCounter  uint64
	beforeSetACLTokenCounter uint64
	SetACLTokenMock          mAgentMockSetACLToken
}

// NewAgentMock returns a mock for Agent
func NewAgentMock(t minimock.Tester) *AgentMock {
	m := &AgentMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ForceLeaveMock = mAgentMockForceLeave{mock: m}
	m.ForceLeaveMock.callArgs = []*AgentMockForceLeaveParams{}

	m.JoinMock = mAgentMockJoin{mock: m}
	m.JoinMock.callArgs = []*AgentMockJoinParams{}

	m.LeaveMock = mAgentMockLeave{mock: m}
	m.LeaveMock.callArgs = []*AgentMockLeaveParams{}

	m.MaintenanceModeMock = mAgentMockMaintenanceMode{mock: m}
	m.MaintenanceModeMock.callArgs = []*AgentMockMaintenanceModeParams{}

	m.MembersMock = mAgentMockMembers{mock: m}
	m.MembersMock.callArgs = []*AgentMockMembersParams{}

	m.MetricsMock = mAgentMockMetrics{mock: m}
	m.MetricsMock.callArgs = []*AgentMockMetricsParams{}

	m.ReloadMock = mAgentMockReload{mock: m}
	m.ReloadMock.callArgs = []*AgentMockReloadParams{}

	m.SelfMock = mAgentMockSelf{mock: m}
	m.SelfMock.callArgs = []*AgentMockSelfParams{}

	m.SetACLTokenMock = mAgentMockSetACLToken{mock: m}
	m.SetACLTokenMock.callArgs = []*AgentMockSetACLTokenParams{}

	return m
}

type mAgentMockForceLeave struct {
	mock               *AgentMock
	defaultExpectation *AgentMockForceLeaveExpectation
	expectations       []*AgentMockForceLeaveExpectation

	callArgs []*AgentMockForceLeaveParams
	mutex    sync.RWMutex
}

// AgentMockForceLeaveExpectation specifies expectation struct of the Agent.ForceLeave
type AgentMockForceLeaveExpectation struct {
	mock    *AgentMock
	params  *AgentMockForceLeaveParams
	results *AgentMockForceLeaveResults
	Counter uint64
}

// AgentMockForceLeaveParams contains parameters of the Agent.ForceLeave
type AgentMockForceLeaveParams struct {
	ctx  Ctx
	node string
}

// AgentMockForceLeaveResults contains results of the Agent.ForceLeave
type AgentMockForceLeaveResults struct {
	err error
}

// Expect sets up expected params for Agent.ForceLeave
func (mmForceLeave *mAgentMockForceLeave) Expect(ctx Ctx, node string) *mAgentMockForceLeave {
	if mmForceLeave.mock.funcForceLeave != nil {
		mmForceLeave.mock.t.Fatalf("AgentMock.ForceLeave mock is already set by Set")
	}

	if mmForceLeave.defaultExpectation == nil {
		mmForceLeave.defaultExpectation = &AgentMockForceLeaveExpectation{}
	}

	mmForceLeave.defaultExpectation.params = &AgentMockForceLeaveParams{ctx, node}
	for _, e := range mmForceLeave.expectations {
		if minimock.Equal(e.params, mmForceLeave.defaultExpectation.params) {
			mmForceLeave.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmForceLeave.defaultExpectation.params)
		}
	}

	return mmForceLeave
}

// Inspect accepts an inspector function that has same arguments as the Agent.ForceLeave
func (mmForceLeave *mAgentMockForceLeave) Inspect(f func(ctx Ctx, node string)) *mAgentMockForceLeave {
	if mmForceLeave.mock.inspectFuncForceLeave != nil {
		mmForceLeave.mock.t.Fatalf("Inspect function is already set for AgentMock.ForceLeave")
	}

	mmForceLeave.mock.inspectFuncForceLeave = f

	return mmForceLeave
}

// Return sets up results that will be returned by Agent.ForceLeave
func (mmForceLeave *mAgentMockForceLeave) Return(err error) *AgentMock {
	if mmForceLeave.mock.funcForceLeave != nil {
		mmForceLeave.mock.t.Fatalf("AgentMock.ForceLeave mock is already set by Set")
	}

	if mmForceLeave.defaultExpectation == nil {
		mmForceLeave.defaultExpectation = &AgentMockForceLeaveExpectation{mock: mmForceLeave.mock}
	}
	mmForceLeave.defaultExpectation.results = &AgentMockForceLeaveResults{err}
	return mmForceLeave.mock
}

//Set uses given function f to mock the Agent.ForceLeave method
func (mmForceLeave *mAgentMockForceLeave) Set(f func(ctx Ctx, node string) (err error)) *AgentMock {
	if mmForceLeave.defaultExpectation != nil {
		mmForceLeave.mock.t.Fatalf("Default expectation is already set for the Agent.ForceLeave method")
	}

	if len(mmForceLeave.expectations) > 0 {
		mmForceLeave.mock.t.Fatalf("Some expectations are already set for the Agent.ForceLeave method")
	}

	mmForceLeave.mock.funcForceLeave = f
	return mmForceLeave.mock
}

// When sets expectation for the Agent.ForceLeave which will trigger the result defined by the following
// Then helper
func (mmForceLeave *mAgentMockForceLeave) When(ctx Ctx, node string) *AgentMockForceLeaveExpectation {
	if mmForceLeave.mock.funcForceLeave != nil {
		mmForceLeave.mock.t.Fatalf("AgentMock.ForceLeave mock is already set by Set")
	}

	expectation := &AgentMockForceLeaveExpectation{
		mock:   mmForceLeave.mock,
		params: &AgentMockForceLeaveParams{ctx, node},
	}
	mmForceLeave.expectations = append(mmForceLeave.expectations, expectation)
	return expectation
}

// Then sets up Agent.ForceLeave return parameters for the expectation previously defined by the When method
func (e *AgentMockForceLeaveExpectation) Then(err error) *AgentMock {
	e.results = &AgentMockForceLeaveResults{err}
	return e.mock
}

// ForceLeave implements Agent
func (mmForceLeave *AgentMock) ForceLeave(ctx Ctx, node string) (err error) {
	mm_atomic.AddUint64(&mmForceLeave.beforeForceLeaveCounter, 1)
	defer mm_atomic.AddUint64(&mmForceLeave.afterForceLeaveCounter, 1)

	if mmForceLeave.inspectFuncForceLeave != nil {
		mmForceLeave.inspectFuncForceLeave(ctx, node)
	}

	mm_params := &AgentMockForceLeaveParams{ctx, node}

	// Record call args
	mmForceLeave.ForceLeaveMock.mutex.Lock()
	mmForceLeave.ForceLeaveMock.callArgs = append(mmForceLeave.ForceLeaveMock.callArgs, mm_params)
	mmForceLeave.ForceLeaveMock.mutex.Unlock()

	for _, e := range mmForceLeave.ForceLeaveMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmForceLeave.ForceLeaveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmForceLeave.ForceLeaveMock.defaultExpectation.Counter, 1)
		mm_want := mmForceLeave.ForceLeaveMock.defaultExpectation.params
		mm_got := AgentMockForceLeaveParams{ctx, node}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmForceLeave.t.Errorf("AgentMock.ForceLeave got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmForceLeave.ForceLeaveMock.defaultExpectation.results
		if mm_results == nil {
			mmForceLeave.t.Fatal("No results are set for the AgentMock.ForceLeave")
		}
		return (*mm_results).err
	}
	if mmForceLeave.funcForceLeave != nil {
		return mmForceLeave.funcForceLeave(ctx, node)
	}
	mmForceLeave.t.Fatalf("Unexpected call to AgentMock.ForceLeave. %v %v", ctx, node)
	return
}

// ForceLeaveAfterCounter returns a count of finished AgentMock.ForceLeave invocations
func (mmForceLeave *AgentMock) ForceLeaveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmForceLeave.afterForceLeaveCounter)
}

// ForceLeaveBeforeCounter returns a count of AgentMock.ForceLeave invocations
func (mmForceLeave *AgentMock) ForceLeaveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmForceLeave.beforeForceLeaveCounter)
}

// Calls returns a list of arguments used in each call to AgentMock.ForceLeave.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmForceLeave *mAgentMockForceLeave) Calls() []*AgentMockForceLeaveParams {
	mmForceLeave.mutex.RLock()

	argCopy := make([]*AgentMockForceLeaveParams, len(mmForceLeave.callArgs))
	copy(argCopy, mmForceLeave.callArgs)

	mmForceLeave.mutex.RUnlock()

	return argCopy
}

// MinimockForceLeaveDone returns true if the count of the ForceLeave invocations corresponds
// the number of defined expectations
func (m *AgentMock) MinimockForceLeaveDone() bool {
	for _, e := range m.ForceLeaveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ForceLeaveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterForceLeaveCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcForceLeave != nil && mm_atomic.LoadUint64(&m.afterForceLeaveCounter) < 1 {
		return false
	}
	return true
}

// MinimockForceLeaveInspect logs each unmet expectation
func (m *AgentMock) MinimockForceLeaveInspect() {
	for _, e := range m.ForceLeaveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AgentMock.ForceLeave with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ForceLeaveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterForceLeaveCounter) < 1 {
		if m.ForceLeaveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AgentMock.ForceLeave")
		} else {
			m.t.Errorf("Expected call to AgentMock.ForceLeave with params: %#v", *m.ForceLeaveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcForceLeave != nil && mm_atomic.LoadUint64(&m.afterForceLeaveCounter) < 1 {
		m.t.Error("Expected call to AgentMock.ForceLeave")
	}
}

type mAgentMockJoin struct {
	mock               *AgentMock
	defaultExpectation *AgentMockJoinExpectation
	expectations       []*AgentMockJoinExpectation

	callArgs []*AgentMockJoinParams
	mutex    sync.RWMutex
}

// AgentMockJoinExpectation specifies expectation struct of the Agent.Join
type AgentMockJoinExpectation struct {
	mock    *AgentMock
	params  *AgentMockJoinParams
	results *AgentMockJoinResults
	Counter uint64
}

// AgentMockJoinParams contains parameters of the Agent.Join
type AgentMockJoinParams struct {
	ctx     Ctx
	address string
	wan     bool
}

// AgentMockJoinResults contains results of the Agent.Join
type AgentMockJoinResults struct {
	err error
}

// Expect sets up expected params for Agent.Join
func (mmJoin *mAgentMockJoin) Expect(ctx Ctx, address string, wan bool) *mAgentMockJoin {
	if mmJoin.mock.funcJoin != nil {
		mmJoin.mock.t.Fatalf("AgentMock.Join mock is already set by Set")
	}

	if mmJoin.defaultExpectation == nil {
		mmJoin.defaultExpectation = &AgentMockJoinExpectation{}
	}

	mmJoin.defaultExpectation.params = &AgentMockJoinParams{ctx, address, wan}
	for _, e := range mmJoin.expectations {
		if minimock.Equal(e.params, mmJoin.defaultExpectation.params) {
			mmJoin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmJoin.defaultExpectation.params)
		}
	}

	return mmJoin
}

// Inspect accepts an inspector function that has same arguments as the Agent.Join
func (mmJoin *mAgentMockJoin) Inspect(f func(ctx Ctx, address string, wan bool)) *mAgentMockJoin {
	if mmJoin.mock.inspectFuncJoin != nil {
		mmJoin.mock.t.Fatalf("Inspect function is already set for AgentMock.Join")
	}

	mmJoin.mock.inspectFuncJoin = f

	return mmJoin
}

// Return sets up results that will be returned by Agent.Join
func (mmJoin *mAgentMockJoin) Return(err error) *AgentMock {
	if mmJoin.mock.funcJoin != nil {
		mmJoin.mock.t.Fatalf("AgentMock.Join mock is already set by Set")
	}

	if mmJoin.defaultExpectation == nil {
		mmJoin.defaultExpectation = &AgentMockJoinExpectation{mock: mmJoin.mock}
	}
	mmJoin.defaultExpectation.results = &AgentMockJoinResults{err}
	return mmJoin.mock
}

//Set uses given function f to mock the Agent.Join method
func (mmJoin *mAgentMockJoin) Set(f func(ctx Ctx, address string, wan bool) (err error)) *AgentMock {
	if mmJoin.defaultExpectation != nil {
		mmJoin.mock.t.Fatalf("Default expectation is already set for the Agent.Join method")
	}

	if len(mmJoin.expectations) > 0 {
		mmJoin.mock.t.Fatalf("Some expectations are already set for the Agent.Join method")
	}

	mmJoin.mock.funcJoin = f
	return mmJoin.mock
}

// When sets expectation for the Agent.Join which will trigger the result defined by the following
// Then helper
func (mmJoin *mAgentMockJoin) When(ctx Ctx, address string, wan bool) *AgentMockJoinExpectation {
	if mmJoin.mock.funcJoin != nil {
		mmJoin.mock.t.Fatalf("AgentMock.Join mock is already set by Set")
	}

	expectation := &AgentMockJoinExpectation{
		mock:   mmJoin.mock,
		params: &AgentMockJoinParams{ctx, address, wan},
	}
	mmJoin.expectations = append(mmJoin.expectations, expectation)
	return expectation
}

// Then sets up Agent.Join return parameters for the expectation previously defined by the When method
func (e *AgentMockJoinExpectation) Then(err error) *AgentMock {
	e.results = &AgentMockJoinResults{err}
	return e.mock
}

// Join implements Agent
func (mmJoin *AgentMock) Join(ctx Ctx, address string, wan bool) (err error) {
	mm_atomic.AddUint64(&mmJoin.beforeJoinCounter, 1)
	defer mm_atomic.AddUint64(&mmJoin.afterJoinCounter, 1)

	if mmJoin.inspectFuncJoin != nil {
		mmJoin.inspectFuncJoin(ctx, address, wan)
	}

	mm_params := &AgentMockJoinParams{ctx, address, wan}

	// Record call args
	mmJoin.JoinMock.mutex.Lock()
	mmJoin.JoinMock.callArgs = append(mmJoin.JoinMock.callArgs, mm_params)
	mmJoin.JoinMock.mutex.Unlock()

	for _, e := range mmJoin.JoinMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmJoin.JoinMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmJoin.JoinMock.defaultExpectation.Counter, 1)
		mm_want := mmJoin.JoinMock.defaultExpectation.params
		mm_got := AgentMockJoinParams{ctx, address, wan}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmJoin.t.Errorf("AgentMock.Join got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmJoin.JoinMock.defaultExpectation.results
		if mm_results == nil {
			mmJoin.t.Fatal("No results are set for the AgentMock.Join")
		}
		return (*mm_results).err
	}
	if mmJoin.funcJoin != nil {
		return mmJoin.funcJoin(ctx, address, wan)
	}
	mmJoin.t.Fatalf("Unexpected call to AgentMock.Join. %v %v %v", ctx, address, wan)
	return
}

// JoinAfterCounter returns a count of finished AgentMock.Join invocations
func (mmJoin *AgentMock) JoinAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmJoin.afterJoinCounter)
}

// JoinBeforeCounter returns a count of AgentMock.Join invocations
func (mmJoin *AgentMock) JoinBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmJoin.beforeJoinCounter)
}

// Calls returns a list of arguments used in each call to AgentMock.Join.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmJoin *mAgentMockJoin) Calls() []*AgentMockJoinParams {
	mmJoin.mutex.RLock()

	argCopy := make([]*AgentMockJoinParams, len(mmJoin.callArgs))
	copy(argCopy, mmJoin.callArgs)

	mmJoin.mutex.RUnlock()

	return argCopy
}

// MinimockJoinDone returns true if the count of the Join invocations corresponds
// the number of defined expectations
func (m *AgentMock) MinimockJoinDone() bool {
	for _, e := range m.JoinMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.JoinMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterJoinCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcJoin != nil && mm_atomic.LoadUint64(&m.afterJoinCounter) < 1 {
		return false
	}
	return true
}

// MinimockJoinInspect logs each unmet expectation
func (m *AgentMock) MinimockJoinInspect() {
	for _, e := range m.JoinMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AgentMock.Join with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.JoinMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterJoinCounter) < 1 {
		if m.JoinMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AgentMock.Join")
		} else {
			m.t.Errorf("Expected call to AgentMock.Join with params: %#v", *m.JoinMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcJoin != nil && mm_atomic.LoadUint64(&m.afterJoinCounter) < 1 {
		m.t.Error("Expected call to AgentMock.Join")
	}
}

type mAgentMockLeave struct {
	mock               *AgentMock
	defaultExpectation *AgentMockLeaveExpectation
	expectations       []*AgentMockLeaveExpectation

	callArgs []*AgentMockLeaveParams
	mutex    sync.RWMutex
}

// AgentMockLeaveExpectation specifies expectation struct of the Agent.Leave
type AgentMockLeaveExpectation struct {
	mock    *AgentMock
	params  *AgentMockLeaveParams
	results *AgentMockLeaveResults
	Counter uint64
}

// AgentMockLeaveParams contains parameters of the Agent.Leave
type AgentMockLeaveParams struct {
	ctx Ctx
}

// AgentMockLeaveResults contains results of the Agent.Leave
type AgentMockLeaveResults struct {
	err error
}

// Expect sets up expected params for Agent.Leave
func (mmLeave *mAgentMockLeave) Expect(ctx Ctx) *mAgentMockLeave {
	if mmLeave.mock.funcLeave != nil {
		mmLeave.mock.t.Fatalf("AgentMock.Leave mock is already set by Set")
	}

	if mmLeave.defaultExpectation == nil {
		mmLeave.defaultExpectation = &AgentMockLeaveExpectation{}
	}

	mmLeave.defaultExpectation.params = &AgentMockLeaveParams{ctx}
	for _, e := range mmLeave.expectations {
		if minimock.Equal(e.params, mmLeave.defaultExpectation.params) {
			mmLeave.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLeave.defaultExpectation.params)
		}
	}

	return mmLeave
}

// Inspect accepts an inspector function that has same arguments as the Agent.Leave
func (mmLeave *mAgentMockLeave) Inspect(f func(ctx Ctx)) *mAgentMockLeave {
	if mmLeave.mock.inspectFuncLeave != nil {
		mmLeave.mock.t.Fatalf("Inspect function is already set for AgentMock.Leave")
	}

	mmLeave.mock.inspectFuncLeave = f

	return mmLeave
}

// Return sets up results that will be returned by Agent.Leave
func (mmLeave *mAgentMockLeave) Return(err error) *AgentMock {
	if mmLeave.mock.funcLeave != nil {
		mmLeave.mock.t.Fatalf("AgentMock.Leave mock is already set by Set")
	}

	if mmLeave.defaultExpectation == nil {
		mmLeave.defaultExpectation = &AgentMockLeaveExpectation{mock: mmLeave.mock}
	}
	mmLeave.defaultExpectation.results = &AgentMockLeaveResults{err}
	return mmLeave.mock
}

//Set uses given function f to mock the Agent.Leave method
func (mmLeave *mAgentMockLeave) Set(f func(ctx Ctx) (err error)) *AgentMock {
	if mmLeave.defaultExpectation != nil {
		mmLeave.mock.t.Fatalf("Default expectation is already set for the Agent.Leave method")
	}

	if len(mmLeave.expectations) > 0 {
		mmLeave.mock.t.Fatalf("Some expectations are already set for the Agent.Leave method")
	}

	mmLeave.mock.funcLeave = f
	return mmLeave.mock
}

// When sets expectation for the Agent.Leave which will trigger the result defined by the following
// Then helper
func (mmLeave *mAgentMockLeave) When(ctx Ctx) *AgentMockLeaveExpectation {
	if mmLeave.mock.funcLeave != nil {
		mmLeave.mock.t.Fatalf("AgentMock.Leave mock is already set by Set")
	}

	expectation := &AgentMockLeaveExpectation{
		mock:   mmLeave.mock,
		params: &AgentMockLeaveParams{ctx},
	}
	mmLeave.expectations = append(mmLeave.expectations, expectation)
	return expectation
}

// Then sets up Agent.Leave return parameters for the expectation previously defined by the When method
func (e *AgentMockLeaveExpectation) Then(err error) *AgentMock {
	e.results = &AgentMockLeaveResults{err}
	return e.mock
}

// Leave implements Agent
func (mmLeave *AgentMock) Leave(ctx Ctx) (err error) {
	mm_atomic.AddUint64(&mmLeave.beforeLeaveCounter, 1)
	defer mm_atomic.AddUint64(&mmLeave.afterLeaveCounter, 1)

	if mmLeave.inspectFuncLeave != nil {
		mmLeave.inspectFuncLeave(ctx)
	}

	mm_params := &AgentMockLeaveParams{ctx}

	// Record call args
	mmLeave.LeaveMock.mutex.Lock()
	mmLeave.LeaveMock.callArgs = append(mmLeave.LeaveMock.callArgs, mm_params)
	mmLeave.LeaveMock.mutex.Unlock()

	for _, e := range mmLeave.LeaveMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmLeave.LeaveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLeave.LeaveMock.defaultExpectation.Counter, 1)
		mm_want := mmLeave.LeaveMock.defaultExpectation.params
		mm_got := AgentMockLeaveParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLeave.t.Errorf("AgentMock.Leave got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLeave.LeaveMock.defaultExpectation.results
		if mm_results == nil {
			mmLeave.t.Fatal("No results are set for the AgentMock.Leave")
		}
		return (*mm_results).err
	}
	if mmLeave.funcLeave != nil {
		return mmLeave.funcLeave(ctx)
	}
	mmLeave.t.Fatalf("Unexpected call to AgentMock.Leave. %v", ctx)
	return
}

// LeaveAfterCounter returns a count of finished AgentMock.Leave invocations
func (mmLeave *AgentMock) LeaveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLeave.afterLeaveCounter)
}

// LeaveBeforeCounter returns a count of AgentMock.Leave invocations
func (mmLeave *AgentMock) LeaveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLeave.beforeLeaveCounter)
}

// Calls returns a list of arguments used in each call to AgentMock.Leave.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLeave *mAgentMockLeave) Calls() []*AgentMockLeaveParams {
	mmLeave.mutex.RLock()

	argCopy := make([]*AgentMockLeaveParams, len(mmLeave.callArgs))
	copy(argCopy, mmLeave.callArgs)

	mmLeave.mutex.RUnlock()

	return argCopy
}

// MinimockLeaveDone returns true if the count of the Leave invocations corresponds
// the number of defined expectations
func (m *AgentMock) MinimockLeaveDone() bool {
	for _, e := range m.LeaveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LeaveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLeaveCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLeave != nil && mm_atomic.LoadUint64(&m.afterLeaveCounter) < 1 {
		return false
	}
	return true
}

// MinimockLeaveInspect logs each unmet expectation
func (m *AgentMock) MinimockLeaveInspect() {
	for _, e := range m.LeaveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AgentMock.Leave with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LeaveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLeaveCounter) < 1 {
		if m.LeaveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AgentMock.Leave")
		} else {
			m.t.Errorf("Expected call to AgentMock.Leave with params: %#v", *m.LeaveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLeave != nil && mm_atomic.LoadUint64(&m.afterLeaveCounter) < 1 {
		m.t.Error("Expected call to AgentMock.Leave")
	}
}

type mAgentMockMaintenanceMode struct {
	mock               *AgentMock
	defaultExpectation *AgentMockMaintenanceModeExpectation
	expectations       []*AgentMockMaintenanceModeExpectation

	callArgs []*AgentMockMaintenanceModeParams
	mutex    sync.RWMutex
}

// AgentMockMaintenanceModeExpectation specifies expectation struct of the Agent.MaintenanceMode
type AgentMockMaintenanceModeExpectation struct {
	mock    *AgentMock
	params  *AgentMockMaintenanceModeParams
	results *AgentMockMaintenanceModeResults
	Counter uint64
}

// AgentMockMaintenanceModeParams contains parameters of the Agent.MaintenanceMode
type AgentMockMaintenanceModeParams struct {
	ctx     Ctx
	enabled bool
	reason  string
}

// AgentMockMaintenanceModeResults contains results of the Agent.MaintenanceMode
type AgentMockMaintenanceModeResults struct {
	err error
}

// Expect sets up expected params for Agent.MaintenanceMode
func (mmMaintenanceMode *mAgentMockMaintenanceMode) Expect(ctx Ctx, enabled bool, reason string) *mAgentMockMaintenanceMode {
	if mmMaintenanceMode.mock.funcMaintenanceMode != nil {
		mmMaintenanceMode.mock.t.Fatalf("AgentMock.MaintenanceMode mock is already set by Set")
	}

	if mmMaintenanceMode.defaultExpectation == nil {
		mmMaintenanceMode.defaultExpectation = &AgentMockMaintenanceModeExpectation{}
	}

	mmMaintenanceMode.defaultExpectation.params = &AgentMockMaintenanceModeParams{ctx, enabled, reason}
	for _, e := range mmMaintenanceMode.expectations {
		if minimock.Equal(e.params, mmMaintenanceMode.defaultExpectation.params) {
			mmMaintenanceMode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMaintenanceMode.defaultExpectation.params)
		}
	}

	return mmMaintenanceMode
}

// Inspect accepts an inspector function that has same arguments as the Agent.MaintenanceMode
func (mmMaintenanceMode *mAgentMockMaintenanceMode) Inspect(f func(ctx Ctx, enabled bool, reason string)) *mAgentMockMaintenanceMode {
	if mmMaintenanceMode.mock.inspectFuncMaintenanceMode != nil {
		mmMaintenanceMode.mock.t.Fatalf("Inspect function is already set for AgentMock.MaintenanceMode")
	}

	mmMaintenanceMode.mock.inspectFuncMaintenanceMode = f

	return mmMaintenanceMode
}

// Return sets up results that will be returned by Agent.MaintenanceMode
func (mmMaintenanceMode *mAgentMockMaintenanceMode) Return(err error) *AgentMock {
	if mmMaintenanceMode.mock.funcMaintenanceMode != nil {
		mmMaintenanceMode.mock.t.Fatalf("AgentMock.MaintenanceMode mock is already set by Set")
	}

	if mmMaintenanceMode.defaultExpectation == nil {
		mmMaintenanceMode.defaultExpectation = &AgentMockMaintenanceModeExpectation{mock: mmMaintenanceMode.mock}
	}
	mmMaintenanceMode.defaultExpectation.results = &AgentMockMaintenanceModeResults{err}
	return mmMaintenanceMode.mock
}

//Set uses given function f to mock the Agent.MaintenanceMode method
func (mmMaintenanceMode *mAgentMockMaintenanceMode) Set(f func(ctx Ctx, enabled bool, reason string) (err error)) *AgentMock {
	if mmMaintenanceMode.defaultExpectation != nil {
		mmMaintenanceMode.mock.t.Fatalf("Default expectation is already set for the Agent.MaintenanceMode method")
	}

	if len(mmMaintenanceMode.expectations) > 0 {
		mmMaintenanceMode.mock.t.Fatalf("Some expectations are already set for the Agent.MaintenanceMode method")
	}

	mmMaintenanceMode.mock.funcMaintenanceMode = f
	return mmMaintenanceMode.mock
}

// When sets expectation for the Agent.MaintenanceMode which will trigger the result defined by the following
// Then helper
func (mmMaintenanceMode *mAgentMockMaintenanceMode) When(ctx Ctx, enabled bool, reason string) *AgentMockMaintenanceModeExpectation {
	if mmMaintenanceMode.mock.funcMaintenanceMode != nil {
		mmMaintenanceMode.mock.t.Fatalf("AgentMock.MaintenanceMode mock is already set by Set")
	}

	expectation := &AgentMockMaintenanceModeExpectation{
		mock:   mmMaintenanceMode.mock,
		params: &AgentMockMaintenanceModeParams{ctx, enabled, reason},
	}
	mmMaintenanceMode.expectations = append(mmMaintenanceMode.expectations, expectation)
	return expectation
}

// Then sets up Agent.MaintenanceMode return parameters for the expectation previously defined by the When method
func (e *AgentMockMaintenanceModeExpectation) Then(err error) *AgentMock {
	e.results = &AgentMockMaintenanceModeResults{err}
	return e.mock
}

// MaintenanceMode implements Agent
func (mmMaintenanceMode *AgentMock) MaintenanceMode(ctx Ctx, enabled bool, reason string) (err error) {
	mm_atomic.AddUint64(&mmMaintenanceMode.beforeMaintenanceModeCounter, 1)
	defer mm_atomic.AddUint64(&mmMaintenanceMode.afterMaintenanceModeCounter, 1)

	if mmMaintenanceMode.inspectFuncMaintenanceMode != nil {
		mmMaintenanceMode.inspectFuncMaintenanceMode(ctx, enabled, reason)
	}

	mm_params := &AgentMockMaintenanceModeParams{ctx, enabled, reason}

	// Record call args
	mmMaintenanceMode.MaintenanceModeMock.mutex.Lock()
	mmMaintenanceMode.MaintenanceModeMock.callArgs = append(mmMaintenanceMode.MaintenanceModeMock.callArgs, mm_params)
	mmMaintenanceMode.MaintenanceModeMock.mutex.Unlock()

	for _, e := range mmMaintenanceMode.MaintenanceModeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmMaintenanceMode.MaintenanceModeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMaintenanceMode.MaintenanceModeMock.defaultExpectation.Counter, 1)
		mm_want := mmMaintenanceMode.MaintenanceModeMock.defaultExpectation.params
		mm_got := AgentMockMaintenanceModeParams{ctx, enabled, reason}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMaintenanceMode.t.Errorf("AgentMock.MaintenanceMode got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMaintenanceMode.MaintenanceModeMock.defaultExpectation.results
		if mm_results == nil {
			mmMaintenanceMode.t.Fatal("No results are set for the AgentMock.MaintenanceMode")
		}
		return (*mm_results).err
	}
	if mmMaintenanceMode.funcMaintenanceMode != nil {
		return mmMaintenanceMode.funcMaintenanceMode(ctx, enabled, reason)
	}
	mmMaintenanceMode.t.Fatalf("Unexpected call to AgentMock.MaintenanceMode. %v %v %v", ctx, enabled, reason)
	return
}

// MaintenanceModeAfterCounter returns a count of finished AgentMock.MaintenanceMode invocations
func (mmMaintenanceMode *AgentMock) MaintenanceModeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMaintenanceMode.afterMaintenanceModeCounter)
}

// MaintenanceModeBeforeCounter returns a count of AgentMock.MaintenanceMode invocations
func (mmMaintenanceMode *AgentMock) MaintenanceModeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMaintenanceMode.beforeMaintenanceModeCounter)
}

// Calls returns a list of arguments used in each call to AgentMock.MaintenanceMode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMaintenanceMode *mAgentMockMaintenanceMode) Calls() []*AgentMockMaintenanceModeParams {
	mmMaintenanceMode.mutex.RLock()

	argCopy := make([]*AgentMockMaintenanceModeParams, len(mmMaintenanceMode.callArgs))
	copy(argCopy, mmMaintenanceMode.callArgs)

	mmMaintenanceMode.mutex.RUnlock()

	return argCopy
}

// MinimockMaintenanceModeDone returns true if the count of the MaintenanceMode invocations corresponds
// the number of defined expectations
func (m *AgentMock) MinimockMaintenanceModeDone() bool {
	for _, e := range m.MaintenanceModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MaintenanceModeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMaintenanceModeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMaintenanceMode != nil && mm_atomic.LoadUint64(&m.afterMaintenanceModeCounter) < 1 {
		return false
	}
	return true
}

// MinimockMaintenanceModeInspect logs each unmet expectation
func (m *AgentMock) MinimockMaintenanceModeInspect() {
	for _, e := range m.MaintenanceModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AgentMock.MaintenanceMode with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MaintenanceModeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMaintenanceModeCounter) < 1 {
		if m.MaintenanceModeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AgentMock.MaintenanceMode")
		} else {
			m.t.Errorf("Expected call to AgentMock.MaintenanceMode with params: %#v", *m.MaintenanceModeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMaintenanceMode != nil && mm_atomic.LoadUint64(&m.afterMaintenanceModeCounter) < 1 {
		m.t.Error("Expected call to AgentMock.MaintenanceMode")
	}
}

type mAgentMockMembers struct {
	mock               *AgentMock
	defaultExpectation *AgentMockMembersExpectation
	expectations       []*AgentMockMembersExpectation

	callArgs []*AgentMockMembersParams
	mutex    sync.RWMutex
}

// AgentMockMembersExpectation specifies expectation struct of the Agent.Members
type AgentMockMembersExpectation struct {
	mock    *AgentMock
	params  *AgentMockMembersParams
	results *AgentMockMembersResults
	Counter uint64
}

// AgentMockMembersParams contains parameters of the Agent.Members
type AgentMockMembersParams struct {
	ctx Ctx
	wan bool
}

// AgentMockMembersResults contains results of the Agent.Members
type AgentMockMembersResults struct {
	aa1 []AgentInfo
	err error
}

// Expect sets up expected params for Agent.Members
func (mmMembers *mAgentMockMembers) Expect(ctx Ctx, wan bool) *mAgentMockMembers {
	if mmMembers.mock.funcMembers != nil {
		mmMembers.mock.t.Fatalf("AgentMock.Members mock is already set by Set")
	}

	if mmMembers.defaultExpectation == nil {
		mmMembers.defaultExpectation = &AgentMockMembersExpectation{}
	}

	mmMembers.defaultExpectation.params = &AgentMockMembersParams{ctx, wan}
	for _, e := range mmMembers.expectations {
		if minimock.Equal(e.params, mmMembers.defaultExpectation.params) {
			mmMembers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMembers.defaultExpectation.params)
		}
	}

	return mmMembers
}

// Inspect accepts an inspector function that has same arguments as the Agent.Members
func (mmMembers *mAgentMockMembers) Inspect(f func(ctx Ctx, wan bool)) *mAgentMockMembers {
	if mmMembers.mock.inspectFuncMembers != nil {
		mmMembers.mock.t.Fatalf("Inspect function is already set for AgentMock.Members")
	}

	mmMembers.mock.inspectFuncMembers = f

	return mmMembers
}

// Return sets up results that will be returned by Agent.Members
func (mmMembers *mAgentMockMembers) Return(aa1 []AgentInfo, err error) *AgentMock {
	if mmMembers.mock.funcMembers != nil {
		mmMembers.mock.t.Fatalf("AgentMock.Members mock is already set by Set")
	}

	if mmMembers.defaultExpectation == nil {
		mmMembers.defaultExpectation = &AgentMockMembersExpectation{mock: mmMembers.mock}
	}
	mmMembers.defaultExpectation.results = &AgentMockMembersResults{aa1, err}
	return mmMembers.mock
}

//Set uses given function f to mock the Agent.Members method
func (mmMembers *mAgentMockMembers) Set(f func(ctx Ctx, wan bool) (aa1 []AgentInfo, err error)) *AgentMock {
	if mmMembers.defaultExpectation != nil {
		mmMembers.mock.t.Fatalf("Default expectation is already set for the Agent.Members method")
	}

	if len(mmMembers.expectations) > 0 {
		mmMembers.mock.t.Fatalf("Some expectations are already set for the Agent.Members method")
	}

	mmMembers.mock.funcMembers = f
	return mmMembers.mock
}

// When sets expectation for the Agent.Members which will trigger the result defined by the following
// Then helper
func (mmMembers *mAgentMockMembers) When(ctx Ctx, wan bool) *AgentMockMembersExpectation {
	if mmMembers.mock.funcMembers != nil {
		mmMembers.mock.t.Fatalf("AgentMock.Members mock is already set by Set")
	}

	expectation := &AgentMockMembersExpectation{
		mock:   mmMembers.mock,
		params: &AgentMockMembersParams{ctx, wan},
	}
	mmMembers.expectations = append(mmMembers.expectations, expectation)
	return expectation
}

// Then sets up Agent.Members return parameters for the expectation previously defined by the When method
func (e *AgentMockMembersExpectation) Then(aa1 []AgentInfo, err error) *AgentMock {
	e.results = &AgentMockMembersResults{aa1, err}
	return e.mock
}

// Members implements Agent
func (mmMembers *AgentMock) Members(ctx Ctx, wan bool) (aa1 []AgentInfo, err error) {
	mm_atomic.AddUint64(&mmMembers.beforeMembersCounter, 1)
	defer mm_atomic.AddUint64(&mmMembers.afterMembersCounter, 1)

	if mmMembers.inspectFuncMembers != nil {
		mmMembers.inspectFuncMembers(ctx, wan)
	}

	mm_params := &AgentMockMembersParams{ctx, wan}

	// Record call args
	mmMembers.MembersMock.mutex.Lock()
	mmMembers.MembersMock.callArgs = append(mmMembers.MembersMock.callArgs, mm_params)
	mmMembers.MembersMock.mutex.Unlock()

	for _, e := range mmMembers.MembersMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.aa1, e.results.err
		}
	}

	if mmMembers.MembersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMembers.MembersMock.defaultExpectation.Counter, 1)
		mm_want := mmMembers.MembersMock.defaultExpectation.params
		mm_got := AgentMockMembersParams{ctx, wan}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMembers.t.Errorf("AgentMock.Members got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMembers.MembersMock.defaultExpectation.results
		if mm_results == nil {
			mmMembers.t.Fatal("No results are set for the AgentMock.Members")
		}
		return (*mm_results).aa1, (*mm_results).err
	}
	if mmMembers.funcMembers != nil {
		return mmMembers.funcMembers(ctx, wan)
	}
	mmMembers.t.Fatalf("Unexpected call to AgentMock.Members. %v %v", ctx, wan)
	return
}

// MembersAfterCounter returns a count of finished AgentMock.Members invocations
func (mmMembers *AgentMock) MembersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMembers.afterMembersCounter)
}

// MembersBeforeCounter returns a count of AgentMock.Members invocations
func (mmMembers *AgentMock) MembersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMembers.beforeMembersCounter)
}

// Calls returns a list of arguments used in each call to AgentMock.Members.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMembers *mAgentMockMembers) Calls() []*AgentMockMembersParams {
	mmMembers.mutex.RLock()

	argCopy := make([]*AgentMockMembersParams, len(mmMembers.callArgs))
	copy(argCopy, mmMembers.callArgs)

	mmMembers.mutex.RUnlock()

	return argCopy
}

// MinimockMembersDone returns true if the count of the Members invocations corresponds
// the number of defined expectations
func (m *AgentMock) MinimockMembersDone() bool {
	for _, e := range m.MembersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MembersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMembersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMembers != nil && mm_atomic.LoadUint64(&m.afterMembersCounter) < 1 {
		return false
	}
	return true
}

// MinimockMembersInspect logs each unmet expectation
func (m *AgentMock) MinimockMembersInspect() {
	for _, e := range m.MembersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AgentMock.Members with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MembersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMembersCounter) < 1 {
		if m.MembersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AgentMock.Members")
		} else {
			m.t.Errorf("Expected call to AgentMock.Members with params: %#v", *m.MembersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMembers != nil && mm_atomic.LoadUint64(&m.afterMembersCounter) < 1 {
		m.t.Error("Expected call to AgentMock.Members")
	}
}

type mAgentMockMetrics struct {
	mock               *AgentMock
	defaultExpectation *AgentMockMetricsExpectation
	expectations       []*AgentMockMetricsExpectation

	callArgs []*AgentMockMetricsParams
	mutex    sync.RWMutex
}

// AgentMockMetricsExpectation specifies expectation struct of the Agent.Metrics
type AgentMockMetricsExpectation struct {
	mock    *AgentMock
	params  *AgentMockMetricsParams
	results *AgentMockMetricsResults
	Counter uint64
}

// AgentMockMetricsParams contains parameters of the Agent.Metrics
type AgentMockMetricsParams struct {
	ctx Ctx
}

// AgentMockMetricsResults contains results of the Agent.Metrics
type AgentMockMetricsResults struct {
	m1  Metrics
	err error
}

// Expect sets up expected params for Agent.Metrics
func (mmMetrics *mAgentMockMetrics) Expect(ctx Ctx) *mAgentMockMetrics {
	if mmMetrics.mock.funcMetrics != nil {
		mmMetrics.mock.t.Fatalf("AgentMock.Metrics mock is already set by Set")
	}

	if mmMetrics.defaultExpectation == nil {
		mmMetrics.defaultExpectation = &AgentMockMetricsExpectation{}
	}

	mmMetrics.defaultExpectation.params = &AgentMockMetricsParams{ctx}
	for _, e := range mmMetrics.expectations {
		if minimock.Equal(e.params, mmMetrics.defaultExpectation.params) {
			mmMetrics.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMetrics.defaultExpectation.params)
		}
	}

	return mmMetrics
}

// Inspect accepts an inspector function that has same arguments as the Agent.Metrics
func (mmMetrics *mAgentMockMetrics) Inspect(f func(ctx Ctx)) *mAgentMockMetrics {
	if mmMetrics.mock.inspectFuncMetrics != nil {
		mmMetrics.mock.t.Fatalf("Inspect function is already set for AgentMock.Metrics")
	}

	mmMetrics.mock.inspectFuncMetrics = f

	return mmMetrics
}

// Return sets up results that will be returned by Agent.Metrics
func (mmMetrics *mAgentMockMetrics) Return(m1 Metrics, err error) *AgentMock {
	if mmMetrics.mock.funcMetrics != nil {
		mmMetrics.mock.t.Fatalf("AgentMock.Metrics mock is already set by Set")
	}

	if mmMetrics.defaultExpectation == nil {
		mmMetrics.defaultExpectation = &AgentMockMetricsExpectation{mock: mmMetrics.mock}
	}
	mmMetrics.defaultExpectation.results = &AgentMockMetricsResults{m1, err}
	return mmMetrics.mock
}

//Set uses given function f to mock the Agent.Metrics method
func (mmMetrics *mAgentMockMetrics) Set(f func(ctx Ctx) (m1 Metrics, err error)) *AgentMock {
	if mmMetrics.defaultExpectation != nil {
		mmMetrics.mock.t.Fatalf("Default expectation is already set for the Agent.Metrics method")
	}

	if len(mmMetrics.expectations) > 0 {
		mmMetrics.mock.t.Fatalf("Some expectations are already set for the Agent.Metrics method")
	}

	mmMetrics.mock.funcMetrics = f
	return mmMetrics.mock
}

// When sets expectation for the Agent.Metrics which will trigger the result defined by the following
// Then helper
func (mmMetrics *mAgentMockMetrics) When(ctx Ctx) *AgentMockMetricsExpectation {
	if mmMetrics.mock.funcMetrics != nil {
		mmMetrics.mock.t.Fatalf("AgentMock.Metrics mock is already set by Set")
	}

	expectation := &AgentMockMetricsExpectation{
		mock:   mmMetrics.mock,
		params: &AgentMockMetricsParams{ctx},
	}
	mmMetrics.expectations = append(mmMetrics.expectations, expectation)
	return expectation
}

// Then sets up Agent.Metrics return parameters for the expectation previously defined by the When method
func (e *AgentMockMetricsExpectation) Then(m1 Metrics, err error) *AgentMock {
	e.results = &AgentMockMetricsResults{m1, err}
	return e.mock
}

// Metrics implements Agent
func (mmMetrics *AgentMock) Metrics(ctx Ctx) (m1 Metrics, err error) {
	mm_atomic.AddUint64(&mmMetrics.beforeMetricsCounter, 1)
	defer mm_atomic.AddUint64(&mmMetrics.afterMetricsCounter, 1)

	if mmMetrics.inspectFuncMetrics != nil {
		mmMetrics.inspectFuncMetrics(ctx)
	}

	mm_params := &AgentMockMetricsParams{ctx}

	// Record call args
	mmMetrics.MetricsMock.mutex.Lock()
	mmMetrics.MetricsMock.callArgs = append(mmMetrics.MetricsMock.callArgs, mm_params)
	mmMetrics.MetricsMock.mutex.Unlock()

	for _, e := range mmMetrics.MetricsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmMetrics.MetricsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMetrics.MetricsMock.defaultExpectation.Counter, 1)
		mm_want := mmMetrics.MetricsMock.defaultExpectation.params
		mm_got := AgentMockMetricsParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMetrics.t.Errorf("AgentMock.Metrics got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMetrics.MetricsMock.defaultExpectation.results
		if mm_results == nil {
			mmMetrics.t.Fatal("No results are set for the AgentMock.Metrics")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmMetrics.funcMetrics != nil {
		return mmMetrics.funcMetrics(ctx)
	}
	mmMetrics.t.Fatalf("Unexpected call to AgentMock.Metrics. %v", ctx)
	return
}

// MetricsAfterCounter returns a count of finished AgentMock.Metrics invocations
func (mmMetrics *AgentMock) MetricsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMetrics.afterMetricsCounter)
}

// MetricsBeforeCounter returns a count of AgentMock.Metrics invocations
func (mmMetrics *AgentMock) MetricsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMetrics.beforeMetricsCounter)
}

// Calls returns a list of arguments used in each call to AgentMock.Metrics.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMetrics *mAgentMockMetrics) Calls() []*AgentMockMetricsParams {
	mmMetrics.mutex.RLock()

	argCopy := make([]*AgentMockMetricsParams, len(mmMetrics.callArgs))
	copy(argCopy, mmMetrics.callArgs)

	mmMetrics.mutex.RUnlock()

	return argCopy
}

// MinimockMetricsDone returns true if the count of the Metrics invocations corresponds
// the number of defined expectations
func (m *AgentMock) MinimockMetricsDone() bool {
	for _, e := range m.MetricsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MetricsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMetricsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMetrics != nil && mm_atomic.LoadUint64(&m.afterMetricsCounter) < 1 {
		return false
	}
	return true
}

// MinimockMetricsInspect logs each unmet expectation
func (m *AgentMock) MinimockMetricsInspect() {
	for _, e := range m.MetricsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AgentMock.Metrics with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MetricsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMetricsCounter) < 1 {
		if m.MetricsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AgentMock.Metrics")
		} else {
			m.t.Errorf("Expected call to AgentMock.Metrics with params: %#v", *m.MetricsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMetrics != nil && mm_atomic.LoadUint64(&m.afterMetricsCounter) < 1 {
		m.t.Error("Expected call to AgentMock.Metrics")
	}
}

type mAgentMockReload struct {
	mock               *AgentMock
	defaultExpectation *AgentMockReloadExpectation
	expectations       []*AgentMockReloadExpectation

	callArgs []*AgentMockReloadParams
	mutex    sync.RWMutex
}

// AgentMockReloadExpectation specifies expectation struct of the Agent.Reload
type AgentMockReloadExpectation struct {
	mock    *AgentMock
	params  *AgentMockReloadParams
	results *AgentMockReloadResults
	Counter uint64
}

// AgentMockReloadParams contains parameters of the Agent.Reload
type AgentMockReloadParams struct {
	ctx Ctx
}

// AgentMockReloadResults contains results of the Agent.Reload
type AgentMockReloadResults struct {
	err error
}

// Expect sets up expected params for Agent.Reload
func (mmReload *mAgentMockReload) Expect(ctx Ctx) *mAgentMockReload {
	if mmReload.mock.funcReload != nil {
		mmReload.mock.t.Fatalf("AgentMock.Reload mock is already set by Set")
	}

	if mmReload.defaultExpectation == nil {
		mmReload.defaultExpectation = &AgentMockReloadExpectation{}
	}

	mmReload.defaultExpectation.params = &AgentMockReloadParams{ctx}
	for _, e := range mmReload.expectations {
		if minimock.Equal(e.params, mmReload.defaultExpectation.params) {
			mmReload.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReload.defaultExpectation.params)
		}
	}

	return mmReload
}

// Inspect accepts an inspector function that has same arguments as the Agent.Reload
func (mmReload *mAgentMockReload) Inspect(f func(ctx Ctx)) *mAgentMockReload {
	if mmReload.mock.inspectFuncReload != nil {
		mmReload.mock.t.Fatalf("Inspect function is already set for AgentMock.Reload")
	}

	mmReload.mock.inspectFuncReload = f

	return mmReload
}

// Return sets up results that will be returned by Agent.Reload
func (mmReload *mAgentMockReload) Return(err error) *AgentMock {
	if mmReload.mock.funcReload != nil {
		mmReload.mock.t.Fatalf("AgentMock.Reload mock is already set by Set")
	}

	if mmReload.defaultExpectation == nil {
		mmReload.defaultExpectation = &AgentMockReloadExpectation{mock: mmReload.mock}
	}
	mmReload.defaultExpectation.results = &AgentMockReloadResults{err}
	return mmReload.mock
}

//Set uses given function f to mock the Agent.Reload method
func (mmReload *mAgentMockReload) Set(f func(ctx Ctx) (err error)) *AgentMock {
	if mmReload.defaultExpectation != nil {
		mmReload.mock.t.Fatalf("Default expectation is already set for the Agent.Reload method")
	}

	if len(mmReload.expectations) > 0 {
		mmReload.mock.t.Fatalf("Some expectations are already set for the Agent.Reload method")
	}

	mmReload.mock.funcReload = f
	return mmReload.mock
}

// When sets expectation for the Agent.Reload which will trigger the result defined by the following
// Then helper
func (mmReload *mAgentMockReload) When(ctx Ctx) *AgentMockReloadExpectation {
	if mmReload.mock.funcReload != nil {
		mmReload.mock.t.Fatalf("AgentMock.Reload mock is already set by Set")
	}

	expectation := &AgentMockReloadExpectation{
		mock:   mmReload.mock,
		params: &AgentMockReloadParams{ctx},
	}
	mmReload.expectations = append(mmReload.expectations, expectation)
	return expectation
}

// Then sets up Agent.Reload return parameters for the expectation previously defined by the When method
func (e *AgentMockReloadExpectation) Then(err error) *AgentMock {
	e.results = &AgentMockReloadResults{err}
	return e.mock
}

// Reload implements Agent
func (mmReload *AgentMock) Reload(ctx Ctx) (err error) {
	mm_atomic.AddUint64(&mmReload.beforeReloadCounter, 1)
	defer mm_atomic.AddUint64(&mmReload.afterReloadCounter, 1)

	if mmReload.inspectFuncReload != nil {
		mmReload.inspectFuncReload(ctx)
	}

	mm_params := &AgentMockReloadParams{ctx}

	// Record call args
	mmReload.ReloadMock.mutex.Lock()
	mmReload.ReloadMock.callArgs = append(mmReload.ReloadMock.callArgs, mm_params)
	mmReload.ReloadMock.mutex.Unlock()

	for _, e := range mmReload.ReloadMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReload.ReloadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReload.ReloadMock.defaultExpectation.Counter, 1)
		mm_want := mmReload.ReloadMock.defaultExpectation.params
		mm_got := AgentMockReloadParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReload.t.Errorf("AgentMock.Reload got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReload.ReloadMock.defaultExpectation.results
		if mm_results == nil {
			mmReload.t.Fatal("No results are set for the AgentMock.Reload")
		}
		return (*mm_results).err
	}
	if mmReload.funcReload != nil {
		return mmReload.funcReload(ctx)
	}
	mmReload.t.Fatalf("Unexpected call to AgentMock.Reload. %v", ctx)
	return
}

// ReloadAfterCounter returns a count of finished AgentMock.Reload invocations
func (mmReload *AgentMock) ReloadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReload.afterReloadCounter)
}

// ReloadBeforeCounter returns a count of AgentMock.Reload invocations
func (mmReload *AgentMock) ReloadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReload.beforeReloadCounter)
}

// Calls returns a list of arguments used in each call to AgentMock.Reload.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReload *mAgentMockReload) Calls() []*AgentMockReloadParams {
	mmReload.mutex.RLock()

	argCopy := make([]*AgentMockReloadParams, len(mmReload.callArgs))
	copy(argCopy, mmReload.callArgs)

	mmReload.mutex.RUnlock()

	return argCopy
}

// MinimockReloadDone returns true if the count of the Reload invocations corresponds
// the number of defined expectations
func (m *AgentMock) MinimockReloadDone() bool {
	for _, e := range m.ReloadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReloadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReloadCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReload != nil && mm_atomic.LoadUint64(&m.afterReloadCounter) < 1 {
		return false
	}
	return true
}

// MinimockReloadInspect logs each unmet expectation
func (m *AgentMock) MinimockReloadInspect() {
	for _, e := range m.ReloadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AgentMock.Reload with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReloadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReloadCounter) < 1 {
		if m.ReloadMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AgentMock.Reload")
		} else {
			m.t.Errorf("Expected call to AgentMock.Reload with params: %#v", *m.ReloadMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReload != nil && mm_atomic.LoadUint64(&m.afterReloadCounter) < 1 {
		m.t.Error("Expected call to AgentMock.Reload")
	}
}

type mAgentMockSelf struct {
	mock               *AgentMock
	defaultExpectation *AgentMockSelfExpectation
	expectations       []*AgentMockSelfExpectation

	callArgs []*AgentMockSelfParams
	mutex    sync.RWMutex
}

// AgentMockSelfExpectation specifies expectation struct of the Agent.Self
type AgentMockSelfExpectation struct {
	mock    *AgentMock
	params  *AgentMockSelfParams
	results *AgentMockSelfResults
	Counter uint64
}

// AgentMockSelfParams contains parameters of the Agent.Self
type AgentMockSelfParams struct {
	ctx Ctx
}

// AgentMockSelfResults contains results of the Agent.Self
type AgentMockSelfResults struct {
	a1  AgentInfo
	err error
}

// Expect sets up expected params for Agent.Self
func (mmSelf *mAgentMockSelf) Expect(ctx Ctx) *mAgentMockSelf {
	if mmSelf.mock.funcSelf != nil {
		mmSelf.mock.t.Fatalf("AgentMock.Self mock is already set by Set")
	}

	if mmSelf.defaultExpectation == nil {
		mmSelf.defaultExpectation = &AgentMockSelfExpectation{}
	}

	mmSelf.defaultExpectation.params = &AgentMockSelfParams{ctx}
	for _, e := range mmSelf.expectations {
		if minimock.Equal(e.params, mmSelf.defaultExpectation.params) {
			mmSelf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelf.defaultExpectation.params)
		}
	}

	return mmSelf
}

// Inspect accepts an inspector function that has same arguments as the Agent.Self
func (mmSelf *mAgentMockSelf) Inspect(f func(ctx Ctx)) *mAgentMockSelf {
	if mmSelf.mock.inspectFuncSelf != nil {
		mmSelf.mock.t.Fatalf("Inspect function is already set for AgentMock.Self")
	}

	mmSelf.mock.inspectFuncSelf = f

	return mmSelf
}

// Return sets up results that will be returned by Agent.Self
func (mmSelf *mAgentMockSelf) Return(a1 AgentInfo, err error) *AgentMock {
	if mmSelf.mock.funcSelf != nil {
		mmSelf.mock.t.Fatalf("AgentMock.Self mock is already set by Set")
	}

	if mmSelf.defaultExpectation == nil {
		mmSelf.defaultExpectation = &AgentMockSelfExpectation{mock: mmSelf.mock}
	}
	mmSelf.defaultExpectation.results = &AgentMockSelfResults{a1, err}
	return mmSelf.mock
}

//Set uses given function f to mock the Agent.Self method
func (mmSelf *mAgentMockSelf) Set(f func(ctx Ctx) (a1 AgentInfo, err error)) *AgentMock {
	if mmSelf.defaultExpectation != nil {
		mmSelf.mock.t.Fatalf("Default expectation is already set for the Agent.Self method")
	}

	if len(mmSelf.expectations) > 0 {
		mmSelf.mock.t.Fatalf("Some expectations are already set for the Agent.Self method")
	}

	mmSelf.mock.funcSelf = f
	return mmSelf.mock
}

// When sets expectation for the Agent.Self which will trigger the result defined by the following
// Then helper
func (mmSelf *mAgentMockSelf) When(ctx Ctx) *AgentMockSelfExpectation {
	if mmSelf.mock.funcSelf != nil {
		mmSelf.mock.t.Fatalf("AgentMock.Self mock is already set by Set")
	}

	expectation := &AgentMockSelfExpectation{
		mock:   mmSelf.mock,
		params: &AgentMockSelfParams{ctx},
	}
	mmSelf.expectations = append(mmSelf.expectations, expectation)
	return expectation
}

// Then sets up Agent.Self return parameters for the expectation previously defined by the When method
func (e *AgentMockSelfExpectation) Then(a1 AgentInfo, err error) *AgentMock {
	e.results = &AgentMockSelfResults{a1, err}
	return e.mock
}

// Self implements Agent
func (mmSelf *AgentMock) Self(ctx Ctx) (a1 AgentInfo, err error) {
	mm_atomic.AddUint64(&mmSelf.beforeSelfCounter, 1)
	defer mm_atomic.AddUint64(&mmSelf.afterSelfCounter, 1)

	if mmSelf.inspectFuncSelf != nil {
		mmSelf.inspectFuncSelf(ctx)
	}

	mm_params := &AgentMockSelfParams{ctx}

	// Record call args
	mmSelf.SelfMock.mutex.Lock()
	mmSelf.SelfMock.callArgs = append(mmSelf.SelfMock.callArgs, mm_params)
	mmSelf.SelfMock.mutex.Unlock()

	for _, e := range mmSelf.SelfMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.a1, e.results.err
		}
	}

	if mmSelf.SelfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelf.SelfMock.defaultExpectation.Counter, 1)
		mm_want := mmSelf.SelfMock.defaultExpectation.params
		mm_got := AgentMockSelfParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelf.t.Errorf("AgentMock.Self got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelf.SelfMock.defaultExpectation.results
		if mm_results == nil {
			mmSelf.t.Fatal("No results are set for the AgentMock.Self")
		}
		return (*mm_results).a1, (*mm_results).err
	}
	if mmSelf.funcSelf != nil {
		return mmSelf.funcSelf(ctx)
	}
	mmSelf.t.Fatalf("Unexpected call to AgentMock.Self. %v", ctx)
	return
}

// SelfAfterCounter returns a count of finished AgentMock.Self invocations
func (mmSelf *AgentMock) SelfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelf.afterSelfCounter)
}

// SelfBeforeCounter returns a count of AgentMock.Self invocations
func (mmSelf *AgentMock) SelfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelf.beforeSelfCounter)
}

// Calls returns a list of arguments used in each call to AgentMock.Self.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelf *mAgentMockSelf) Calls() []*AgentMockSelfParams {
	mmSelf.mutex.RLock()

	argCopy := make([]*AgentMockSelfParams, len(mmSelf.callArgs))
	copy(argCopy, mmSelf.callArgs)

	mmSelf.mutex.RUnlock()

	return argCopy
}

// MinimockSelfDone returns true if the count of the Self invocations corresponds
// the number of defined expectations
func (m *AgentMock) MinimockSelfDone() bool {
	for _, e := range m.SelfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SelfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSelfCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelf != nil && mm_atomic.LoadUint64(&m.afterSelfCounter) < 1 {
		return false
	}
	return true
}

// MinimockSelfInspect logs each unmet expectation
func (m *AgentMock) MinimockSelfInspect() {
	for _, e := range m.SelfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AgentMock.Self with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SelfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSelfCounter) < 1 {
		if m.SelfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AgentMock.Self")
		} else {
			m.t.Errorf("Expected call to AgentMock.Self with params: %#v", *m.SelfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelf != nil && mm_atomic.LoadUint64(&m.afterSelfCounter) < 1 {
		m.t.Error("Expected call to AgentMock.Self")
	}
}

type mAgentMockSetACLToken struct {
	mock               *AgentMock
	defaultExpectation *AgentMockSetACLTokenExpectation
	expectations       []*AgentMockSetACLTokenExpectation

	callArgs []*AgentMockSetACLTokenParams
	mutex    sync.RWMutex
}

// AgentMockSetACLTokenExpectation specifies expectation struct of the Agent.SetACLToken
type AgentMockSetACLTokenExpectation struct {
	mock    *AgentMock
	params  *AgentMockSetACLTokenParams
	results *AgentMockSetACLTokenResults
	Counter uint64
}

// AgentMockSetACLTokenParams contains parameters of the Agent.SetACLToken
type AgentMockSetACLTokenParams struct {
	ctx   Ctx
	kind  string
	token string
}

// AgentMockSetACLTokenResults contains results of the Agent.SetACLToken
type AgentMockSetACLTokenResults struct {
	err error
}

// Expect sets up expected params for Agent.SetACLToken
func (mmSetACLToken *mAgentMockSetACLToken) Expect(ctx Ctx, kind string, token string) *mAgentMockSetACLToken {
	if mmSetACLToken.mock.funcSetACLToken != nil {
		mmSetACLToken.mock.t.Fatalf("AgentMock.SetACLToken mock is already set by Set")
	}

	if mmSetACLToken.defaultExpectation == nil {
		mmSetACLToken.defaultExpectation = &AgentMockSetACLTokenExpectation{}
	}

	mmSetACLToken.defaultExpectation.params = &AgentMockSetACLTokenParams{ctx, kind, token}
	for _, e := range mmSetACLToken.expectations {
		if minimock.Equal(e.params, mmSetACLToken.defaultExpectation.params) {
			mmSetACLToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetACLToken.defaultExpectation.params)
		}
	}

	return mmSetACLToken
}

// Inspect accepts an inspector function that has same arguments as the Agent.SetACLToken
func (mmSetACLToken *mAgentMockSetACLToken) Inspect(f func(ctx Ctx, kind string, token string)) *mAgentMockSetACLToken {
	if mmSetACLToken.mock.inspectFuncSetACLToken != nil {
		mmSetACLToken.mock.t.Fatalf("Inspect function is already set for AgentMock.SetACLToken")
	}

	mmSetACLToken.mock.inspectFuncSetACLToken = f

	return mmSetACLToken
}

// Return sets up results that will be returned by Agent.SetACLToken
func (mmSetACLToken *mAgentMockSetACLToken) Return(err error) *AgentMock {
	if mmSetACLToken.mock.funcSetACLToken != nil {
		mmSetACLToken.mock.t.Fatalf("AgentMock.SetACLToken mock is already set by Set")
	}

	if mmSetACLToken.defaultExpectation == nil {
		mmSetACLToken.defaultExpectation = &AgentMockSetACLTokenExpectation{mock: mmSetACLToken.mock}
	}
	mmSetACLToken.defaultExpectation.results = &AgentMockSetACLTokenResults{err}
	return mmSetACLToken.mock
}

//Set uses given function f to mock the Agent.SetACLToken method
func (mmSetACLToken *mAgentMockSetACLToken) Set(f func(ctx Ctx, kind string, token string) (err error)) *AgentMock {
	if mmSetACLToken.defaultExpectation != nil {
		mmSetACLToken.mock.t.Fatalf("Default expectation is already set for the Agent.SetACLToken method")
	}

	if len(mmSetACLToken.expectations) > 0 {
		mmSetACLToken.mock.t.Fatalf("Some expectations are already set for the Agent.SetACLToken method")
	}

	mmSetACLToken.mock.funcSetACLToken = f
	return mmSetACLToken.mock
}

// When sets expectation for the Agent.SetACLToken which will trigger the result defined by the following
// Then helper
func (mmSetACLToken *mAgentMockSetACLToken) When(ctx Ctx, kind string, token string) *AgentMockSetACLTokenExpectation {
	if mmSetACLToken.mock.funcSetACLToken != nil {
		mmSetACLToken.mock.t.Fatalf("AgentMock.SetACLToken mock is already set by Set")
	}

	expectation := &AgentMockSetACLTokenExpectation{
		mock:   mmSetACLToken.mock,
		params: &AgentMockSetACLTokenParams{ctx, kind, token},
	}
	mmSetACLToken.expectations = append(mmSetACLToken.expectations, expectation)
	return expectation
}

// Then sets up Agent.SetACLToken return parameters for the expectation previously defined by the When method
func (e *AgentMockSetACLTokenExpectation) Then(err error) *AgentMock {
	e.results = &AgentMockSetACLTokenResults{err}
	return e.mock
}

// SetACLToken implements Agent
func (mmSetACLToken *AgentMock) SetACLToken(ctx Ctx, kind string, token string) (err error) {
	mm_atomic.AddUint64(&mmSetACLToken.beforeSetACLTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmSetACLToken.afterSetACLTokenCounter, 1)

	if mmSetACLToken.inspectFuncSetACLToken != nil {
		mmSetACLToken.inspectFuncSetACLToken(ctx, kind, token)
	}

	mm_params := &AgentMockSetACLTokenParams{ctx, kind, token}

	// Record call args
	mmSetACLToken.SetACLTokenMock.mutex.Lock()
	mmSetACLToken.SetACLTokenMock.callArgs = append(mmSetACLToken.SetACLTokenMock.callArgs, mm_params)
	mmSetACLToken.SetACLTokenMock.mutex.Unlock()

	for _, e := range mmSetACLToken.SetACLTokenMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetACLToken.SetACLTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetACLToken.SetACLTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmSetACLToken.SetACLTokenMock.defaultExpectation.params
		mm_got := AgentMockSetACLTokenParams{ctx, kind, token}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetACLToken.t.Errorf("AgentMock.SetACLToken got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetACLToken.SetACLTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmSetACLToken.t.Fatal("No results are set for the AgentMock.SetACLToken")
		}
		return (*mm_results).err
	}
	if mmSetACLToken.funcSetACLToken != nil {
		return mmSetACLToken.funcSetACLToken(ctx, kind, token)
	}
	mmSetACLToken.t.Fatalf("Unexpected call to AgentMock.SetACLToken. %v %v %v", ctx, kind, token)
	return
}

// SetACLTokenAfterCounter returns a count of finished AgentMock.SetACLToken invocations
func (mmSetACLToken *AgentMock) SetACLTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetACLToken.afterSetACLTokenCounter)
}

// SetACLTokenBeforeCounter returns a count of AgentMock.SetACLToken invocations
func (mmSetACLToken *AgentMock) SetACLTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetACLToken.beforeSetACLTokenCounter)
}

// Calls returns a list of arguments used in each call to AgentMock.SetACLToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetACLToken *mAgentMockSetACLToken) Calls() []*AgentMockSetACLTokenParams {
	mmSetACLToken.mutex.RLock()

	argCopy := make([]*AgentMockSetACLTokenParams, len(mmSetACLToken.callArgs))
	copy(argCopy, mmSetACLToken.callArgs)

	mmSetACLToken.mutex.RUnlock()

	return argCopy
}

// MinimockSetACLTokenDone returns true if the count of the SetACLToken invocations corresponds
// the number of defined expectations
func (m *AgentMock) MinimockSetACLTokenDone() bool {
	for _, e := range m.SetACLTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetACLTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetACLTokenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetACLToken != nil && mm_atomic.LoadUint64(&m.afterSetACLTokenCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetACLTokenInspect logs each unmet expectation
func (m *AgentMock) MinimockSetACLTokenInspect() {
	for _, e := range m.SetACLTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AgentMock.SetACLToken with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetACLTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetACLTokenCounter) < 1 {
		if m.SetACLTokenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AgentMock.SetACLToken")
		} else {
			m.t.Errorf("Expected call to AgentMock.SetACLToken with params: %#v", *m.SetACLTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetACLToken != nil && mm_atomic.LoadUint64(&m.afterSetACLTokenCounter) < 1 {
		m.t.Error("Expected call to AgentMock.SetACLToken")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AgentMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockForceLeaveInspect()

		m.MinimockJoinInspect()

		m.MinimockLeaveInspect()

		m.MinimockMaintenanceModeInspect()

		m.MinimockMembersInspect()

		m.MinimockMetricsInspect()

		m.MinimockReloadInspect()

		m.MinimockSelfInspect()

		m.MinimockSetACLTokenInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AgentMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AgentMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockForceLeaveDone() &&
		m.MinimockJoinDone() &&
		m.MinimockLeaveDone() &&
		m.MinimockMaintenanceModeDone() &&
		m.MinimockMembersDone() &&
		m.MinimockMetricsDone() &&
		m.MinimockReloadDone() &&
		m.MinimockSelfDone() &&
		m.MinimockSetACLTokenDone()
}
