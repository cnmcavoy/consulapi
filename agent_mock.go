package consulapi

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
)

// AgentMock implements Agent
type AgentMock struct {
	t minimock.Tester

	funcMaintenanceMode          func(enabled bool, reason string) (err error)
	afterMaintenanceModeCounter  uint64
	beforeMaintenanceModeCounter uint64
	MaintenanceModeMock          mAgentMockMaintenanceMode

	funcMembers          func(wan bool) (aa1 []AgentInfo, err error)
	afterMembersCounter  uint64
	beforeMembersCounter uint64
	MembersMock          mAgentMockMembers

	funcReload          func() (err error)
	afterReloadCounter  uint64
	beforeReloadCounter uint64
	ReloadMock          mAgentMockReload

	funcSelf          func() (a1 AgentInfo, err error)
	afterSelfCounter  uint64
	beforeSelfCounter uint64
	SelfMock          mAgentMockSelf
}

// NewAgentMock returns a mock for Agent
func NewAgentMock(t minimock.Tester) *AgentMock {
	m := &AgentMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.MaintenanceModeMock = mAgentMockMaintenanceMode{mock: m}
	m.MaintenanceModeMock.callArgs = []*AgentMockMaintenanceModeParams{}

	m.MembersMock = mAgentMockMembers{mock: m}
	m.MembersMock.callArgs = []*AgentMockMembersParams{}

	m.ReloadMock = mAgentMockReload{mock: m}

	m.SelfMock = mAgentMockSelf{mock: m}

	return m
}

type mAgentMockMaintenanceMode struct {
	mock               *AgentMock
	defaultExpectation *AgentMockMaintenanceModeExpectation
	expectations       []*AgentMockMaintenanceModeExpectation

	callArgs []*AgentMockMaintenanceModeParams
	mutex    sync.RWMutex
}

// AgentMockMaintenanceModeExpectation specifies expectation struct of the Agent.MaintenanceMode
type AgentMockMaintenanceModeExpectation struct {
	mock    *AgentMock
	params  *AgentMockMaintenanceModeParams
	results *AgentMockMaintenanceModeResults
	Counter uint64
}

// AgentMockMaintenanceModeParams contains parameters of the Agent.MaintenanceMode
type AgentMockMaintenanceModeParams struct {
	enabled bool
	reason  string
}

// AgentMockMaintenanceModeResults contains results of the Agent.MaintenanceMode
type AgentMockMaintenanceModeResults struct {
	err error
}

// Expect sets up expected params for Agent.MaintenanceMode
func (mmMaintenanceMode *mAgentMockMaintenanceMode) Expect(enabled bool, reason string) *mAgentMockMaintenanceMode {
	if mmMaintenanceMode.mock.funcMaintenanceMode != nil {
		mmMaintenanceMode.mock.t.Fatalf("AgentMock.MaintenanceMode mock is already set by Set")
	}

	if mmMaintenanceMode.defaultExpectation == nil {
		mmMaintenanceMode.defaultExpectation = &AgentMockMaintenanceModeExpectation{}
	}

	mmMaintenanceMode.defaultExpectation.params = &AgentMockMaintenanceModeParams{enabled, reason}
	for _, e := range mmMaintenanceMode.expectations {
		if minimock.Equal(e.params, mmMaintenanceMode.defaultExpectation.params) {
			mmMaintenanceMode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMaintenanceMode.defaultExpectation.params)
		}
	}

	return mmMaintenanceMode
}

// Return sets up results that will be returned by Agent.MaintenanceMode
func (mmMaintenanceMode *mAgentMockMaintenanceMode) Return(err error) *AgentMock {
	if mmMaintenanceMode.mock.funcMaintenanceMode != nil {
		mmMaintenanceMode.mock.t.Fatalf("AgentMock.MaintenanceMode mock is already set by Set")
	}

	if mmMaintenanceMode.defaultExpectation == nil {
		mmMaintenanceMode.defaultExpectation = &AgentMockMaintenanceModeExpectation{mock: mmMaintenanceMode.mock}
	}
	mmMaintenanceMode.defaultExpectation.results = &AgentMockMaintenanceModeResults{err}
	return mmMaintenanceMode.mock
}

//Set uses given function f to mock the Agent.MaintenanceMode method
func (mmMaintenanceMode *mAgentMockMaintenanceMode) Set(f func(enabled bool, reason string) (err error)) *AgentMock {
	if mmMaintenanceMode.defaultExpectation != nil {
		mmMaintenanceMode.mock.t.Fatalf("Default expectation is already set for the Agent.MaintenanceMode method")
	}

	if len(mmMaintenanceMode.expectations) > 0 {
		mmMaintenanceMode.mock.t.Fatalf("Some expectations are already set for the Agent.MaintenanceMode method")
	}

	mmMaintenanceMode.mock.funcMaintenanceMode = f
	return mmMaintenanceMode.mock
}

// When sets expectation for the Agent.MaintenanceMode which will trigger the result defined by the following
// Then helper
func (mmMaintenanceMode *mAgentMockMaintenanceMode) When(enabled bool, reason string) *AgentMockMaintenanceModeExpectation {
	if mmMaintenanceMode.mock.funcMaintenanceMode != nil {
		mmMaintenanceMode.mock.t.Fatalf("AgentMock.MaintenanceMode mock is already set by Set")
	}

	expectation := &AgentMockMaintenanceModeExpectation{
		mock:   mmMaintenanceMode.mock,
		params: &AgentMockMaintenanceModeParams{enabled, reason},
	}
	mmMaintenanceMode.expectations = append(mmMaintenanceMode.expectations, expectation)
	return expectation
}

// Then sets up Agent.MaintenanceMode return parameters for the expectation previously defined by the When method
func (e *AgentMockMaintenanceModeExpectation) Then(err error) *AgentMock {
	e.results = &AgentMockMaintenanceModeResults{err}
	return e.mock
}

// MaintenanceMode implements Agent
func (mmMaintenanceMode *AgentMock) MaintenanceMode(enabled bool, reason string) (err error) {
	mm_atomic.AddUint64(&mmMaintenanceMode.beforeMaintenanceModeCounter, 1)
	defer mm_atomic.AddUint64(&mmMaintenanceMode.afterMaintenanceModeCounter, 1)

	params := &AgentMockMaintenanceModeParams{enabled, reason}

	// Record call args
	mmMaintenanceMode.MaintenanceModeMock.mutex.Lock()
	mmMaintenanceMode.MaintenanceModeMock.callArgs = append(mmMaintenanceMode.MaintenanceModeMock.callArgs, params)
	mmMaintenanceMode.MaintenanceModeMock.mutex.Unlock()

	for _, e := range mmMaintenanceMode.MaintenanceModeMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmMaintenanceMode.MaintenanceModeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMaintenanceMode.MaintenanceModeMock.defaultExpectation.Counter, 1)
		want := mmMaintenanceMode.MaintenanceModeMock.defaultExpectation.params
		got := AgentMockMaintenanceModeParams{enabled, reason}
		if want != nil && !minimock.Equal(*want, got) {
			mmMaintenanceMode.t.Errorf("AgentMock.MaintenanceMode got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmMaintenanceMode.MaintenanceModeMock.defaultExpectation.results
		if results == nil {
			mmMaintenanceMode.t.Fatal("No results are set for the AgentMock.MaintenanceMode")
		}
		return (*results).err
	}
	if mmMaintenanceMode.funcMaintenanceMode != nil {
		return mmMaintenanceMode.funcMaintenanceMode(enabled, reason)
	}
	mmMaintenanceMode.t.Fatalf("Unexpected call to AgentMock.MaintenanceMode. %v %v", enabled, reason)
	return
}

// MaintenanceModeAfterCounter returns a count of finished AgentMock.MaintenanceMode invocations
func (mmMaintenanceMode *AgentMock) MaintenanceModeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMaintenanceMode.afterMaintenanceModeCounter)
}

// MaintenanceModeBeforeCounter returns a count of AgentMock.MaintenanceMode invocations
func (mmMaintenanceMode *AgentMock) MaintenanceModeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMaintenanceMode.beforeMaintenanceModeCounter)
}

// Calls returns a list of arguments used in each call to AgentMock.MaintenanceMode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMaintenanceMode *mAgentMockMaintenanceMode) Calls() []*AgentMockMaintenanceModeParams {
	mmMaintenanceMode.mutex.RLock()

	argCopy := make([]*AgentMockMaintenanceModeParams, len(mmMaintenanceMode.callArgs))
	copy(argCopy, mmMaintenanceMode.callArgs)

	mmMaintenanceMode.mutex.RUnlock()

	return argCopy
}

// MinimockMaintenanceModeDone returns true if the count of the MaintenanceMode invocations corresponds
// the number of defined expectations
func (m *AgentMock) MinimockMaintenanceModeDone() bool {
	for _, e := range m.MaintenanceModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MaintenanceModeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMaintenanceModeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMaintenanceMode != nil && mm_atomic.LoadUint64(&m.afterMaintenanceModeCounter) < 1 {
		return false
	}
	return true
}

// MinimockMaintenanceModeInspect logs each unmet expectation
func (m *AgentMock) MinimockMaintenanceModeInspect() {
	for _, e := range m.MaintenanceModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AgentMock.MaintenanceMode with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MaintenanceModeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMaintenanceModeCounter) < 1 {
		if m.MaintenanceModeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AgentMock.MaintenanceMode")
		} else {
			m.t.Errorf("Expected call to AgentMock.MaintenanceMode with params: %#v", *m.MaintenanceModeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMaintenanceMode != nil && mm_atomic.LoadUint64(&m.afterMaintenanceModeCounter) < 1 {
		m.t.Error("Expected call to AgentMock.MaintenanceMode")
	}
}

type mAgentMockMembers struct {
	mock               *AgentMock
	defaultExpectation *AgentMockMembersExpectation
	expectations       []*AgentMockMembersExpectation

	callArgs []*AgentMockMembersParams
	mutex    sync.RWMutex
}

// AgentMockMembersExpectation specifies expectation struct of the Agent.Members
type AgentMockMembersExpectation struct {
	mock    *AgentMock
	params  *AgentMockMembersParams
	results *AgentMockMembersResults
	Counter uint64
}

// AgentMockMembersParams contains parameters of the Agent.Members
type AgentMockMembersParams struct {
	wan bool
}

// AgentMockMembersResults contains results of the Agent.Members
type AgentMockMembersResults struct {
	aa1 []AgentInfo
	err error
}

// Expect sets up expected params for Agent.Members
func (mmMembers *mAgentMockMembers) Expect(wan bool) *mAgentMockMembers {
	if mmMembers.mock.funcMembers != nil {
		mmMembers.mock.t.Fatalf("AgentMock.Members mock is already set by Set")
	}

	if mmMembers.defaultExpectation == nil {
		mmMembers.defaultExpectation = &AgentMockMembersExpectation{}
	}

	mmMembers.defaultExpectation.params = &AgentMockMembersParams{wan}
	for _, e := range mmMembers.expectations {
		if minimock.Equal(e.params, mmMembers.defaultExpectation.params) {
			mmMembers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMembers.defaultExpectation.params)
		}
	}

	return mmMembers
}

// Return sets up results that will be returned by Agent.Members
func (mmMembers *mAgentMockMembers) Return(aa1 []AgentInfo, err error) *AgentMock {
	if mmMembers.mock.funcMembers != nil {
		mmMembers.mock.t.Fatalf("AgentMock.Members mock is already set by Set")
	}

	if mmMembers.defaultExpectation == nil {
		mmMembers.defaultExpectation = &AgentMockMembersExpectation{mock: mmMembers.mock}
	}
	mmMembers.defaultExpectation.results = &AgentMockMembersResults{aa1, err}
	return mmMembers.mock
}

//Set uses given function f to mock the Agent.Members method
func (mmMembers *mAgentMockMembers) Set(f func(wan bool) (aa1 []AgentInfo, err error)) *AgentMock {
	if mmMembers.defaultExpectation != nil {
		mmMembers.mock.t.Fatalf("Default expectation is already set for the Agent.Members method")
	}

	if len(mmMembers.expectations) > 0 {
		mmMembers.mock.t.Fatalf("Some expectations are already set for the Agent.Members method")
	}

	mmMembers.mock.funcMembers = f
	return mmMembers.mock
}

// When sets expectation for the Agent.Members which will trigger the result defined by the following
// Then helper
func (mmMembers *mAgentMockMembers) When(wan bool) *AgentMockMembersExpectation {
	if mmMembers.mock.funcMembers != nil {
		mmMembers.mock.t.Fatalf("AgentMock.Members mock is already set by Set")
	}

	expectation := &AgentMockMembersExpectation{
		mock:   mmMembers.mock,
		params: &AgentMockMembersParams{wan},
	}
	mmMembers.expectations = append(mmMembers.expectations, expectation)
	return expectation
}

// Then sets up Agent.Members return parameters for the expectation previously defined by the When method
func (e *AgentMockMembersExpectation) Then(aa1 []AgentInfo, err error) *AgentMock {
	e.results = &AgentMockMembersResults{aa1, err}
	return e.mock
}

// Members implements Agent
func (mmMembers *AgentMock) Members(wan bool) (aa1 []AgentInfo, err error) {
	mm_atomic.AddUint64(&mmMembers.beforeMembersCounter, 1)
	defer mm_atomic.AddUint64(&mmMembers.afterMembersCounter, 1)

	params := &AgentMockMembersParams{wan}

	// Record call args
	mmMembers.MembersMock.mutex.Lock()
	mmMembers.MembersMock.callArgs = append(mmMembers.MembersMock.callArgs, params)
	mmMembers.MembersMock.mutex.Unlock()

	for _, e := range mmMembers.MembersMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.aa1, e.results.err
		}
	}

	if mmMembers.MembersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMembers.MembersMock.defaultExpectation.Counter, 1)
		want := mmMembers.MembersMock.defaultExpectation.params
		got := AgentMockMembersParams{wan}
		if want != nil && !minimock.Equal(*want, got) {
			mmMembers.t.Errorf("AgentMock.Members got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmMembers.MembersMock.defaultExpectation.results
		if results == nil {
			mmMembers.t.Fatal("No results are set for the AgentMock.Members")
		}
		return (*results).aa1, (*results).err
	}
	if mmMembers.funcMembers != nil {
		return mmMembers.funcMembers(wan)
	}
	mmMembers.t.Fatalf("Unexpected call to AgentMock.Members. %v", wan)
	return
}

// MembersAfterCounter returns a count of finished AgentMock.Members invocations
func (mmMembers *AgentMock) MembersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMembers.afterMembersCounter)
}

// MembersBeforeCounter returns a count of AgentMock.Members invocations
func (mmMembers *AgentMock) MembersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMembers.beforeMembersCounter)
}

// Calls returns a list of arguments used in each call to AgentMock.Members.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMembers *mAgentMockMembers) Calls() []*AgentMockMembersParams {
	mmMembers.mutex.RLock()

	argCopy := make([]*AgentMockMembersParams, len(mmMembers.callArgs))
	copy(argCopy, mmMembers.callArgs)

	mmMembers.mutex.RUnlock()

	return argCopy
}

// MinimockMembersDone returns true if the count of the Members invocations corresponds
// the number of defined expectations
func (m *AgentMock) MinimockMembersDone() bool {
	for _, e := range m.MembersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MembersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMembersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMembers != nil && mm_atomic.LoadUint64(&m.afterMembersCounter) < 1 {
		return false
	}
	return true
}

// MinimockMembersInspect logs each unmet expectation
func (m *AgentMock) MinimockMembersInspect() {
	for _, e := range m.MembersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AgentMock.Members with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MembersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMembersCounter) < 1 {
		if m.MembersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AgentMock.Members")
		} else {
			m.t.Errorf("Expected call to AgentMock.Members with params: %#v", *m.MembersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMembers != nil && mm_atomic.LoadUint64(&m.afterMembersCounter) < 1 {
		m.t.Error("Expected call to AgentMock.Members")
	}
}

type mAgentMockReload struct {
	mock               *AgentMock
	defaultExpectation *AgentMockReloadExpectation
	expectations       []*AgentMockReloadExpectation
}

// AgentMockReloadExpectation specifies expectation struct of the Agent.Reload
type AgentMockReloadExpectation struct {
	mock *AgentMock

	results *AgentMockReloadResults
	Counter uint64
}

// AgentMockReloadResults contains results of the Agent.Reload
type AgentMockReloadResults struct {
	err error
}

// Expect sets up expected params for Agent.Reload
func (mmReload *mAgentMockReload) Expect() *mAgentMockReload {
	if mmReload.mock.funcReload != nil {
		mmReload.mock.t.Fatalf("AgentMock.Reload mock is already set by Set")
	}

	if mmReload.defaultExpectation == nil {
		mmReload.defaultExpectation = &AgentMockReloadExpectation{}
	}

	return mmReload
}

// Return sets up results that will be returned by Agent.Reload
func (mmReload *mAgentMockReload) Return(err error) *AgentMock {
	if mmReload.mock.funcReload != nil {
		mmReload.mock.t.Fatalf("AgentMock.Reload mock is already set by Set")
	}

	if mmReload.defaultExpectation == nil {
		mmReload.defaultExpectation = &AgentMockReloadExpectation{mock: mmReload.mock}
	}
	mmReload.defaultExpectation.results = &AgentMockReloadResults{err}
	return mmReload.mock
}

//Set uses given function f to mock the Agent.Reload method
func (mmReload *mAgentMockReload) Set(f func() (err error)) *AgentMock {
	if mmReload.defaultExpectation != nil {
		mmReload.mock.t.Fatalf("Default expectation is already set for the Agent.Reload method")
	}

	if len(mmReload.expectations) > 0 {
		mmReload.mock.t.Fatalf("Some expectations are already set for the Agent.Reload method")
	}

	mmReload.mock.funcReload = f
	return mmReload.mock
}

// Reload implements Agent
func (mmReload *AgentMock) Reload() (err error) {
	mm_atomic.AddUint64(&mmReload.beforeReloadCounter, 1)
	defer mm_atomic.AddUint64(&mmReload.afterReloadCounter, 1)

	if mmReload.ReloadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReload.ReloadMock.defaultExpectation.Counter, 1)

		results := mmReload.ReloadMock.defaultExpectation.results
		if results == nil {
			mmReload.t.Fatal("No results are set for the AgentMock.Reload")
		}
		return (*results).err
	}
	if mmReload.funcReload != nil {
		return mmReload.funcReload()
	}
	mmReload.t.Fatalf("Unexpected call to AgentMock.Reload.")
	return
}

// ReloadAfterCounter returns a count of finished AgentMock.Reload invocations
func (mmReload *AgentMock) ReloadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReload.afterReloadCounter)
}

// ReloadBeforeCounter returns a count of AgentMock.Reload invocations
func (mmReload *AgentMock) ReloadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReload.beforeReloadCounter)
}

// MinimockReloadDone returns true if the count of the Reload invocations corresponds
// the number of defined expectations
func (m *AgentMock) MinimockReloadDone() bool {
	for _, e := range m.ReloadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReloadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReloadCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReload != nil && mm_atomic.LoadUint64(&m.afterReloadCounter) < 1 {
		return false
	}
	return true
}

// MinimockReloadInspect logs each unmet expectation
func (m *AgentMock) MinimockReloadInspect() {
	for _, e := range m.ReloadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AgentMock.Reload")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReloadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReloadCounter) < 1 {
		m.t.Error("Expected call to AgentMock.Reload")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReload != nil && mm_atomic.LoadUint64(&m.afterReloadCounter) < 1 {
		m.t.Error("Expected call to AgentMock.Reload")
	}
}

type mAgentMockSelf struct {
	mock               *AgentMock
	defaultExpectation *AgentMockSelfExpectation
	expectations       []*AgentMockSelfExpectation
}

// AgentMockSelfExpectation specifies expectation struct of the Agent.Self
type AgentMockSelfExpectation struct {
	mock *AgentMock

	results *AgentMockSelfResults
	Counter uint64
}

// AgentMockSelfResults contains results of the Agent.Self
type AgentMockSelfResults struct {
	a1  AgentInfo
	err error
}

// Expect sets up expected params for Agent.Self
func (mmSelf *mAgentMockSelf) Expect() *mAgentMockSelf {
	if mmSelf.mock.funcSelf != nil {
		mmSelf.mock.t.Fatalf("AgentMock.Self mock is already set by Set")
	}

	if mmSelf.defaultExpectation == nil {
		mmSelf.defaultExpectation = &AgentMockSelfExpectation{}
	}

	return mmSelf
}

// Return sets up results that will be returned by Agent.Self
func (mmSelf *mAgentMockSelf) Return(a1 AgentInfo, err error) *AgentMock {
	if mmSelf.mock.funcSelf != nil {
		mmSelf.mock.t.Fatalf("AgentMock.Self mock is already set by Set")
	}

	if mmSelf.defaultExpectation == nil {
		mmSelf.defaultExpectation = &AgentMockSelfExpectation{mock: mmSelf.mock}
	}
	mmSelf.defaultExpectation.results = &AgentMockSelfResults{a1, err}
	return mmSelf.mock
}

//Set uses given function f to mock the Agent.Self method
func (mmSelf *mAgentMockSelf) Set(f func() (a1 AgentInfo, err error)) *AgentMock {
	if mmSelf.defaultExpectation != nil {
		mmSelf.mock.t.Fatalf("Default expectation is already set for the Agent.Self method")
	}

	if len(mmSelf.expectations) > 0 {
		mmSelf.mock.t.Fatalf("Some expectations are already set for the Agent.Self method")
	}

	mmSelf.mock.funcSelf = f
	return mmSelf.mock
}

// Self implements Agent
func (mmSelf *AgentMock) Self() (a1 AgentInfo, err error) {
	mm_atomic.AddUint64(&mmSelf.beforeSelfCounter, 1)
	defer mm_atomic.AddUint64(&mmSelf.afterSelfCounter, 1)

	if mmSelf.SelfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelf.SelfMock.defaultExpectation.Counter, 1)

		results := mmSelf.SelfMock.defaultExpectation.results
		if results == nil {
			mmSelf.t.Fatal("No results are set for the AgentMock.Self")
		}
		return (*results).a1, (*results).err
	}
	if mmSelf.funcSelf != nil {
		return mmSelf.funcSelf()
	}
	mmSelf.t.Fatalf("Unexpected call to AgentMock.Self.")
	return
}

// SelfAfterCounter returns a count of finished AgentMock.Self invocations
func (mmSelf *AgentMock) SelfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelf.afterSelfCounter)
}

// SelfBeforeCounter returns a count of AgentMock.Self invocations
func (mmSelf *AgentMock) SelfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelf.beforeSelfCounter)
}

// MinimockSelfDone returns true if the count of the Self invocations corresponds
// the number of defined expectations
func (m *AgentMock) MinimockSelfDone() bool {
	for _, e := range m.SelfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SelfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSelfCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelf != nil && mm_atomic.LoadUint64(&m.afterSelfCounter) < 1 {
		return false
	}
	return true
}

// MinimockSelfInspect logs each unmet expectation
func (m *AgentMock) MinimockSelfInspect() {
	for _, e := range m.SelfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AgentMock.Self")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SelfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSelfCounter) < 1 {
		m.t.Error("Expected call to AgentMock.Self")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelf != nil && mm_atomic.LoadUint64(&m.afterSelfCounter) < 1 {
		m.t.Error("Expected call to AgentMock.Self")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AgentMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockMaintenanceModeInspect()

		m.MinimockMembersInspect()

		m.MinimockReloadInspect()

		m.MinimockSelfInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AgentMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AgentMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockMaintenanceModeDone() &&
		m.MinimockMembersDone() &&
		m.MinimockReloadDone() &&
		m.MinimockSelfDone()
}
