package consulapi

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
)

// LeaderSessionMock implements LeaderSession
type LeaderSessionMock struct {
	t minimock.Tester

	funcAbdicate          func() (err error)
	afterAbdicateCounter  uint64
	beforeAbdicateCounter uint64
	AbdicateMock          mLeaderSessionMockAbdicate

	funcCurrent          func() (s1 string, err error)
	afterCurrentCounter  uint64
	beforeCurrentCounter uint64
	CurrentMock          mLeaderSessionMockCurrent

	funcSessionID          func() (s1 string)
	afterSessionIDCounter  uint64
	beforeSessionIDCounter uint64
	SessionIDMock          mLeaderSessionMockSessionID
}

// NewLeaderSessionMock returns a mock for LeaderSession
func NewLeaderSessionMock(t minimock.Tester) *LeaderSessionMock {
	m := &LeaderSessionMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AbdicateMock = mLeaderSessionMockAbdicate{mock: m}

	m.CurrentMock = mLeaderSessionMockCurrent{mock: m}

	m.SessionIDMock = mLeaderSessionMockSessionID{mock: m}

	return m
}

type mLeaderSessionMockAbdicate struct {
	mock               *LeaderSessionMock
	defaultExpectation *LeaderSessionMockAbdicateExpectation
	expectations       []*LeaderSessionMockAbdicateExpectation
}

// LeaderSessionMockAbdicateExpectation specifies expectation struct of the LeaderSession.Abdicate
type LeaderSessionMockAbdicateExpectation struct {
	mock *LeaderSessionMock

	results *LeaderSessionMockAbdicateResults
	Counter uint64
}

// LeaderSessionMockAbdicateResults contains results of the LeaderSession.Abdicate
type LeaderSessionMockAbdicateResults struct {
	err error
}

// Expect sets up expected params for LeaderSession.Abdicate
func (mmAbdicate *mLeaderSessionMockAbdicate) Expect() *mLeaderSessionMockAbdicate {
	if mmAbdicate.mock.funcAbdicate != nil {
		mmAbdicate.mock.t.Fatalf("LeaderSessionMock.Abdicate mock is already set by Set")
	}

	if mmAbdicate.defaultExpectation == nil {
		mmAbdicate.defaultExpectation = &LeaderSessionMockAbdicateExpectation{}
	}

	return mmAbdicate
}

// Return sets up results that will be returned by LeaderSession.Abdicate
func (mmAbdicate *mLeaderSessionMockAbdicate) Return(err error) *LeaderSessionMock {
	if mmAbdicate.mock.funcAbdicate != nil {
		mmAbdicate.mock.t.Fatalf("LeaderSessionMock.Abdicate mock is already set by Set")
	}

	if mmAbdicate.defaultExpectation == nil {
		mmAbdicate.defaultExpectation = &LeaderSessionMockAbdicateExpectation{mock: mmAbdicate.mock}
	}
	mmAbdicate.defaultExpectation.results = &LeaderSessionMockAbdicateResults{err}
	return mmAbdicate.mock
}

//Set uses given function f to mock the LeaderSession.Abdicate method
func (mmAbdicate *mLeaderSessionMockAbdicate) Set(f func() (err error)) *LeaderSessionMock {
	if mmAbdicate.defaultExpectation != nil {
		mmAbdicate.mock.t.Fatalf("Default expectation is already set for the LeaderSession.Abdicate method")
	}

	if len(mmAbdicate.expectations) > 0 {
		mmAbdicate.mock.t.Fatalf("Some expectations are already set for the LeaderSession.Abdicate method")
	}

	mmAbdicate.mock.funcAbdicate = f
	return mmAbdicate.mock
}

// Abdicate implements LeaderSession
func (mmAbdicate *LeaderSessionMock) Abdicate() (err error) {
	mm_atomic.AddUint64(&mmAbdicate.beforeAbdicateCounter, 1)
	defer mm_atomic.AddUint64(&mmAbdicate.afterAbdicateCounter, 1)

	if mmAbdicate.AbdicateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAbdicate.AbdicateMock.defaultExpectation.Counter, 1)

		results := mmAbdicate.AbdicateMock.defaultExpectation.results
		if results == nil {
			mmAbdicate.t.Fatal("No results are set for the LeaderSessionMock.Abdicate")
		}
		return (*results).err
	}
	if mmAbdicate.funcAbdicate != nil {
		return mmAbdicate.funcAbdicate()
	}
	mmAbdicate.t.Fatalf("Unexpected call to LeaderSessionMock.Abdicate.")
	return
}

// AbdicateAfterCounter returns a count of finished LeaderSessionMock.Abdicate invocations
func (mmAbdicate *LeaderSessionMock) AbdicateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAbdicate.afterAbdicateCounter)
}

// AbdicateBeforeCounter returns a count of LeaderSessionMock.Abdicate invocations
func (mmAbdicate *LeaderSessionMock) AbdicateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAbdicate.beforeAbdicateCounter)
}

// MinimockAbdicateDone returns true if the count of the Abdicate invocations corresponds
// the number of defined expectations
func (m *LeaderSessionMock) MinimockAbdicateDone() bool {
	for _, e := range m.AbdicateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AbdicateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAbdicateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAbdicate != nil && mm_atomic.LoadUint64(&m.afterAbdicateCounter) < 1 {
		return false
	}
	return true
}

// MinimockAbdicateInspect logs each unmet expectation
func (m *LeaderSessionMock) MinimockAbdicateInspect() {
	for _, e := range m.AbdicateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LeaderSessionMock.Abdicate")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AbdicateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAbdicateCounter) < 1 {
		m.t.Error("Expected call to LeaderSessionMock.Abdicate")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAbdicate != nil && mm_atomic.LoadUint64(&m.afterAbdicateCounter) < 1 {
		m.t.Error("Expected call to LeaderSessionMock.Abdicate")
	}
}

type mLeaderSessionMockCurrent struct {
	mock               *LeaderSessionMock
	defaultExpectation *LeaderSessionMockCurrentExpectation
	expectations       []*LeaderSessionMockCurrentExpectation
}

// LeaderSessionMockCurrentExpectation specifies expectation struct of the LeaderSession.Current
type LeaderSessionMockCurrentExpectation struct {
	mock *LeaderSessionMock

	results *LeaderSessionMockCurrentResults
	Counter uint64
}

// LeaderSessionMockCurrentResults contains results of the LeaderSession.Current
type LeaderSessionMockCurrentResults struct {
	s1  string
	err error
}

// Expect sets up expected params for LeaderSession.Current
func (mmCurrent *mLeaderSessionMockCurrent) Expect() *mLeaderSessionMockCurrent {
	if mmCurrent.mock.funcCurrent != nil {
		mmCurrent.mock.t.Fatalf("LeaderSessionMock.Current mock is already set by Set")
	}

	if mmCurrent.defaultExpectation == nil {
		mmCurrent.defaultExpectation = &LeaderSessionMockCurrentExpectation{}
	}

	return mmCurrent
}

// Return sets up results that will be returned by LeaderSession.Current
func (mmCurrent *mLeaderSessionMockCurrent) Return(s1 string, err error) *LeaderSessionMock {
	if mmCurrent.mock.funcCurrent != nil {
		mmCurrent.mock.t.Fatalf("LeaderSessionMock.Current mock is already set by Set")
	}

	if mmCurrent.defaultExpectation == nil {
		mmCurrent.defaultExpectation = &LeaderSessionMockCurrentExpectation{mock: mmCurrent.mock}
	}
	mmCurrent.defaultExpectation.results = &LeaderSessionMockCurrentResults{s1, err}
	return mmCurrent.mock
}

//Set uses given function f to mock the LeaderSession.Current method
func (mmCurrent *mLeaderSessionMockCurrent) Set(f func() (s1 string, err error)) *LeaderSessionMock {
	if mmCurrent.defaultExpectation != nil {
		mmCurrent.mock.t.Fatalf("Default expectation is already set for the LeaderSession.Current method")
	}

	if len(mmCurrent.expectations) > 0 {
		mmCurrent.mock.t.Fatalf("Some expectations are already set for the LeaderSession.Current method")
	}

	mmCurrent.mock.funcCurrent = f
	return mmCurrent.mock
}

// Current implements LeaderSession
func (mmCurrent *LeaderSessionMock) Current() (s1 string, err error) {
	mm_atomic.AddUint64(&mmCurrent.beforeCurrentCounter, 1)
	defer mm_atomic.AddUint64(&mmCurrent.afterCurrentCounter, 1)

	if mmCurrent.CurrentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCurrent.CurrentMock.defaultExpectation.Counter, 1)

		results := mmCurrent.CurrentMock.defaultExpectation.results
		if results == nil {
			mmCurrent.t.Fatal("No results are set for the LeaderSessionMock.Current")
		}
		return (*results).s1, (*results).err
	}
	if mmCurrent.funcCurrent != nil {
		return mmCurrent.funcCurrent()
	}
	mmCurrent.t.Fatalf("Unexpected call to LeaderSessionMock.Current.")
	return
}

// CurrentAfterCounter returns a count of finished LeaderSessionMock.Current invocations
func (mmCurrent *LeaderSessionMock) CurrentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCurrent.afterCurrentCounter)
}

// CurrentBeforeCounter returns a count of LeaderSessionMock.Current invocations
func (mmCurrent *LeaderSessionMock) CurrentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCurrent.beforeCurrentCounter)
}

// MinimockCurrentDone returns true if the count of the Current invocations corresponds
// the number of defined expectations
func (m *LeaderSessionMock) MinimockCurrentDone() bool {
	for _, e := range m.CurrentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CurrentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCurrentCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCurrent != nil && mm_atomic.LoadUint64(&m.afterCurrentCounter) < 1 {
		return false
	}
	return true
}

// MinimockCurrentInspect logs each unmet expectation
func (m *LeaderSessionMock) MinimockCurrentInspect() {
	for _, e := range m.CurrentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LeaderSessionMock.Current")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CurrentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCurrentCounter) < 1 {
		m.t.Error("Expected call to LeaderSessionMock.Current")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCurrent != nil && mm_atomic.LoadUint64(&m.afterCurrentCounter) < 1 {
		m.t.Error("Expected call to LeaderSessionMock.Current")
	}
}

type mLeaderSessionMockSessionID struct {
	mock               *LeaderSessionMock
	defaultExpectation *LeaderSessionMockSessionIDExpectation
	expectations       []*LeaderSessionMockSessionIDExpectation
}

// LeaderSessionMockSessionIDExpectation specifies expectation struct of the LeaderSession.SessionID
type LeaderSessionMockSessionIDExpectation struct {
	mock *LeaderSessionMock

	results *LeaderSessionMockSessionIDResults
	Counter uint64
}

// LeaderSessionMockSessionIDResults contains results of the LeaderSession.SessionID
type LeaderSessionMockSessionIDResults struct {
	s1 string
}

// Expect sets up expected params for LeaderSession.SessionID
func (mmSessionID *mLeaderSessionMockSessionID) Expect() *mLeaderSessionMockSessionID {
	if mmSessionID.mock.funcSessionID != nil {
		mmSessionID.mock.t.Fatalf("LeaderSessionMock.SessionID mock is already set by Set")
	}

	if mmSessionID.defaultExpectation == nil {
		mmSessionID.defaultExpectation = &LeaderSessionMockSessionIDExpectation{}
	}

	return mmSessionID
}

// Return sets up results that will be returned by LeaderSession.SessionID
func (mmSessionID *mLeaderSessionMockSessionID) Return(s1 string) *LeaderSessionMock {
	if mmSessionID.mock.funcSessionID != nil {
		mmSessionID.mock.t.Fatalf("LeaderSessionMock.SessionID mock is already set by Set")
	}

	if mmSessionID.defaultExpectation == nil {
		mmSessionID.defaultExpectation = &LeaderSessionMockSessionIDExpectation{mock: mmSessionID.mock}
	}
	mmSessionID.defaultExpectation.results = &LeaderSessionMockSessionIDResults{s1}
	return mmSessionID.mock
}

//Set uses given function f to mock the LeaderSession.SessionID method
func (mmSessionID *mLeaderSessionMockSessionID) Set(f func() (s1 string)) *LeaderSessionMock {
	if mmSessionID.defaultExpectation != nil {
		mmSessionID.mock.t.Fatalf("Default expectation is already set for the LeaderSession.SessionID method")
	}

	if len(mmSessionID.expectations) > 0 {
		mmSessionID.mock.t.Fatalf("Some expectations are already set for the LeaderSession.SessionID method")
	}

	mmSessionID.mock.funcSessionID = f
	return mmSessionID.mock
}

// SessionID implements LeaderSession
func (mmSessionID *LeaderSessionMock) SessionID() (s1 string) {
	mm_atomic.AddUint64(&mmSessionID.beforeSessionIDCounter, 1)
	defer mm_atomic.AddUint64(&mmSessionID.afterSessionIDCounter, 1)

	if mmSessionID.SessionIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSessionID.SessionIDMock.defaultExpectation.Counter, 1)

		results := mmSessionID.SessionIDMock.defaultExpectation.results
		if results == nil {
			mmSessionID.t.Fatal("No results are set for the LeaderSessionMock.SessionID")
		}
		return (*results).s1
	}
	if mmSessionID.funcSessionID != nil {
		return mmSessionID.funcSessionID()
	}
	mmSessionID.t.Fatalf("Unexpected call to LeaderSessionMock.SessionID.")
	return
}

// SessionIDAfterCounter returns a count of finished LeaderSessionMock.SessionID invocations
func (mmSessionID *LeaderSessionMock) SessionIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSessionID.afterSessionIDCounter)
}

// SessionIDBeforeCounter returns a count of LeaderSessionMock.SessionID invocations
func (mmSessionID *LeaderSessionMock) SessionIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSessionID.beforeSessionIDCounter)
}

// MinimockSessionIDDone returns true if the count of the SessionID invocations corresponds
// the number of defined expectations
func (m *LeaderSessionMock) MinimockSessionIDDone() bool {
	for _, e := range m.SessionIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SessionIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSessionIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSessionID != nil && mm_atomic.LoadUint64(&m.afterSessionIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockSessionIDInspect logs each unmet expectation
func (m *LeaderSessionMock) MinimockSessionIDInspect() {
	for _, e := range m.SessionIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LeaderSessionMock.SessionID")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SessionIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSessionIDCounter) < 1 {
		m.t.Error("Expected call to LeaderSessionMock.SessionID")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSessionID != nil && mm_atomic.LoadUint64(&m.afterSessionIDCounter) < 1 {
		m.t.Error("Expected call to LeaderSessionMock.SessionID")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LeaderSessionMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAbdicateInspect()

		m.MinimockCurrentInspect()

		m.MinimockSessionIDInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LeaderSessionMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LeaderSessionMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAbdicateDone() &&
		m.MinimockCurrentDone() &&
		m.MinimockSessionIDDone()
}
