package consulapi

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
)

// KVMock implements KV
type KVMock struct {
	t minimock.Tester

	funcDelete          func(dc string, path string) (err error)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mKVMockDelete

	funcGet          func(dc string, path string) (s1 string, err error)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mKVMockGet

	funcKeys          func(dc string, path string) (sa1 []string, err error)
	afterKeysCounter  uint64
	beforeKeysCounter uint64
	KeysMock          mKVMockKeys

	funcPut          func(dc string, path string, value string) (err error)
	afterPutCounter  uint64
	beforePutCounter uint64
	PutMock          mKVMockPut

	funcRecurse          func(dc string, path string) (saa1 [][2]string, err error)
	afterRecurseCounter  uint64
	beforeRecurseCounter uint64
	RecurseMock          mKVMockRecurse
}

// NewKVMock returns a mock for KV
func NewKVMock(t minimock.Tester) *KVMock {
	m := &KVMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DeleteMock = mKVMockDelete{mock: m}
	m.DeleteMock.callArgs = []*KVMockDeleteParams{}

	m.GetMock = mKVMockGet{mock: m}
	m.GetMock.callArgs = []*KVMockGetParams{}

	m.KeysMock = mKVMockKeys{mock: m}
	m.KeysMock.callArgs = []*KVMockKeysParams{}

	m.PutMock = mKVMockPut{mock: m}
	m.PutMock.callArgs = []*KVMockPutParams{}

	m.RecurseMock = mKVMockRecurse{mock: m}
	m.RecurseMock.callArgs = []*KVMockRecurseParams{}

	return m
}

type mKVMockDelete struct {
	mock               *KVMock
	defaultExpectation *KVMockDeleteExpectation
	expectations       []*KVMockDeleteExpectation

	callArgs []*KVMockDeleteParams
	mutex    sync.RWMutex
}

// KVMockDeleteExpectation specifies expectation struct of the KV.Delete
type KVMockDeleteExpectation struct {
	mock    *KVMock
	params  *KVMockDeleteParams
	results *KVMockDeleteResults
	Counter uint64
}

// KVMockDeleteParams contains parameters of the KV.Delete
type KVMockDeleteParams struct {
	dc   string
	path string
}

// KVMockDeleteResults contains results of the KV.Delete
type KVMockDeleteResults struct {
	err error
}

// Expect sets up expected params for KV.Delete
func (mmDelete *mKVMockDelete) Expect(dc string, path string) *mKVMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("KVMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &KVMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &KVMockDeleteParams{dc, path}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Return sets up results that will be returned by KV.Delete
func (mmDelete *mKVMockDelete) Return(err error) *KVMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("KVMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &KVMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &KVMockDeleteResults{err}
	return mmDelete.mock
}

//Set uses given function f to mock the KV.Delete method
func (mmDelete *mKVMockDelete) Set(f func(dc string, path string) (err error)) *KVMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the KV.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the KV.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the KV.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mKVMockDelete) When(dc string, path string) *KVMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("KVMock.Delete mock is already set by Set")
	}

	expectation := &KVMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &KVMockDeleteParams{dc, path},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up KV.Delete return parameters for the expectation previously defined by the When method
func (e *KVMockDeleteExpectation) Then(err error) *KVMock {
	e.results = &KVMockDeleteResults{err}
	return e.mock
}

// Delete implements KV
func (mmDelete *KVMock) Delete(dc string, path string) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	params := &KVMockDeleteParams{dc, path}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		want := mmDelete.DeleteMock.defaultExpectation.params
		got := KVMockDeleteParams{dc, path}
		if want != nil && !minimock.Equal(*want, got) {
			mmDelete.t.Errorf("KVMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmDelete.DeleteMock.defaultExpectation.results
		if results == nil {
			mmDelete.t.Fatal("No results are set for the KVMock.Delete")
		}
		return (*results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(dc, path)
	}
	mmDelete.t.Fatalf("Unexpected call to KVMock.Delete. %v %v", dc, path)
	return
}

// DeleteAfterCounter returns a count of finished KVMock.Delete invocations
func (mmDelete *KVMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of KVMock.Delete invocations
func (mmDelete *KVMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to KVMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mKVMockDelete) Calls() []*KVMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*KVMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *KVMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *KVMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KVMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to KVMock.Delete")
		} else {
			m.t.Errorf("Expected call to KVMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to KVMock.Delete")
	}
}

type mKVMockGet struct {
	mock               *KVMock
	defaultExpectation *KVMockGetExpectation
	expectations       []*KVMockGetExpectation

	callArgs []*KVMockGetParams
	mutex    sync.RWMutex
}

// KVMockGetExpectation specifies expectation struct of the KV.Get
type KVMockGetExpectation struct {
	mock    *KVMock
	params  *KVMockGetParams
	results *KVMockGetResults
	Counter uint64
}

// KVMockGetParams contains parameters of the KV.Get
type KVMockGetParams struct {
	dc   string
	path string
}

// KVMockGetResults contains results of the KV.Get
type KVMockGetResults struct {
	s1  string
	err error
}

// Expect sets up expected params for KV.Get
func (mmGet *mKVMockGet) Expect(dc string, path string) *mKVMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("KVMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &KVMockGetExpectation{}
	}

	mmGet.defaultExpectation.params = &KVMockGetParams{dc, path}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// Return sets up results that will be returned by KV.Get
func (mmGet *mKVMockGet) Return(s1 string, err error) *KVMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("KVMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &KVMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &KVMockGetResults{s1, err}
	return mmGet.mock
}

//Set uses given function f to mock the KV.Get method
func (mmGet *mKVMockGet) Set(f func(dc string, path string) (s1 string, err error)) *KVMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the KV.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the KV.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the KV.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mKVMockGet) When(dc string, path string) *KVMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("KVMock.Get mock is already set by Set")
	}

	expectation := &KVMockGetExpectation{
		mock:   mmGet.mock,
		params: &KVMockGetParams{dc, path},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up KV.Get return parameters for the expectation previously defined by the When method
func (e *KVMockGetExpectation) Then(s1 string, err error) *KVMock {
	e.results = &KVMockGetResults{s1, err}
	return e.mock
}

// Get implements KV
func (mmGet *KVMock) Get(dc string, path string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	params := &KVMockGetParams{dc, path}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		want := mmGet.GetMock.defaultExpectation.params
		got := KVMockGetParams{dc, path}
		if want != nil && !minimock.Equal(*want, got) {
			mmGet.t.Errorf("KVMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmGet.GetMock.defaultExpectation.results
		if results == nil {
			mmGet.t.Fatal("No results are set for the KVMock.Get")
		}
		return (*results).s1, (*results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(dc, path)
	}
	mmGet.t.Fatalf("Unexpected call to KVMock.Get. %v %v", dc, path)
	return
}

// GetAfterCounter returns a count of finished KVMock.Get invocations
func (mmGet *KVMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of KVMock.Get invocations
func (mmGet *KVMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to KVMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mKVMockGet) Calls() []*KVMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*KVMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *KVMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *KVMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KVMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to KVMock.Get")
		} else {
			m.t.Errorf("Expected call to KVMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to KVMock.Get")
	}
}

type mKVMockKeys struct {
	mock               *KVMock
	defaultExpectation *KVMockKeysExpectation
	expectations       []*KVMockKeysExpectation

	callArgs []*KVMockKeysParams
	mutex    sync.RWMutex
}

// KVMockKeysExpectation specifies expectation struct of the KV.Keys
type KVMockKeysExpectation struct {
	mock    *KVMock
	params  *KVMockKeysParams
	results *KVMockKeysResults
	Counter uint64
}

// KVMockKeysParams contains parameters of the KV.Keys
type KVMockKeysParams struct {
	dc   string
	path string
}

// KVMockKeysResults contains results of the KV.Keys
type KVMockKeysResults struct {
	sa1 []string
	err error
}

// Expect sets up expected params for KV.Keys
func (mmKeys *mKVMockKeys) Expect(dc string, path string) *mKVMockKeys {
	if mmKeys.mock.funcKeys != nil {
		mmKeys.mock.t.Fatalf("KVMock.Keys mock is already set by Set")
	}

	if mmKeys.defaultExpectation == nil {
		mmKeys.defaultExpectation = &KVMockKeysExpectation{}
	}

	mmKeys.defaultExpectation.params = &KVMockKeysParams{dc, path}
	for _, e := range mmKeys.expectations {
		if minimock.Equal(e.params, mmKeys.defaultExpectation.params) {
			mmKeys.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmKeys.defaultExpectation.params)
		}
	}

	return mmKeys
}

// Return sets up results that will be returned by KV.Keys
func (mmKeys *mKVMockKeys) Return(sa1 []string, err error) *KVMock {
	if mmKeys.mock.funcKeys != nil {
		mmKeys.mock.t.Fatalf("KVMock.Keys mock is already set by Set")
	}

	if mmKeys.defaultExpectation == nil {
		mmKeys.defaultExpectation = &KVMockKeysExpectation{mock: mmKeys.mock}
	}
	mmKeys.defaultExpectation.results = &KVMockKeysResults{sa1, err}
	return mmKeys.mock
}

//Set uses given function f to mock the KV.Keys method
func (mmKeys *mKVMockKeys) Set(f func(dc string, path string) (sa1 []string, err error)) *KVMock {
	if mmKeys.defaultExpectation != nil {
		mmKeys.mock.t.Fatalf("Default expectation is already set for the KV.Keys method")
	}

	if len(mmKeys.expectations) > 0 {
		mmKeys.mock.t.Fatalf("Some expectations are already set for the KV.Keys method")
	}

	mmKeys.mock.funcKeys = f
	return mmKeys.mock
}

// When sets expectation for the KV.Keys which will trigger the result defined by the following
// Then helper
func (mmKeys *mKVMockKeys) When(dc string, path string) *KVMockKeysExpectation {
	if mmKeys.mock.funcKeys != nil {
		mmKeys.mock.t.Fatalf("KVMock.Keys mock is already set by Set")
	}

	expectation := &KVMockKeysExpectation{
		mock:   mmKeys.mock,
		params: &KVMockKeysParams{dc, path},
	}
	mmKeys.expectations = append(mmKeys.expectations, expectation)
	return expectation
}

// Then sets up KV.Keys return parameters for the expectation previously defined by the When method
func (e *KVMockKeysExpectation) Then(sa1 []string, err error) *KVMock {
	e.results = &KVMockKeysResults{sa1, err}
	return e.mock
}

// Keys implements KV
func (mmKeys *KVMock) Keys(dc string, path string) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmKeys.beforeKeysCounter, 1)
	defer mm_atomic.AddUint64(&mmKeys.afterKeysCounter, 1)

	params := &KVMockKeysParams{dc, path}

	// Record call args
	mmKeys.KeysMock.mutex.Lock()
	mmKeys.KeysMock.callArgs = append(mmKeys.KeysMock.callArgs, params)
	mmKeys.KeysMock.mutex.Unlock()

	for _, e := range mmKeys.KeysMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmKeys.KeysMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmKeys.KeysMock.defaultExpectation.Counter, 1)
		want := mmKeys.KeysMock.defaultExpectation.params
		got := KVMockKeysParams{dc, path}
		if want != nil && !minimock.Equal(*want, got) {
			mmKeys.t.Errorf("KVMock.Keys got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmKeys.KeysMock.defaultExpectation.results
		if results == nil {
			mmKeys.t.Fatal("No results are set for the KVMock.Keys")
		}
		return (*results).sa1, (*results).err
	}
	if mmKeys.funcKeys != nil {
		return mmKeys.funcKeys(dc, path)
	}
	mmKeys.t.Fatalf("Unexpected call to KVMock.Keys. %v %v", dc, path)
	return
}

// KeysAfterCounter returns a count of finished KVMock.Keys invocations
func (mmKeys *KVMock) KeysAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmKeys.afterKeysCounter)
}

// KeysBeforeCounter returns a count of KVMock.Keys invocations
func (mmKeys *KVMock) KeysBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmKeys.beforeKeysCounter)
}

// Calls returns a list of arguments used in each call to KVMock.Keys.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmKeys *mKVMockKeys) Calls() []*KVMockKeysParams {
	mmKeys.mutex.RLock()

	argCopy := make([]*KVMockKeysParams, len(mmKeys.callArgs))
	copy(argCopy, mmKeys.callArgs)

	mmKeys.mutex.RUnlock()

	return argCopy
}

// MinimockKeysDone returns true if the count of the Keys invocations corresponds
// the number of defined expectations
func (m *KVMock) MinimockKeysDone() bool {
	for _, e := range m.KeysMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.KeysMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterKeysCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcKeys != nil && mm_atomic.LoadUint64(&m.afterKeysCounter) < 1 {
		return false
	}
	return true
}

// MinimockKeysInspect logs each unmet expectation
func (m *KVMock) MinimockKeysInspect() {
	for _, e := range m.KeysMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KVMock.Keys with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.KeysMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterKeysCounter) < 1 {
		if m.KeysMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to KVMock.Keys")
		} else {
			m.t.Errorf("Expected call to KVMock.Keys with params: %#v", *m.KeysMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcKeys != nil && mm_atomic.LoadUint64(&m.afterKeysCounter) < 1 {
		m.t.Error("Expected call to KVMock.Keys")
	}
}

type mKVMockPut struct {
	mock               *KVMock
	defaultExpectation *KVMockPutExpectation
	expectations       []*KVMockPutExpectation

	callArgs []*KVMockPutParams
	mutex    sync.RWMutex
}

// KVMockPutExpectation specifies expectation struct of the KV.Put
type KVMockPutExpectation struct {
	mock    *KVMock
	params  *KVMockPutParams
	results *KVMockPutResults
	Counter uint64
}

// KVMockPutParams contains parameters of the KV.Put
type KVMockPutParams struct {
	dc    string
	path  string
	value string
}

// KVMockPutResults contains results of the KV.Put
type KVMockPutResults struct {
	err error
}

// Expect sets up expected params for KV.Put
func (mmPut *mKVMockPut) Expect(dc string, path string, value string) *mKVMockPut {
	if mmPut.mock.funcPut != nil {
		mmPut.mock.t.Fatalf("KVMock.Put mock is already set by Set")
	}

	if mmPut.defaultExpectation == nil {
		mmPut.defaultExpectation = &KVMockPutExpectation{}
	}

	mmPut.defaultExpectation.params = &KVMockPutParams{dc, path, value}
	for _, e := range mmPut.expectations {
		if minimock.Equal(e.params, mmPut.defaultExpectation.params) {
			mmPut.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPut.defaultExpectation.params)
		}
	}

	return mmPut
}

// Return sets up results that will be returned by KV.Put
func (mmPut *mKVMockPut) Return(err error) *KVMock {
	if mmPut.mock.funcPut != nil {
		mmPut.mock.t.Fatalf("KVMock.Put mock is already set by Set")
	}

	if mmPut.defaultExpectation == nil {
		mmPut.defaultExpectation = &KVMockPutExpectation{mock: mmPut.mock}
	}
	mmPut.defaultExpectation.results = &KVMockPutResults{err}
	return mmPut.mock
}

//Set uses given function f to mock the KV.Put method
func (mmPut *mKVMockPut) Set(f func(dc string, path string, value string) (err error)) *KVMock {
	if mmPut.defaultExpectation != nil {
		mmPut.mock.t.Fatalf("Default expectation is already set for the KV.Put method")
	}

	if len(mmPut.expectations) > 0 {
		mmPut.mock.t.Fatalf("Some expectations are already set for the KV.Put method")
	}

	mmPut.mock.funcPut = f
	return mmPut.mock
}

// When sets expectation for the KV.Put which will trigger the result defined by the following
// Then helper
func (mmPut *mKVMockPut) When(dc string, path string, value string) *KVMockPutExpectation {
	if mmPut.mock.funcPut != nil {
		mmPut.mock.t.Fatalf("KVMock.Put mock is already set by Set")
	}

	expectation := &KVMockPutExpectation{
		mock:   mmPut.mock,
		params: &KVMockPutParams{dc, path, value},
	}
	mmPut.expectations = append(mmPut.expectations, expectation)
	return expectation
}

// Then sets up KV.Put return parameters for the expectation previously defined by the When method
func (e *KVMockPutExpectation) Then(err error) *KVMock {
	e.results = &KVMockPutResults{err}
	return e.mock
}

// Put implements KV
func (mmPut *KVMock) Put(dc string, path string, value string) (err error) {
	mm_atomic.AddUint64(&mmPut.beforePutCounter, 1)
	defer mm_atomic.AddUint64(&mmPut.afterPutCounter, 1)

	params := &KVMockPutParams{dc, path, value}

	// Record call args
	mmPut.PutMock.mutex.Lock()
	mmPut.PutMock.callArgs = append(mmPut.PutMock.callArgs, params)
	mmPut.PutMock.mutex.Unlock()

	for _, e := range mmPut.PutMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPut.PutMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPut.PutMock.defaultExpectation.Counter, 1)
		want := mmPut.PutMock.defaultExpectation.params
		got := KVMockPutParams{dc, path, value}
		if want != nil && !minimock.Equal(*want, got) {
			mmPut.t.Errorf("KVMock.Put got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmPut.PutMock.defaultExpectation.results
		if results == nil {
			mmPut.t.Fatal("No results are set for the KVMock.Put")
		}
		return (*results).err
	}
	if mmPut.funcPut != nil {
		return mmPut.funcPut(dc, path, value)
	}
	mmPut.t.Fatalf("Unexpected call to KVMock.Put. %v %v %v", dc, path, value)
	return
}

// PutAfterCounter returns a count of finished KVMock.Put invocations
func (mmPut *KVMock) PutAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPut.afterPutCounter)
}

// PutBeforeCounter returns a count of KVMock.Put invocations
func (mmPut *KVMock) PutBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPut.beforePutCounter)
}

// Calls returns a list of arguments used in each call to KVMock.Put.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPut *mKVMockPut) Calls() []*KVMockPutParams {
	mmPut.mutex.RLock()

	argCopy := make([]*KVMockPutParams, len(mmPut.callArgs))
	copy(argCopy, mmPut.callArgs)

	mmPut.mutex.RUnlock()

	return argCopy
}

// MinimockPutDone returns true if the count of the Put invocations corresponds
// the number of defined expectations
func (m *KVMock) MinimockPutDone() bool {
	for _, e := range m.PutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PutMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPut != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		return false
	}
	return true
}

// MinimockPutInspect logs each unmet expectation
func (m *KVMock) MinimockPutInspect() {
	for _, e := range m.PutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KVMock.Put with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PutMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		if m.PutMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to KVMock.Put")
		} else {
			m.t.Errorf("Expected call to KVMock.Put with params: %#v", *m.PutMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPut != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		m.t.Error("Expected call to KVMock.Put")
	}
}

type mKVMockRecurse struct {
	mock               *KVMock
	defaultExpectation *KVMockRecurseExpectation
	expectations       []*KVMockRecurseExpectation

	callArgs []*KVMockRecurseParams
	mutex    sync.RWMutex
}

// KVMockRecurseExpectation specifies expectation struct of the KV.Recurse
type KVMockRecurseExpectation struct {
	mock    *KVMock
	params  *KVMockRecurseParams
	results *KVMockRecurseResults
	Counter uint64
}

// KVMockRecurseParams contains parameters of the KV.Recurse
type KVMockRecurseParams struct {
	dc   string
	path string
}

// KVMockRecurseResults contains results of the KV.Recurse
type KVMockRecurseResults struct {
	saa1 [][2]string
	err  error
}

// Expect sets up expected params for KV.Recurse
func (mmRecurse *mKVMockRecurse) Expect(dc string, path string) *mKVMockRecurse {
	if mmRecurse.mock.funcRecurse != nil {
		mmRecurse.mock.t.Fatalf("KVMock.Recurse mock is already set by Set")
	}

	if mmRecurse.defaultExpectation == nil {
		mmRecurse.defaultExpectation = &KVMockRecurseExpectation{}
	}

	mmRecurse.defaultExpectation.params = &KVMockRecurseParams{dc, path}
	for _, e := range mmRecurse.expectations {
		if minimock.Equal(e.params, mmRecurse.defaultExpectation.params) {
			mmRecurse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRecurse.defaultExpectation.params)
		}
	}

	return mmRecurse
}

// Return sets up results that will be returned by KV.Recurse
func (mmRecurse *mKVMockRecurse) Return(saa1 [][2]string, err error) *KVMock {
	if mmRecurse.mock.funcRecurse != nil {
		mmRecurse.mock.t.Fatalf("KVMock.Recurse mock is already set by Set")
	}

	if mmRecurse.defaultExpectation == nil {
		mmRecurse.defaultExpectation = &KVMockRecurseExpectation{mock: mmRecurse.mock}
	}
	mmRecurse.defaultExpectation.results = &KVMockRecurseResults{saa1, err}
	return mmRecurse.mock
}

//Set uses given function f to mock the KV.Recurse method
func (mmRecurse *mKVMockRecurse) Set(f func(dc string, path string) (saa1 [][2]string, err error)) *KVMock {
	if mmRecurse.defaultExpectation != nil {
		mmRecurse.mock.t.Fatalf("Default expectation is already set for the KV.Recurse method")
	}

	if len(mmRecurse.expectations) > 0 {
		mmRecurse.mock.t.Fatalf("Some expectations are already set for the KV.Recurse method")
	}

	mmRecurse.mock.funcRecurse = f
	return mmRecurse.mock
}

// When sets expectation for the KV.Recurse which will trigger the result defined by the following
// Then helper
func (mmRecurse *mKVMockRecurse) When(dc string, path string) *KVMockRecurseExpectation {
	if mmRecurse.mock.funcRecurse != nil {
		mmRecurse.mock.t.Fatalf("KVMock.Recurse mock is already set by Set")
	}

	expectation := &KVMockRecurseExpectation{
		mock:   mmRecurse.mock,
		params: &KVMockRecurseParams{dc, path},
	}
	mmRecurse.expectations = append(mmRecurse.expectations, expectation)
	return expectation
}

// Then sets up KV.Recurse return parameters for the expectation previously defined by the When method
func (e *KVMockRecurseExpectation) Then(saa1 [][2]string, err error) *KVMock {
	e.results = &KVMockRecurseResults{saa1, err}
	return e.mock
}

// Recurse implements KV
func (mmRecurse *KVMock) Recurse(dc string, path string) (saa1 [][2]string, err error) {
	mm_atomic.AddUint64(&mmRecurse.beforeRecurseCounter, 1)
	defer mm_atomic.AddUint64(&mmRecurse.afterRecurseCounter, 1)

	params := &KVMockRecurseParams{dc, path}

	// Record call args
	mmRecurse.RecurseMock.mutex.Lock()
	mmRecurse.RecurseMock.callArgs = append(mmRecurse.RecurseMock.callArgs, params)
	mmRecurse.RecurseMock.mutex.Unlock()

	for _, e := range mmRecurse.RecurseMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.saa1, e.results.err
		}
	}

	if mmRecurse.RecurseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRecurse.RecurseMock.defaultExpectation.Counter, 1)
		want := mmRecurse.RecurseMock.defaultExpectation.params
		got := KVMockRecurseParams{dc, path}
		if want != nil && !minimock.Equal(*want, got) {
			mmRecurse.t.Errorf("KVMock.Recurse got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmRecurse.RecurseMock.defaultExpectation.results
		if results == nil {
			mmRecurse.t.Fatal("No results are set for the KVMock.Recurse")
		}
		return (*results).saa1, (*results).err
	}
	if mmRecurse.funcRecurse != nil {
		return mmRecurse.funcRecurse(dc, path)
	}
	mmRecurse.t.Fatalf("Unexpected call to KVMock.Recurse. %v %v", dc, path)
	return
}

// RecurseAfterCounter returns a count of finished KVMock.Recurse invocations
func (mmRecurse *KVMock) RecurseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecurse.afterRecurseCounter)
}

// RecurseBeforeCounter returns a count of KVMock.Recurse invocations
func (mmRecurse *KVMock) RecurseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecurse.beforeRecurseCounter)
}

// Calls returns a list of arguments used in each call to KVMock.Recurse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRecurse *mKVMockRecurse) Calls() []*KVMockRecurseParams {
	mmRecurse.mutex.RLock()

	argCopy := make([]*KVMockRecurseParams, len(mmRecurse.callArgs))
	copy(argCopy, mmRecurse.callArgs)

	mmRecurse.mutex.RUnlock()

	return argCopy
}

// MinimockRecurseDone returns true if the count of the Recurse invocations corresponds
// the number of defined expectations
func (m *KVMock) MinimockRecurseDone() bool {
	for _, e := range m.RecurseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RecurseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRecurseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecurse != nil && mm_atomic.LoadUint64(&m.afterRecurseCounter) < 1 {
		return false
	}
	return true
}

// MinimockRecurseInspect logs each unmet expectation
func (m *KVMock) MinimockRecurseInspect() {
	for _, e := range m.RecurseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KVMock.Recurse with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RecurseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRecurseCounter) < 1 {
		if m.RecurseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to KVMock.Recurse")
		} else {
			m.t.Errorf("Expected call to KVMock.Recurse with params: %#v", *m.RecurseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecurse != nil && mm_atomic.LoadUint64(&m.afterRecurseCounter) < 1 {
		m.t.Error("Expected call to KVMock.Recurse")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *KVMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockDeleteInspect()

		m.MinimockGetInspect()

		m.MinimockKeysInspect()

		m.MinimockPutInspect()

		m.MinimockRecurseInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *KVMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *KVMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockKeysDone() &&
		m.MinimockPutDone() &&
		m.MinimockRecurseDone()
}
