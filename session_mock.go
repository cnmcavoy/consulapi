package consulapi

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock"
)

// SessionMock implements Session
type SessionMock struct {
	t minimock.Tester

	funcCreateSession          func(dc string, config SessionConfig) (s1 SessionID, err error)
	afterCreateSessionCounter  uint64
	beforeCreateSessionCounter uint64
	CreateSessionMock          mSessionMockCreateSession

	funcDeleteSession          func(dc string, id SessionID) (err error)
	afterDeleteSessionCounter  uint64
	beforeDeleteSessionCounter uint64
	DeleteSessionMock          mSessionMockDeleteSession

	funcListSessions          func(dc string, node string) (m1 map[SessionID]SessionConfig, err error)
	afterListSessionsCounter  uint64
	beforeListSessionsCounter uint64
	ListSessionsMock          mSessionMockListSessions

	funcReadSession          func(dc string, id SessionID) (s1 SessionConfig, err error)
	afterReadSessionCounter  uint64
	beforeReadSessionCounter uint64
	ReadSessionMock          mSessionMockReadSession

	funcRenewSession          func(dc string, id SessionID) (d1 time.Duration, err error)
	afterRenewSessionCounter  uint64
	beforeRenewSessionCounter uint64
	RenewSessionMock          mSessionMockRenewSession
}

// NewSessionMock returns a mock for Session
func NewSessionMock(t minimock.Tester) *SessionMock {
	m := &SessionMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateSessionMock = mSessionMockCreateSession{mock: m}
	m.CreateSessionMock.callArgs = []*SessionMockCreateSessionParams{}

	m.DeleteSessionMock = mSessionMockDeleteSession{mock: m}
	m.DeleteSessionMock.callArgs = []*SessionMockDeleteSessionParams{}

	m.ListSessionsMock = mSessionMockListSessions{mock: m}
	m.ListSessionsMock.callArgs = []*SessionMockListSessionsParams{}

	m.ReadSessionMock = mSessionMockReadSession{mock: m}
	m.ReadSessionMock.callArgs = []*SessionMockReadSessionParams{}

	m.RenewSessionMock = mSessionMockRenewSession{mock: m}
	m.RenewSessionMock.callArgs = []*SessionMockRenewSessionParams{}

	return m
}

type mSessionMockCreateSession struct {
	mock               *SessionMock
	defaultExpectation *SessionMockCreateSessionExpectation
	expectations       []*SessionMockCreateSessionExpectation

	callArgs []*SessionMockCreateSessionParams
	mutex    sync.RWMutex
}

// SessionMockCreateSessionExpectation specifies expectation struct of the Session.CreateSession
type SessionMockCreateSessionExpectation struct {
	mock    *SessionMock
	params  *SessionMockCreateSessionParams
	results *SessionMockCreateSessionResults
	Counter uint64
}

// SessionMockCreateSessionParams contains parameters of the Session.CreateSession
type SessionMockCreateSessionParams struct {
	dc     string
	config SessionConfig
}

// SessionMockCreateSessionResults contains results of the Session.CreateSession
type SessionMockCreateSessionResults struct {
	s1  SessionID
	err error
}

// Expect sets up expected params for Session.CreateSession
func (mmCreateSession *mSessionMockCreateSession) Expect(dc string, config SessionConfig) *mSessionMockCreateSession {
	if mmCreateSession.mock.funcCreateSession != nil {
		mmCreateSession.mock.t.Fatalf("SessionMock.CreateSession mock is already set by Set")
	}

	if mmCreateSession.defaultExpectation == nil {
		mmCreateSession.defaultExpectation = &SessionMockCreateSessionExpectation{}
	}

	mmCreateSession.defaultExpectation.params = &SessionMockCreateSessionParams{dc, config}
	for _, e := range mmCreateSession.expectations {
		if minimock.Equal(e.params, mmCreateSession.defaultExpectation.params) {
			mmCreateSession.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateSession.defaultExpectation.params)
		}
	}

	return mmCreateSession
}

// Return sets up results that will be returned by Session.CreateSession
func (mmCreateSession *mSessionMockCreateSession) Return(s1 SessionID, err error) *SessionMock {
	if mmCreateSession.mock.funcCreateSession != nil {
		mmCreateSession.mock.t.Fatalf("SessionMock.CreateSession mock is already set by Set")
	}

	if mmCreateSession.defaultExpectation == nil {
		mmCreateSession.defaultExpectation = &SessionMockCreateSessionExpectation{mock: mmCreateSession.mock}
	}
	mmCreateSession.defaultExpectation.results = &SessionMockCreateSessionResults{s1, err}
	return mmCreateSession.mock
}

//Set uses given function f to mock the Session.CreateSession method
func (mmCreateSession *mSessionMockCreateSession) Set(f func(dc string, config SessionConfig) (s1 SessionID, err error)) *SessionMock {
	if mmCreateSession.defaultExpectation != nil {
		mmCreateSession.mock.t.Fatalf("Default expectation is already set for the Session.CreateSession method")
	}

	if len(mmCreateSession.expectations) > 0 {
		mmCreateSession.mock.t.Fatalf("Some expectations are already set for the Session.CreateSession method")
	}

	mmCreateSession.mock.funcCreateSession = f
	return mmCreateSession.mock
}

// When sets expectation for the Session.CreateSession which will trigger the result defined by the following
// Then helper
func (mmCreateSession *mSessionMockCreateSession) When(dc string, config SessionConfig) *SessionMockCreateSessionExpectation {
	if mmCreateSession.mock.funcCreateSession != nil {
		mmCreateSession.mock.t.Fatalf("SessionMock.CreateSession mock is already set by Set")
	}

	expectation := &SessionMockCreateSessionExpectation{
		mock:   mmCreateSession.mock,
		params: &SessionMockCreateSessionParams{dc, config},
	}
	mmCreateSession.expectations = append(mmCreateSession.expectations, expectation)
	return expectation
}

// Then sets up Session.CreateSession return parameters for the expectation previously defined by the When method
func (e *SessionMockCreateSessionExpectation) Then(s1 SessionID, err error) *SessionMock {
	e.results = &SessionMockCreateSessionResults{s1, err}
	return e.mock
}

// CreateSession implements Session
func (mmCreateSession *SessionMock) CreateSession(dc string, config SessionConfig) (s1 SessionID, err error) {
	mm_atomic.AddUint64(&mmCreateSession.beforeCreateSessionCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateSession.afterCreateSessionCounter, 1)

	params := &SessionMockCreateSessionParams{dc, config}

	// Record call args
	mmCreateSession.CreateSessionMock.mutex.Lock()
	mmCreateSession.CreateSessionMock.callArgs = append(mmCreateSession.CreateSessionMock.callArgs, params)
	mmCreateSession.CreateSessionMock.mutex.Unlock()

	for _, e := range mmCreateSession.CreateSessionMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmCreateSession.CreateSessionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateSession.CreateSessionMock.defaultExpectation.Counter, 1)
		want := mmCreateSession.CreateSessionMock.defaultExpectation.params
		got := SessionMockCreateSessionParams{dc, config}
		if want != nil && !minimock.Equal(*want, got) {
			mmCreateSession.t.Errorf("SessionMock.CreateSession got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmCreateSession.CreateSessionMock.defaultExpectation.results
		if results == nil {
			mmCreateSession.t.Fatal("No results are set for the SessionMock.CreateSession")
		}
		return (*results).s1, (*results).err
	}
	if mmCreateSession.funcCreateSession != nil {
		return mmCreateSession.funcCreateSession(dc, config)
	}
	mmCreateSession.t.Fatalf("Unexpected call to SessionMock.CreateSession. %v %v", dc, config)
	return
}

// CreateSessionAfterCounter returns a count of finished SessionMock.CreateSession invocations
func (mmCreateSession *SessionMock) CreateSessionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateSession.afterCreateSessionCounter)
}

// CreateSessionBeforeCounter returns a count of SessionMock.CreateSession invocations
func (mmCreateSession *SessionMock) CreateSessionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateSession.beforeCreateSessionCounter)
}

// Calls returns a list of arguments used in each call to SessionMock.CreateSession.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateSession *mSessionMockCreateSession) Calls() []*SessionMockCreateSessionParams {
	mmCreateSession.mutex.RLock()

	argCopy := make([]*SessionMockCreateSessionParams, len(mmCreateSession.callArgs))
	copy(argCopy, mmCreateSession.callArgs)

	mmCreateSession.mutex.RUnlock()

	return argCopy
}

// MinimockCreateSessionDone returns true if the count of the CreateSession invocations corresponds
// the number of defined expectations
func (m *SessionMock) MinimockCreateSessionDone() bool {
	for _, e := range m.CreateSessionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateSessionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateSessionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateSession != nil && mm_atomic.LoadUint64(&m.afterCreateSessionCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateSessionInspect logs each unmet expectation
func (m *SessionMock) MinimockCreateSessionInspect() {
	for _, e := range m.CreateSessionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SessionMock.CreateSession with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateSessionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateSessionCounter) < 1 {
		if m.CreateSessionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SessionMock.CreateSession")
		} else {
			m.t.Errorf("Expected call to SessionMock.CreateSession with params: %#v", *m.CreateSessionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateSession != nil && mm_atomic.LoadUint64(&m.afterCreateSessionCounter) < 1 {
		m.t.Error("Expected call to SessionMock.CreateSession")
	}
}

type mSessionMockDeleteSession struct {
	mock               *SessionMock
	defaultExpectation *SessionMockDeleteSessionExpectation
	expectations       []*SessionMockDeleteSessionExpectation

	callArgs []*SessionMockDeleteSessionParams
	mutex    sync.RWMutex
}

// SessionMockDeleteSessionExpectation specifies expectation struct of the Session.DeleteSession
type SessionMockDeleteSessionExpectation struct {
	mock    *SessionMock
	params  *SessionMockDeleteSessionParams
	results *SessionMockDeleteSessionResults
	Counter uint64
}

// SessionMockDeleteSessionParams contains parameters of the Session.DeleteSession
type SessionMockDeleteSessionParams struct {
	dc string
	id SessionID
}

// SessionMockDeleteSessionResults contains results of the Session.DeleteSession
type SessionMockDeleteSessionResults struct {
	err error
}

// Expect sets up expected params for Session.DeleteSession
func (mmDeleteSession *mSessionMockDeleteSession) Expect(dc string, id SessionID) *mSessionMockDeleteSession {
	if mmDeleteSession.mock.funcDeleteSession != nil {
		mmDeleteSession.mock.t.Fatalf("SessionMock.DeleteSession mock is already set by Set")
	}

	if mmDeleteSession.defaultExpectation == nil {
		mmDeleteSession.defaultExpectation = &SessionMockDeleteSessionExpectation{}
	}

	mmDeleteSession.defaultExpectation.params = &SessionMockDeleteSessionParams{dc, id}
	for _, e := range mmDeleteSession.expectations {
		if minimock.Equal(e.params, mmDeleteSession.defaultExpectation.params) {
			mmDeleteSession.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteSession.defaultExpectation.params)
		}
	}

	return mmDeleteSession
}

// Return sets up results that will be returned by Session.DeleteSession
func (mmDeleteSession *mSessionMockDeleteSession) Return(err error) *SessionMock {
	if mmDeleteSession.mock.funcDeleteSession != nil {
		mmDeleteSession.mock.t.Fatalf("SessionMock.DeleteSession mock is already set by Set")
	}

	if mmDeleteSession.defaultExpectation == nil {
		mmDeleteSession.defaultExpectation = &SessionMockDeleteSessionExpectation{mock: mmDeleteSession.mock}
	}
	mmDeleteSession.defaultExpectation.results = &SessionMockDeleteSessionResults{err}
	return mmDeleteSession.mock
}

//Set uses given function f to mock the Session.DeleteSession method
func (mmDeleteSession *mSessionMockDeleteSession) Set(f func(dc string, id SessionID) (err error)) *SessionMock {
	if mmDeleteSession.defaultExpectation != nil {
		mmDeleteSession.mock.t.Fatalf("Default expectation is already set for the Session.DeleteSession method")
	}

	if len(mmDeleteSession.expectations) > 0 {
		mmDeleteSession.mock.t.Fatalf("Some expectations are already set for the Session.DeleteSession method")
	}

	mmDeleteSession.mock.funcDeleteSession = f
	return mmDeleteSession.mock
}

// When sets expectation for the Session.DeleteSession which will trigger the result defined by the following
// Then helper
func (mmDeleteSession *mSessionMockDeleteSession) When(dc string, id SessionID) *SessionMockDeleteSessionExpectation {
	if mmDeleteSession.mock.funcDeleteSession != nil {
		mmDeleteSession.mock.t.Fatalf("SessionMock.DeleteSession mock is already set by Set")
	}

	expectation := &SessionMockDeleteSessionExpectation{
		mock:   mmDeleteSession.mock,
		params: &SessionMockDeleteSessionParams{dc, id},
	}
	mmDeleteSession.expectations = append(mmDeleteSession.expectations, expectation)
	return expectation
}

// Then sets up Session.DeleteSession return parameters for the expectation previously defined by the When method
func (e *SessionMockDeleteSessionExpectation) Then(err error) *SessionMock {
	e.results = &SessionMockDeleteSessionResults{err}
	return e.mock
}

// DeleteSession implements Session
func (mmDeleteSession *SessionMock) DeleteSession(dc string, id SessionID) (err error) {
	mm_atomic.AddUint64(&mmDeleteSession.beforeDeleteSessionCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteSession.afterDeleteSessionCounter, 1)

	params := &SessionMockDeleteSessionParams{dc, id}

	// Record call args
	mmDeleteSession.DeleteSessionMock.mutex.Lock()
	mmDeleteSession.DeleteSessionMock.callArgs = append(mmDeleteSession.DeleteSessionMock.callArgs, params)
	mmDeleteSession.DeleteSessionMock.mutex.Unlock()

	for _, e := range mmDeleteSession.DeleteSessionMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteSession.DeleteSessionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteSession.DeleteSessionMock.defaultExpectation.Counter, 1)
		want := mmDeleteSession.DeleteSessionMock.defaultExpectation.params
		got := SessionMockDeleteSessionParams{dc, id}
		if want != nil && !minimock.Equal(*want, got) {
			mmDeleteSession.t.Errorf("SessionMock.DeleteSession got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmDeleteSession.DeleteSessionMock.defaultExpectation.results
		if results == nil {
			mmDeleteSession.t.Fatal("No results are set for the SessionMock.DeleteSession")
		}
		return (*results).err
	}
	if mmDeleteSession.funcDeleteSession != nil {
		return mmDeleteSession.funcDeleteSession(dc, id)
	}
	mmDeleteSession.t.Fatalf("Unexpected call to SessionMock.DeleteSession. %v %v", dc, id)
	return
}

// DeleteSessionAfterCounter returns a count of finished SessionMock.DeleteSession invocations
func (mmDeleteSession *SessionMock) DeleteSessionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSession.afterDeleteSessionCounter)
}

// DeleteSessionBeforeCounter returns a count of SessionMock.DeleteSession invocations
func (mmDeleteSession *SessionMock) DeleteSessionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSession.beforeDeleteSessionCounter)
}

// Calls returns a list of arguments used in each call to SessionMock.DeleteSession.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteSession *mSessionMockDeleteSession) Calls() []*SessionMockDeleteSessionParams {
	mmDeleteSession.mutex.RLock()

	argCopy := make([]*SessionMockDeleteSessionParams, len(mmDeleteSession.callArgs))
	copy(argCopy, mmDeleteSession.callArgs)

	mmDeleteSession.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteSessionDone returns true if the count of the DeleteSession invocations corresponds
// the number of defined expectations
func (m *SessionMock) MinimockDeleteSessionDone() bool {
	for _, e := range m.DeleteSessionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSessionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteSessionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSession != nil && mm_atomic.LoadUint64(&m.afterDeleteSessionCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteSessionInspect logs each unmet expectation
func (m *SessionMock) MinimockDeleteSessionInspect() {
	for _, e := range m.DeleteSessionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SessionMock.DeleteSession with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSessionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteSessionCounter) < 1 {
		if m.DeleteSessionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SessionMock.DeleteSession")
		} else {
			m.t.Errorf("Expected call to SessionMock.DeleteSession with params: %#v", *m.DeleteSessionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSession != nil && mm_atomic.LoadUint64(&m.afterDeleteSessionCounter) < 1 {
		m.t.Error("Expected call to SessionMock.DeleteSession")
	}
}

type mSessionMockListSessions struct {
	mock               *SessionMock
	defaultExpectation *SessionMockListSessionsExpectation
	expectations       []*SessionMockListSessionsExpectation

	callArgs []*SessionMockListSessionsParams
	mutex    sync.RWMutex
}

// SessionMockListSessionsExpectation specifies expectation struct of the Session.ListSessions
type SessionMockListSessionsExpectation struct {
	mock    *SessionMock
	params  *SessionMockListSessionsParams
	results *SessionMockListSessionsResults
	Counter uint64
}

// SessionMockListSessionsParams contains parameters of the Session.ListSessions
type SessionMockListSessionsParams struct {
	dc   string
	node string
}

// SessionMockListSessionsResults contains results of the Session.ListSessions
type SessionMockListSessionsResults struct {
	m1  map[SessionID]SessionConfig
	err error
}

// Expect sets up expected params for Session.ListSessions
func (mmListSessions *mSessionMockListSessions) Expect(dc string, node string) *mSessionMockListSessions {
	if mmListSessions.mock.funcListSessions != nil {
		mmListSessions.mock.t.Fatalf("SessionMock.ListSessions mock is already set by Set")
	}

	if mmListSessions.defaultExpectation == nil {
		mmListSessions.defaultExpectation = &SessionMockListSessionsExpectation{}
	}

	mmListSessions.defaultExpectation.params = &SessionMockListSessionsParams{dc, node}
	for _, e := range mmListSessions.expectations {
		if minimock.Equal(e.params, mmListSessions.defaultExpectation.params) {
			mmListSessions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListSessions.defaultExpectation.params)
		}
	}

	return mmListSessions
}

// Return sets up results that will be returned by Session.ListSessions
func (mmListSessions *mSessionMockListSessions) Return(m1 map[SessionID]SessionConfig, err error) *SessionMock {
	if mmListSessions.mock.funcListSessions != nil {
		mmListSessions.mock.t.Fatalf("SessionMock.ListSessions mock is already set by Set")
	}

	if mmListSessions.defaultExpectation == nil {
		mmListSessions.defaultExpectation = &SessionMockListSessionsExpectation{mock: mmListSessions.mock}
	}
	mmListSessions.defaultExpectation.results = &SessionMockListSessionsResults{m1, err}
	return mmListSessions.mock
}

//Set uses given function f to mock the Session.ListSessions method
func (mmListSessions *mSessionMockListSessions) Set(f func(dc string, node string) (m1 map[SessionID]SessionConfig, err error)) *SessionMock {
	if mmListSessions.defaultExpectation != nil {
		mmListSessions.mock.t.Fatalf("Default expectation is already set for the Session.ListSessions method")
	}

	if len(mmListSessions.expectations) > 0 {
		mmListSessions.mock.t.Fatalf("Some expectations are already set for the Session.ListSessions method")
	}

	mmListSessions.mock.funcListSessions = f
	return mmListSessions.mock
}

// When sets expectation for the Session.ListSessions which will trigger the result defined by the following
// Then helper
func (mmListSessions *mSessionMockListSessions) When(dc string, node string) *SessionMockListSessionsExpectation {
	if mmListSessions.mock.funcListSessions != nil {
		mmListSessions.mock.t.Fatalf("SessionMock.ListSessions mock is already set by Set")
	}

	expectation := &SessionMockListSessionsExpectation{
		mock:   mmListSessions.mock,
		params: &SessionMockListSessionsParams{dc, node},
	}
	mmListSessions.expectations = append(mmListSessions.expectations, expectation)
	return expectation
}

// Then sets up Session.ListSessions return parameters for the expectation previously defined by the When method
func (e *SessionMockListSessionsExpectation) Then(m1 map[SessionID]SessionConfig, err error) *SessionMock {
	e.results = &SessionMockListSessionsResults{m1, err}
	return e.mock
}

// ListSessions implements Session
func (mmListSessions *SessionMock) ListSessions(dc string, node string) (m1 map[SessionID]SessionConfig, err error) {
	mm_atomic.AddUint64(&mmListSessions.beforeListSessionsCounter, 1)
	defer mm_atomic.AddUint64(&mmListSessions.afterListSessionsCounter, 1)

	params := &SessionMockListSessionsParams{dc, node}

	// Record call args
	mmListSessions.ListSessionsMock.mutex.Lock()
	mmListSessions.ListSessionsMock.callArgs = append(mmListSessions.ListSessionsMock.callArgs, params)
	mmListSessions.ListSessionsMock.mutex.Unlock()

	for _, e := range mmListSessions.ListSessionsMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmListSessions.ListSessionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListSessions.ListSessionsMock.defaultExpectation.Counter, 1)
		want := mmListSessions.ListSessionsMock.defaultExpectation.params
		got := SessionMockListSessionsParams{dc, node}
		if want != nil && !minimock.Equal(*want, got) {
			mmListSessions.t.Errorf("SessionMock.ListSessions got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmListSessions.ListSessionsMock.defaultExpectation.results
		if results == nil {
			mmListSessions.t.Fatal("No results are set for the SessionMock.ListSessions")
		}
		return (*results).m1, (*results).err
	}
	if mmListSessions.funcListSessions != nil {
		return mmListSessions.funcListSessions(dc, node)
	}
	mmListSessions.t.Fatalf("Unexpected call to SessionMock.ListSessions. %v %v", dc, node)
	return
}

// ListSessionsAfterCounter returns a count of finished SessionMock.ListSessions invocations
func (mmListSessions *SessionMock) ListSessionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSessions.afterListSessionsCounter)
}

// ListSessionsBeforeCounter returns a count of SessionMock.ListSessions invocations
func (mmListSessions *SessionMock) ListSessionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSessions.beforeListSessionsCounter)
}

// Calls returns a list of arguments used in each call to SessionMock.ListSessions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListSessions *mSessionMockListSessions) Calls() []*SessionMockListSessionsParams {
	mmListSessions.mutex.RLock()

	argCopy := make([]*SessionMockListSessionsParams, len(mmListSessions.callArgs))
	copy(argCopy, mmListSessions.callArgs)

	mmListSessions.mutex.RUnlock()

	return argCopy
}

// MinimockListSessionsDone returns true if the count of the ListSessions invocations corresponds
// the number of defined expectations
func (m *SessionMock) MinimockListSessionsDone() bool {
	for _, e := range m.ListSessionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListSessionsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListSessionsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListSessions != nil && mm_atomic.LoadUint64(&m.afterListSessionsCounter) < 1 {
		return false
	}
	return true
}

// MinimockListSessionsInspect logs each unmet expectation
func (m *SessionMock) MinimockListSessionsInspect() {
	for _, e := range m.ListSessionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SessionMock.ListSessions with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListSessionsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListSessionsCounter) < 1 {
		if m.ListSessionsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SessionMock.ListSessions")
		} else {
			m.t.Errorf("Expected call to SessionMock.ListSessions with params: %#v", *m.ListSessionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListSessions != nil && mm_atomic.LoadUint64(&m.afterListSessionsCounter) < 1 {
		m.t.Error("Expected call to SessionMock.ListSessions")
	}
}

type mSessionMockReadSession struct {
	mock               *SessionMock
	defaultExpectation *SessionMockReadSessionExpectation
	expectations       []*SessionMockReadSessionExpectation

	callArgs []*SessionMockReadSessionParams
	mutex    sync.RWMutex
}

// SessionMockReadSessionExpectation specifies expectation struct of the Session.ReadSession
type SessionMockReadSessionExpectation struct {
	mock    *SessionMock
	params  *SessionMockReadSessionParams
	results *SessionMockReadSessionResults
	Counter uint64
}

// SessionMockReadSessionParams contains parameters of the Session.ReadSession
type SessionMockReadSessionParams struct {
	dc string
	id SessionID
}

// SessionMockReadSessionResults contains results of the Session.ReadSession
type SessionMockReadSessionResults struct {
	s1  SessionConfig
	err error
}

// Expect sets up expected params for Session.ReadSession
func (mmReadSession *mSessionMockReadSession) Expect(dc string, id SessionID) *mSessionMockReadSession {
	if mmReadSession.mock.funcReadSession != nil {
		mmReadSession.mock.t.Fatalf("SessionMock.ReadSession mock is already set by Set")
	}

	if mmReadSession.defaultExpectation == nil {
		mmReadSession.defaultExpectation = &SessionMockReadSessionExpectation{}
	}

	mmReadSession.defaultExpectation.params = &SessionMockReadSessionParams{dc, id}
	for _, e := range mmReadSession.expectations {
		if minimock.Equal(e.params, mmReadSession.defaultExpectation.params) {
			mmReadSession.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadSession.defaultExpectation.params)
		}
	}

	return mmReadSession
}

// Return sets up results that will be returned by Session.ReadSession
func (mmReadSession *mSessionMockReadSession) Return(s1 SessionConfig, err error) *SessionMock {
	if mmReadSession.mock.funcReadSession != nil {
		mmReadSession.mock.t.Fatalf("SessionMock.ReadSession mock is already set by Set")
	}

	if mmReadSession.defaultExpectation == nil {
		mmReadSession.defaultExpectation = &SessionMockReadSessionExpectation{mock: mmReadSession.mock}
	}
	mmReadSession.defaultExpectation.results = &SessionMockReadSessionResults{s1, err}
	return mmReadSession.mock
}

//Set uses given function f to mock the Session.ReadSession method
func (mmReadSession *mSessionMockReadSession) Set(f func(dc string, id SessionID) (s1 SessionConfig, err error)) *SessionMock {
	if mmReadSession.defaultExpectation != nil {
		mmReadSession.mock.t.Fatalf("Default expectation is already set for the Session.ReadSession method")
	}

	if len(mmReadSession.expectations) > 0 {
		mmReadSession.mock.t.Fatalf("Some expectations are already set for the Session.ReadSession method")
	}

	mmReadSession.mock.funcReadSession = f
	return mmReadSession.mock
}

// When sets expectation for the Session.ReadSession which will trigger the result defined by the following
// Then helper
func (mmReadSession *mSessionMockReadSession) When(dc string, id SessionID) *SessionMockReadSessionExpectation {
	if mmReadSession.mock.funcReadSession != nil {
		mmReadSession.mock.t.Fatalf("SessionMock.ReadSession mock is already set by Set")
	}

	expectation := &SessionMockReadSessionExpectation{
		mock:   mmReadSession.mock,
		params: &SessionMockReadSessionParams{dc, id},
	}
	mmReadSession.expectations = append(mmReadSession.expectations, expectation)
	return expectation
}

// Then sets up Session.ReadSession return parameters for the expectation previously defined by the When method
func (e *SessionMockReadSessionExpectation) Then(s1 SessionConfig, err error) *SessionMock {
	e.results = &SessionMockReadSessionResults{s1, err}
	return e.mock
}

// ReadSession implements Session
func (mmReadSession *SessionMock) ReadSession(dc string, id SessionID) (s1 SessionConfig, err error) {
	mm_atomic.AddUint64(&mmReadSession.beforeReadSessionCounter, 1)
	defer mm_atomic.AddUint64(&mmReadSession.afterReadSessionCounter, 1)

	params := &SessionMockReadSessionParams{dc, id}

	// Record call args
	mmReadSession.ReadSessionMock.mutex.Lock()
	mmReadSession.ReadSessionMock.callArgs = append(mmReadSession.ReadSessionMock.callArgs, params)
	mmReadSession.ReadSessionMock.mutex.Unlock()

	for _, e := range mmReadSession.ReadSessionMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmReadSession.ReadSessionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadSession.ReadSessionMock.defaultExpectation.Counter, 1)
		want := mmReadSession.ReadSessionMock.defaultExpectation.params
		got := SessionMockReadSessionParams{dc, id}
		if want != nil && !minimock.Equal(*want, got) {
			mmReadSession.t.Errorf("SessionMock.ReadSession got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmReadSession.ReadSessionMock.defaultExpectation.results
		if results == nil {
			mmReadSession.t.Fatal("No results are set for the SessionMock.ReadSession")
		}
		return (*results).s1, (*results).err
	}
	if mmReadSession.funcReadSession != nil {
		return mmReadSession.funcReadSession(dc, id)
	}
	mmReadSession.t.Fatalf("Unexpected call to SessionMock.ReadSession. %v %v", dc, id)
	return
}

// ReadSessionAfterCounter returns a count of finished SessionMock.ReadSession invocations
func (mmReadSession *SessionMock) ReadSessionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadSession.afterReadSessionCounter)
}

// ReadSessionBeforeCounter returns a count of SessionMock.ReadSession invocations
func (mmReadSession *SessionMock) ReadSessionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadSession.beforeReadSessionCounter)
}

// Calls returns a list of arguments used in each call to SessionMock.ReadSession.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadSession *mSessionMockReadSession) Calls() []*SessionMockReadSessionParams {
	mmReadSession.mutex.RLock()

	argCopy := make([]*SessionMockReadSessionParams, len(mmReadSession.callArgs))
	copy(argCopy, mmReadSession.callArgs)

	mmReadSession.mutex.RUnlock()

	return argCopy
}

// MinimockReadSessionDone returns true if the count of the ReadSession invocations corresponds
// the number of defined expectations
func (m *SessionMock) MinimockReadSessionDone() bool {
	for _, e := range m.ReadSessionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadSessionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadSessionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadSession != nil && mm_atomic.LoadUint64(&m.afterReadSessionCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadSessionInspect logs each unmet expectation
func (m *SessionMock) MinimockReadSessionInspect() {
	for _, e := range m.ReadSessionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SessionMock.ReadSession with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadSessionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadSessionCounter) < 1 {
		if m.ReadSessionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SessionMock.ReadSession")
		} else {
			m.t.Errorf("Expected call to SessionMock.ReadSession with params: %#v", *m.ReadSessionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadSession != nil && mm_atomic.LoadUint64(&m.afterReadSessionCounter) < 1 {
		m.t.Error("Expected call to SessionMock.ReadSession")
	}
}

type mSessionMockRenewSession struct {
	mock               *SessionMock
	defaultExpectation *SessionMockRenewSessionExpectation
	expectations       []*SessionMockRenewSessionExpectation

	callArgs []*SessionMockRenewSessionParams
	mutex    sync.RWMutex
}

// SessionMockRenewSessionExpectation specifies expectation struct of the Session.RenewSession
type SessionMockRenewSessionExpectation struct {
	mock    *SessionMock
	params  *SessionMockRenewSessionParams
	results *SessionMockRenewSessionResults
	Counter uint64
}

// SessionMockRenewSessionParams contains parameters of the Session.RenewSession
type SessionMockRenewSessionParams struct {
	dc string
	id SessionID
}

// SessionMockRenewSessionResults contains results of the Session.RenewSession
type SessionMockRenewSessionResults struct {
	d1  time.Duration
	err error
}

// Expect sets up expected params for Session.RenewSession
func (mmRenewSession *mSessionMockRenewSession) Expect(dc string, id SessionID) *mSessionMockRenewSession {
	if mmRenewSession.mock.funcRenewSession != nil {
		mmRenewSession.mock.t.Fatalf("SessionMock.RenewSession mock is already set by Set")
	}

	if mmRenewSession.defaultExpectation == nil {
		mmRenewSession.defaultExpectation = &SessionMockRenewSessionExpectation{}
	}

	mmRenewSession.defaultExpectation.params = &SessionMockRenewSessionParams{dc, id}
	for _, e := range mmRenewSession.expectations {
		if minimock.Equal(e.params, mmRenewSession.defaultExpectation.params) {
			mmRenewSession.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRenewSession.defaultExpectation.params)
		}
	}

	return mmRenewSession
}

// Return sets up results that will be returned by Session.RenewSession
func (mmRenewSession *mSessionMockRenewSession) Return(d1 time.Duration, err error) *SessionMock {
	if mmRenewSession.mock.funcRenewSession != nil {
		mmRenewSession.mock.t.Fatalf("SessionMock.RenewSession mock is already set by Set")
	}

	if mmRenewSession.defaultExpectation == nil {
		mmRenewSession.defaultExpectation = &SessionMockRenewSessionExpectation{mock: mmRenewSession.mock}
	}
	mmRenewSession.defaultExpectation.results = &SessionMockRenewSessionResults{d1, err}
	return mmRenewSession.mock
}

//Set uses given function f to mock the Session.RenewSession method
func (mmRenewSession *mSessionMockRenewSession) Set(f func(dc string, id SessionID) (d1 time.Duration, err error)) *SessionMock {
	if mmRenewSession.defaultExpectation != nil {
		mmRenewSession.mock.t.Fatalf("Default expectation is already set for the Session.RenewSession method")
	}

	if len(mmRenewSession.expectations) > 0 {
		mmRenewSession.mock.t.Fatalf("Some expectations are already set for the Session.RenewSession method")
	}

	mmRenewSession.mock.funcRenewSession = f
	return mmRenewSession.mock
}

// When sets expectation for the Session.RenewSession which will trigger the result defined by the following
// Then helper
func (mmRenewSession *mSessionMockRenewSession) When(dc string, id SessionID) *SessionMockRenewSessionExpectation {
	if mmRenewSession.mock.funcRenewSession != nil {
		mmRenewSession.mock.t.Fatalf("SessionMock.RenewSession mock is already set by Set")
	}

	expectation := &SessionMockRenewSessionExpectation{
		mock:   mmRenewSession.mock,
		params: &SessionMockRenewSessionParams{dc, id},
	}
	mmRenewSession.expectations = append(mmRenewSession.expectations, expectation)
	return expectation
}

// Then sets up Session.RenewSession return parameters for the expectation previously defined by the When method
func (e *SessionMockRenewSessionExpectation) Then(d1 time.Duration, err error) *SessionMock {
	e.results = &SessionMockRenewSessionResults{d1, err}
	return e.mock
}

// RenewSession implements Session
func (mmRenewSession *SessionMock) RenewSession(dc string, id SessionID) (d1 time.Duration, err error) {
	mm_atomic.AddUint64(&mmRenewSession.beforeRenewSessionCounter, 1)
	defer mm_atomic.AddUint64(&mmRenewSession.afterRenewSessionCounter, 1)

	params := &SessionMockRenewSessionParams{dc, id}

	// Record call args
	mmRenewSession.RenewSessionMock.mutex.Lock()
	mmRenewSession.RenewSessionMock.callArgs = append(mmRenewSession.RenewSessionMock.callArgs, params)
	mmRenewSession.RenewSessionMock.mutex.Unlock()

	for _, e := range mmRenewSession.RenewSessionMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.d1, e.results.err
		}
	}

	if mmRenewSession.RenewSessionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRenewSession.RenewSessionMock.defaultExpectation.Counter, 1)
		want := mmRenewSession.RenewSessionMock.defaultExpectation.params
		got := SessionMockRenewSessionParams{dc, id}
		if want != nil && !minimock.Equal(*want, got) {
			mmRenewSession.t.Errorf("SessionMock.RenewSession got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmRenewSession.RenewSessionMock.defaultExpectation.results
		if results == nil {
			mmRenewSession.t.Fatal("No results are set for the SessionMock.RenewSession")
		}
		return (*results).d1, (*results).err
	}
	if mmRenewSession.funcRenewSession != nil {
		return mmRenewSession.funcRenewSession(dc, id)
	}
	mmRenewSession.t.Fatalf("Unexpected call to SessionMock.RenewSession. %v %v", dc, id)
	return
}

// RenewSessionAfterCounter returns a count of finished SessionMock.RenewSession invocations
func (mmRenewSession *SessionMock) RenewSessionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRenewSession.afterRenewSessionCounter)
}

// RenewSessionBeforeCounter returns a count of SessionMock.RenewSession invocations
func (mmRenewSession *SessionMock) RenewSessionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRenewSession.beforeRenewSessionCounter)
}

// Calls returns a list of arguments used in each call to SessionMock.RenewSession.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRenewSession *mSessionMockRenewSession) Calls() []*SessionMockRenewSessionParams {
	mmRenewSession.mutex.RLock()

	argCopy := make([]*SessionMockRenewSessionParams, len(mmRenewSession.callArgs))
	copy(argCopy, mmRenewSession.callArgs)

	mmRenewSession.mutex.RUnlock()

	return argCopy
}

// MinimockRenewSessionDone returns true if the count of the RenewSession invocations corresponds
// the number of defined expectations
func (m *SessionMock) MinimockRenewSessionDone() bool {
	for _, e := range m.RenewSessionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RenewSessionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRenewSessionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRenewSession != nil && mm_atomic.LoadUint64(&m.afterRenewSessionCounter) < 1 {
		return false
	}
	return true
}

// MinimockRenewSessionInspect logs each unmet expectation
func (m *SessionMock) MinimockRenewSessionInspect() {
	for _, e := range m.RenewSessionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SessionMock.RenewSession with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RenewSessionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRenewSessionCounter) < 1 {
		if m.RenewSessionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SessionMock.RenewSession")
		} else {
			m.t.Errorf("Expected call to SessionMock.RenewSession with params: %#v", *m.RenewSessionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRenewSession != nil && mm_atomic.LoadUint64(&m.afterRenewSessionCounter) < 1 {
		m.t.Error("Expected call to SessionMock.RenewSession")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SessionMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateSessionInspect()

		m.MinimockDeleteSessionInspect()

		m.MinimockListSessionsInspect()

		m.MinimockReadSessionInspect()

		m.MinimockRenewSessionInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SessionMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SessionMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateSessionDone() &&
		m.MinimockDeleteSessionDone() &&
		m.MinimockListSessionsDone() &&
		m.MinimockReadSessionDone() &&
		m.MinimockRenewSessionDone()
}
