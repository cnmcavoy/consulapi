package consulapi

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
)

// CatalogMock implements Catalog
type CatalogMock struct {
	t minimock.Tester

	funcDatacenters          func() (sa1 []string, err error)
	afterDatacentersCounter  uint64
	beforeDatacentersCounter uint64
	DatacentersMock          mCatalogMockDatacenters

	funcNode          func(dc string, name string) (n1 NodeInfo, err error)
	afterNodeCounter  uint64
	beforeNodeCounter uint64
	NodeMock          mCatalogMockNode

	funcNodes          func(dc string) (na1 []Node, err error)
	afterNodesCounter  uint64
	beforeNodesCounter uint64
	NodesMock          mCatalogMockNodes

	funcService          func(dc string, service string, tags ...string) (sa1 []Service, err error)
	afterServiceCounter  uint64
	beforeServiceCounter uint64
	ServiceMock          mCatalogMockService

	funcServices          func(dc string) (m1 map[string][]string, err error)
	afterServicesCounter  uint64
	beforeServicesCounter uint64
	ServicesMock          mCatalogMockServices
}

// NewCatalogMock returns a mock for Catalog
func NewCatalogMock(t minimock.Tester) *CatalogMock {
	m := &CatalogMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DatacentersMock = mCatalogMockDatacenters{mock: m}

	m.NodeMock = mCatalogMockNode{mock: m}
	m.NodeMock.callArgs = []*CatalogMockNodeParams{}

	m.NodesMock = mCatalogMockNodes{mock: m}
	m.NodesMock.callArgs = []*CatalogMockNodesParams{}

	m.ServiceMock = mCatalogMockService{mock: m}
	m.ServiceMock.callArgs = []*CatalogMockServiceParams{}

	m.ServicesMock = mCatalogMockServices{mock: m}
	m.ServicesMock.callArgs = []*CatalogMockServicesParams{}

	return m
}

type mCatalogMockDatacenters struct {
	mock               *CatalogMock
	defaultExpectation *CatalogMockDatacentersExpectation
	expectations       []*CatalogMockDatacentersExpectation
}

// CatalogMockDatacentersExpectation specifies expectation struct of the Catalog.Datacenters
type CatalogMockDatacentersExpectation struct {
	mock *CatalogMock

	results *CatalogMockDatacentersResults
	Counter uint64
}

// CatalogMockDatacentersResults contains results of the Catalog.Datacenters
type CatalogMockDatacentersResults struct {
	sa1 []string
	err error
}

// Expect sets up expected params for Catalog.Datacenters
func (mmDatacenters *mCatalogMockDatacenters) Expect() *mCatalogMockDatacenters {
	if mmDatacenters.mock.funcDatacenters != nil {
		mmDatacenters.mock.t.Fatalf("CatalogMock.Datacenters mock is already set by Set")
	}

	if mmDatacenters.defaultExpectation == nil {
		mmDatacenters.defaultExpectation = &CatalogMockDatacentersExpectation{}
	}

	return mmDatacenters
}

// Return sets up results that will be returned by Catalog.Datacenters
func (mmDatacenters *mCatalogMockDatacenters) Return(sa1 []string, err error) *CatalogMock {
	if mmDatacenters.mock.funcDatacenters != nil {
		mmDatacenters.mock.t.Fatalf("CatalogMock.Datacenters mock is already set by Set")
	}

	if mmDatacenters.defaultExpectation == nil {
		mmDatacenters.defaultExpectation = &CatalogMockDatacentersExpectation{mock: mmDatacenters.mock}
	}
	mmDatacenters.defaultExpectation.results = &CatalogMockDatacentersResults{sa1, err}
	return mmDatacenters.mock
}

//Set uses given function f to mock the Catalog.Datacenters method
func (mmDatacenters *mCatalogMockDatacenters) Set(f func() (sa1 []string, err error)) *CatalogMock {
	if mmDatacenters.defaultExpectation != nil {
		mmDatacenters.mock.t.Fatalf("Default expectation is already set for the Catalog.Datacenters method")
	}

	if len(mmDatacenters.expectations) > 0 {
		mmDatacenters.mock.t.Fatalf("Some expectations are already set for the Catalog.Datacenters method")
	}

	mmDatacenters.mock.funcDatacenters = f
	return mmDatacenters.mock
}

// Datacenters implements Catalog
func (mmDatacenters *CatalogMock) Datacenters() (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmDatacenters.beforeDatacentersCounter, 1)
	defer mm_atomic.AddUint64(&mmDatacenters.afterDatacentersCounter, 1)

	if mmDatacenters.DatacentersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDatacenters.DatacentersMock.defaultExpectation.Counter, 1)

		results := mmDatacenters.DatacentersMock.defaultExpectation.results
		if results == nil {
			mmDatacenters.t.Fatal("No results are set for the CatalogMock.Datacenters")
		}
		return (*results).sa1, (*results).err
	}
	if mmDatacenters.funcDatacenters != nil {
		return mmDatacenters.funcDatacenters()
	}
	mmDatacenters.t.Fatalf("Unexpected call to CatalogMock.Datacenters.")
	return
}

// DatacentersAfterCounter returns a count of finished CatalogMock.Datacenters invocations
func (mmDatacenters *CatalogMock) DatacentersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDatacenters.afterDatacentersCounter)
}

// DatacentersBeforeCounter returns a count of CatalogMock.Datacenters invocations
func (mmDatacenters *CatalogMock) DatacentersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDatacenters.beforeDatacentersCounter)
}

// MinimockDatacentersDone returns true if the count of the Datacenters invocations corresponds
// the number of defined expectations
func (m *CatalogMock) MinimockDatacentersDone() bool {
	for _, e := range m.DatacentersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DatacentersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDatacentersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDatacenters != nil && mm_atomic.LoadUint64(&m.afterDatacentersCounter) < 1 {
		return false
	}
	return true
}

// MinimockDatacentersInspect logs each unmet expectation
func (m *CatalogMock) MinimockDatacentersInspect() {
	for _, e := range m.DatacentersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to CatalogMock.Datacenters")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DatacentersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDatacentersCounter) < 1 {
		m.t.Error("Expected call to CatalogMock.Datacenters")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDatacenters != nil && mm_atomic.LoadUint64(&m.afterDatacentersCounter) < 1 {
		m.t.Error("Expected call to CatalogMock.Datacenters")
	}
}

type mCatalogMockNode struct {
	mock               *CatalogMock
	defaultExpectation *CatalogMockNodeExpectation
	expectations       []*CatalogMockNodeExpectation

	callArgs []*CatalogMockNodeParams
	mutex    sync.RWMutex
}

// CatalogMockNodeExpectation specifies expectation struct of the Catalog.Node
type CatalogMockNodeExpectation struct {
	mock    *CatalogMock
	params  *CatalogMockNodeParams
	results *CatalogMockNodeResults
	Counter uint64
}

// CatalogMockNodeParams contains parameters of the Catalog.Node
type CatalogMockNodeParams struct {
	dc   string
	name string
}

// CatalogMockNodeResults contains results of the Catalog.Node
type CatalogMockNodeResults struct {
	n1  NodeInfo
	err error
}

// Expect sets up expected params for Catalog.Node
func (mmNode *mCatalogMockNode) Expect(dc string, name string) *mCatalogMockNode {
	if mmNode.mock.funcNode != nil {
		mmNode.mock.t.Fatalf("CatalogMock.Node mock is already set by Set")
	}

	if mmNode.defaultExpectation == nil {
		mmNode.defaultExpectation = &CatalogMockNodeExpectation{}
	}

	mmNode.defaultExpectation.params = &CatalogMockNodeParams{dc, name}
	for _, e := range mmNode.expectations {
		if minimock.Equal(e.params, mmNode.defaultExpectation.params) {
			mmNode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNode.defaultExpectation.params)
		}
	}

	return mmNode
}

// Return sets up results that will be returned by Catalog.Node
func (mmNode *mCatalogMockNode) Return(n1 NodeInfo, err error) *CatalogMock {
	if mmNode.mock.funcNode != nil {
		mmNode.mock.t.Fatalf("CatalogMock.Node mock is already set by Set")
	}

	if mmNode.defaultExpectation == nil {
		mmNode.defaultExpectation = &CatalogMockNodeExpectation{mock: mmNode.mock}
	}
	mmNode.defaultExpectation.results = &CatalogMockNodeResults{n1, err}
	return mmNode.mock
}

//Set uses given function f to mock the Catalog.Node method
func (mmNode *mCatalogMockNode) Set(f func(dc string, name string) (n1 NodeInfo, err error)) *CatalogMock {
	if mmNode.defaultExpectation != nil {
		mmNode.mock.t.Fatalf("Default expectation is already set for the Catalog.Node method")
	}

	if len(mmNode.expectations) > 0 {
		mmNode.mock.t.Fatalf("Some expectations are already set for the Catalog.Node method")
	}

	mmNode.mock.funcNode = f
	return mmNode.mock
}

// When sets expectation for the Catalog.Node which will trigger the result defined by the following
// Then helper
func (mmNode *mCatalogMockNode) When(dc string, name string) *CatalogMockNodeExpectation {
	if mmNode.mock.funcNode != nil {
		mmNode.mock.t.Fatalf("CatalogMock.Node mock is already set by Set")
	}

	expectation := &CatalogMockNodeExpectation{
		mock:   mmNode.mock,
		params: &CatalogMockNodeParams{dc, name},
	}
	mmNode.expectations = append(mmNode.expectations, expectation)
	return expectation
}

// Then sets up Catalog.Node return parameters for the expectation previously defined by the When method
func (e *CatalogMockNodeExpectation) Then(n1 NodeInfo, err error) *CatalogMock {
	e.results = &CatalogMockNodeResults{n1, err}
	return e.mock
}

// Node implements Catalog
func (mmNode *CatalogMock) Node(dc string, name string) (n1 NodeInfo, err error) {
	mm_atomic.AddUint64(&mmNode.beforeNodeCounter, 1)
	defer mm_atomic.AddUint64(&mmNode.afterNodeCounter, 1)

	params := &CatalogMockNodeParams{dc, name}

	// Record call args
	mmNode.NodeMock.mutex.Lock()
	mmNode.NodeMock.callArgs = append(mmNode.NodeMock.callArgs, params)
	mmNode.NodeMock.mutex.Unlock()

	for _, e := range mmNode.NodeMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n1, e.results.err
		}
	}

	if mmNode.NodeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNode.NodeMock.defaultExpectation.Counter, 1)
		want := mmNode.NodeMock.defaultExpectation.params
		got := CatalogMockNodeParams{dc, name}
		if want != nil && !minimock.Equal(*want, got) {
			mmNode.t.Errorf("CatalogMock.Node got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmNode.NodeMock.defaultExpectation.results
		if results == nil {
			mmNode.t.Fatal("No results are set for the CatalogMock.Node")
		}
		return (*results).n1, (*results).err
	}
	if mmNode.funcNode != nil {
		return mmNode.funcNode(dc, name)
	}
	mmNode.t.Fatalf("Unexpected call to CatalogMock.Node. %v %v", dc, name)
	return
}

// NodeAfterCounter returns a count of finished CatalogMock.Node invocations
func (mmNode *CatalogMock) NodeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNode.afterNodeCounter)
}

// NodeBeforeCounter returns a count of CatalogMock.Node invocations
func (mmNode *CatalogMock) NodeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNode.beforeNodeCounter)
}

// Calls returns a list of arguments used in each call to CatalogMock.Node.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNode *mCatalogMockNode) Calls() []*CatalogMockNodeParams {
	mmNode.mutex.RLock()

	argCopy := make([]*CatalogMockNodeParams, len(mmNode.callArgs))
	copy(argCopy, mmNode.callArgs)

	mmNode.mutex.RUnlock()

	return argCopy
}

// MinimockNodeDone returns true if the count of the Node invocations corresponds
// the number of defined expectations
func (m *CatalogMock) MinimockNodeDone() bool {
	for _, e := range m.NodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNodeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNode != nil && mm_atomic.LoadUint64(&m.afterNodeCounter) < 1 {
		return false
	}
	return true
}

// MinimockNodeInspect logs each unmet expectation
func (m *CatalogMock) MinimockNodeInspect() {
	for _, e := range m.NodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CatalogMock.Node with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNodeCounter) < 1 {
		if m.NodeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CatalogMock.Node")
		} else {
			m.t.Errorf("Expected call to CatalogMock.Node with params: %#v", *m.NodeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNode != nil && mm_atomic.LoadUint64(&m.afterNodeCounter) < 1 {
		m.t.Error("Expected call to CatalogMock.Node")
	}
}

type mCatalogMockNodes struct {
	mock               *CatalogMock
	defaultExpectation *CatalogMockNodesExpectation
	expectations       []*CatalogMockNodesExpectation

	callArgs []*CatalogMockNodesParams
	mutex    sync.RWMutex
}

// CatalogMockNodesExpectation specifies expectation struct of the Catalog.Nodes
type CatalogMockNodesExpectation struct {
	mock    *CatalogMock
	params  *CatalogMockNodesParams
	results *CatalogMockNodesResults
	Counter uint64
}

// CatalogMockNodesParams contains parameters of the Catalog.Nodes
type CatalogMockNodesParams struct {
	dc string
}

// CatalogMockNodesResults contains results of the Catalog.Nodes
type CatalogMockNodesResults struct {
	na1 []Node
	err error
}

// Expect sets up expected params for Catalog.Nodes
func (mmNodes *mCatalogMockNodes) Expect(dc string) *mCatalogMockNodes {
	if mmNodes.mock.funcNodes != nil {
		mmNodes.mock.t.Fatalf("CatalogMock.Nodes mock is already set by Set")
	}

	if mmNodes.defaultExpectation == nil {
		mmNodes.defaultExpectation = &CatalogMockNodesExpectation{}
	}

	mmNodes.defaultExpectation.params = &CatalogMockNodesParams{dc}
	for _, e := range mmNodes.expectations {
		if minimock.Equal(e.params, mmNodes.defaultExpectation.params) {
			mmNodes.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNodes.defaultExpectation.params)
		}
	}

	return mmNodes
}

// Return sets up results that will be returned by Catalog.Nodes
func (mmNodes *mCatalogMockNodes) Return(na1 []Node, err error) *CatalogMock {
	if mmNodes.mock.funcNodes != nil {
		mmNodes.mock.t.Fatalf("CatalogMock.Nodes mock is already set by Set")
	}

	if mmNodes.defaultExpectation == nil {
		mmNodes.defaultExpectation = &CatalogMockNodesExpectation{mock: mmNodes.mock}
	}
	mmNodes.defaultExpectation.results = &CatalogMockNodesResults{na1, err}
	return mmNodes.mock
}

//Set uses given function f to mock the Catalog.Nodes method
func (mmNodes *mCatalogMockNodes) Set(f func(dc string) (na1 []Node, err error)) *CatalogMock {
	if mmNodes.defaultExpectation != nil {
		mmNodes.mock.t.Fatalf("Default expectation is already set for the Catalog.Nodes method")
	}

	if len(mmNodes.expectations) > 0 {
		mmNodes.mock.t.Fatalf("Some expectations are already set for the Catalog.Nodes method")
	}

	mmNodes.mock.funcNodes = f
	return mmNodes.mock
}

// When sets expectation for the Catalog.Nodes which will trigger the result defined by the following
// Then helper
func (mmNodes *mCatalogMockNodes) When(dc string) *CatalogMockNodesExpectation {
	if mmNodes.mock.funcNodes != nil {
		mmNodes.mock.t.Fatalf("CatalogMock.Nodes mock is already set by Set")
	}

	expectation := &CatalogMockNodesExpectation{
		mock:   mmNodes.mock,
		params: &CatalogMockNodesParams{dc},
	}
	mmNodes.expectations = append(mmNodes.expectations, expectation)
	return expectation
}

// Then sets up Catalog.Nodes return parameters for the expectation previously defined by the When method
func (e *CatalogMockNodesExpectation) Then(na1 []Node, err error) *CatalogMock {
	e.results = &CatalogMockNodesResults{na1, err}
	return e.mock
}

// Nodes implements Catalog
func (mmNodes *CatalogMock) Nodes(dc string) (na1 []Node, err error) {
	mm_atomic.AddUint64(&mmNodes.beforeNodesCounter, 1)
	defer mm_atomic.AddUint64(&mmNodes.afterNodesCounter, 1)

	params := &CatalogMockNodesParams{dc}

	// Record call args
	mmNodes.NodesMock.mutex.Lock()
	mmNodes.NodesMock.callArgs = append(mmNodes.NodesMock.callArgs, params)
	mmNodes.NodesMock.mutex.Unlock()

	for _, e := range mmNodes.NodesMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.na1, e.results.err
		}
	}

	if mmNodes.NodesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNodes.NodesMock.defaultExpectation.Counter, 1)
		want := mmNodes.NodesMock.defaultExpectation.params
		got := CatalogMockNodesParams{dc}
		if want != nil && !minimock.Equal(*want, got) {
			mmNodes.t.Errorf("CatalogMock.Nodes got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmNodes.NodesMock.defaultExpectation.results
		if results == nil {
			mmNodes.t.Fatal("No results are set for the CatalogMock.Nodes")
		}
		return (*results).na1, (*results).err
	}
	if mmNodes.funcNodes != nil {
		return mmNodes.funcNodes(dc)
	}
	mmNodes.t.Fatalf("Unexpected call to CatalogMock.Nodes. %v", dc)
	return
}

// NodesAfterCounter returns a count of finished CatalogMock.Nodes invocations
func (mmNodes *CatalogMock) NodesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNodes.afterNodesCounter)
}

// NodesBeforeCounter returns a count of CatalogMock.Nodes invocations
func (mmNodes *CatalogMock) NodesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNodes.beforeNodesCounter)
}

// Calls returns a list of arguments used in each call to CatalogMock.Nodes.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNodes *mCatalogMockNodes) Calls() []*CatalogMockNodesParams {
	mmNodes.mutex.RLock()

	argCopy := make([]*CatalogMockNodesParams, len(mmNodes.callArgs))
	copy(argCopy, mmNodes.callArgs)

	mmNodes.mutex.RUnlock()

	return argCopy
}

// MinimockNodesDone returns true if the count of the Nodes invocations corresponds
// the number of defined expectations
func (m *CatalogMock) MinimockNodesDone() bool {
	for _, e := range m.NodesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NodesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNodesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNodes != nil && mm_atomic.LoadUint64(&m.afterNodesCounter) < 1 {
		return false
	}
	return true
}

// MinimockNodesInspect logs each unmet expectation
func (m *CatalogMock) MinimockNodesInspect() {
	for _, e := range m.NodesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CatalogMock.Nodes with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NodesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNodesCounter) < 1 {
		if m.NodesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CatalogMock.Nodes")
		} else {
			m.t.Errorf("Expected call to CatalogMock.Nodes with params: %#v", *m.NodesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNodes != nil && mm_atomic.LoadUint64(&m.afterNodesCounter) < 1 {
		m.t.Error("Expected call to CatalogMock.Nodes")
	}
}

type mCatalogMockService struct {
	mock               *CatalogMock
	defaultExpectation *CatalogMockServiceExpectation
	expectations       []*CatalogMockServiceExpectation

	callArgs []*CatalogMockServiceParams
	mutex    sync.RWMutex
}

// CatalogMockServiceExpectation specifies expectation struct of the Catalog.Service
type CatalogMockServiceExpectation struct {
	mock    *CatalogMock
	params  *CatalogMockServiceParams
	results *CatalogMockServiceResults
	Counter uint64
}

// CatalogMockServiceParams contains parameters of the Catalog.Service
type CatalogMockServiceParams struct {
	dc      string
	service string
	tags    []string
}

// CatalogMockServiceResults contains results of the Catalog.Service
type CatalogMockServiceResults struct {
	sa1 []Service
	err error
}

// Expect sets up expected params for Catalog.Service
func (mmService *mCatalogMockService) Expect(dc string, service string, tags ...string) *mCatalogMockService {
	if mmService.mock.funcService != nil {
		mmService.mock.t.Fatalf("CatalogMock.Service mock is already set by Set")
	}

	if mmService.defaultExpectation == nil {
		mmService.defaultExpectation = &CatalogMockServiceExpectation{}
	}

	mmService.defaultExpectation.params = &CatalogMockServiceParams{dc, service, tags}
	for _, e := range mmService.expectations {
		if minimock.Equal(e.params, mmService.defaultExpectation.params) {
			mmService.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmService.defaultExpectation.params)
		}
	}

	return mmService
}

// Return sets up results that will be returned by Catalog.Service
func (mmService *mCatalogMockService) Return(sa1 []Service, err error) *CatalogMock {
	if mmService.mock.funcService != nil {
		mmService.mock.t.Fatalf("CatalogMock.Service mock is already set by Set")
	}

	if mmService.defaultExpectation == nil {
		mmService.defaultExpectation = &CatalogMockServiceExpectation{mock: mmService.mock}
	}
	mmService.defaultExpectation.results = &CatalogMockServiceResults{sa1, err}
	return mmService.mock
}

//Set uses given function f to mock the Catalog.Service method
func (mmService *mCatalogMockService) Set(f func(dc string, service string, tags ...string) (sa1 []Service, err error)) *CatalogMock {
	if mmService.defaultExpectation != nil {
		mmService.mock.t.Fatalf("Default expectation is already set for the Catalog.Service method")
	}

	if len(mmService.expectations) > 0 {
		mmService.mock.t.Fatalf("Some expectations are already set for the Catalog.Service method")
	}

	mmService.mock.funcService = f
	return mmService.mock
}

// When sets expectation for the Catalog.Service which will trigger the result defined by the following
// Then helper
func (mmService *mCatalogMockService) When(dc string, service string, tags ...string) *CatalogMockServiceExpectation {
	if mmService.mock.funcService != nil {
		mmService.mock.t.Fatalf("CatalogMock.Service mock is already set by Set")
	}

	expectation := &CatalogMockServiceExpectation{
		mock:   mmService.mock,
		params: &CatalogMockServiceParams{dc, service, tags},
	}
	mmService.expectations = append(mmService.expectations, expectation)
	return expectation
}

// Then sets up Catalog.Service return parameters for the expectation previously defined by the When method
func (e *CatalogMockServiceExpectation) Then(sa1 []Service, err error) *CatalogMock {
	e.results = &CatalogMockServiceResults{sa1, err}
	return e.mock
}

// Service implements Catalog
func (mmService *CatalogMock) Service(dc string, service string, tags ...string) (sa1 []Service, err error) {
	mm_atomic.AddUint64(&mmService.beforeServiceCounter, 1)
	defer mm_atomic.AddUint64(&mmService.afterServiceCounter, 1)

	params := &CatalogMockServiceParams{dc, service, tags}

	// Record call args
	mmService.ServiceMock.mutex.Lock()
	mmService.ServiceMock.callArgs = append(mmService.ServiceMock.callArgs, params)
	mmService.ServiceMock.mutex.Unlock()

	for _, e := range mmService.ServiceMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmService.ServiceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmService.ServiceMock.defaultExpectation.Counter, 1)
		want := mmService.ServiceMock.defaultExpectation.params
		got := CatalogMockServiceParams{dc, service, tags}
		if want != nil && !minimock.Equal(*want, got) {
			mmService.t.Errorf("CatalogMock.Service got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmService.ServiceMock.defaultExpectation.results
		if results == nil {
			mmService.t.Fatal("No results are set for the CatalogMock.Service")
		}
		return (*results).sa1, (*results).err
	}
	if mmService.funcService != nil {
		return mmService.funcService(dc, service, tags...)
	}
	mmService.t.Fatalf("Unexpected call to CatalogMock.Service. %v %v %v", dc, service, tags)
	return
}

// ServiceAfterCounter returns a count of finished CatalogMock.Service invocations
func (mmService *CatalogMock) ServiceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmService.afterServiceCounter)
}

// ServiceBeforeCounter returns a count of CatalogMock.Service invocations
func (mmService *CatalogMock) ServiceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmService.beforeServiceCounter)
}

// Calls returns a list of arguments used in each call to CatalogMock.Service.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmService *mCatalogMockService) Calls() []*CatalogMockServiceParams {
	mmService.mutex.RLock()

	argCopy := make([]*CatalogMockServiceParams, len(mmService.callArgs))
	copy(argCopy, mmService.callArgs)

	mmService.mutex.RUnlock()

	return argCopy
}

// MinimockServiceDone returns true if the count of the Service invocations corresponds
// the number of defined expectations
func (m *CatalogMock) MinimockServiceDone() bool {
	for _, e := range m.ServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ServiceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterServiceCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcService != nil && mm_atomic.LoadUint64(&m.afterServiceCounter) < 1 {
		return false
	}
	return true
}

// MinimockServiceInspect logs each unmet expectation
func (m *CatalogMock) MinimockServiceInspect() {
	for _, e := range m.ServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CatalogMock.Service with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ServiceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterServiceCounter) < 1 {
		if m.ServiceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CatalogMock.Service")
		} else {
			m.t.Errorf("Expected call to CatalogMock.Service with params: %#v", *m.ServiceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcService != nil && mm_atomic.LoadUint64(&m.afterServiceCounter) < 1 {
		m.t.Error("Expected call to CatalogMock.Service")
	}
}

type mCatalogMockServices struct {
	mock               *CatalogMock
	defaultExpectation *CatalogMockServicesExpectation
	expectations       []*CatalogMockServicesExpectation

	callArgs []*CatalogMockServicesParams
	mutex    sync.RWMutex
}

// CatalogMockServicesExpectation specifies expectation struct of the Catalog.Services
type CatalogMockServicesExpectation struct {
	mock    *CatalogMock
	params  *CatalogMockServicesParams
	results *CatalogMockServicesResults
	Counter uint64
}

// CatalogMockServicesParams contains parameters of the Catalog.Services
type CatalogMockServicesParams struct {
	dc string
}

// CatalogMockServicesResults contains results of the Catalog.Services
type CatalogMockServicesResults struct {
	m1  map[string][]string
	err error
}

// Expect sets up expected params for Catalog.Services
func (mmServices *mCatalogMockServices) Expect(dc string) *mCatalogMockServices {
	if mmServices.mock.funcServices != nil {
		mmServices.mock.t.Fatalf("CatalogMock.Services mock is already set by Set")
	}

	if mmServices.defaultExpectation == nil {
		mmServices.defaultExpectation = &CatalogMockServicesExpectation{}
	}

	mmServices.defaultExpectation.params = &CatalogMockServicesParams{dc}
	for _, e := range mmServices.expectations {
		if minimock.Equal(e.params, mmServices.defaultExpectation.params) {
			mmServices.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmServices.defaultExpectation.params)
		}
	}

	return mmServices
}

// Return sets up results that will be returned by Catalog.Services
func (mmServices *mCatalogMockServices) Return(m1 map[string][]string, err error) *CatalogMock {
	if mmServices.mock.funcServices != nil {
		mmServices.mock.t.Fatalf("CatalogMock.Services mock is already set by Set")
	}

	if mmServices.defaultExpectation == nil {
		mmServices.defaultExpectation = &CatalogMockServicesExpectation{mock: mmServices.mock}
	}
	mmServices.defaultExpectation.results = &CatalogMockServicesResults{m1, err}
	return mmServices.mock
}

//Set uses given function f to mock the Catalog.Services method
func (mmServices *mCatalogMockServices) Set(f func(dc string) (m1 map[string][]string, err error)) *CatalogMock {
	if mmServices.defaultExpectation != nil {
		mmServices.mock.t.Fatalf("Default expectation is already set for the Catalog.Services method")
	}

	if len(mmServices.expectations) > 0 {
		mmServices.mock.t.Fatalf("Some expectations are already set for the Catalog.Services method")
	}

	mmServices.mock.funcServices = f
	return mmServices.mock
}

// When sets expectation for the Catalog.Services which will trigger the result defined by the following
// Then helper
func (mmServices *mCatalogMockServices) When(dc string) *CatalogMockServicesExpectation {
	if mmServices.mock.funcServices != nil {
		mmServices.mock.t.Fatalf("CatalogMock.Services mock is already set by Set")
	}

	expectation := &CatalogMockServicesExpectation{
		mock:   mmServices.mock,
		params: &CatalogMockServicesParams{dc},
	}
	mmServices.expectations = append(mmServices.expectations, expectation)
	return expectation
}

// Then sets up Catalog.Services return parameters for the expectation previously defined by the When method
func (e *CatalogMockServicesExpectation) Then(m1 map[string][]string, err error) *CatalogMock {
	e.results = &CatalogMockServicesResults{m1, err}
	return e.mock
}

// Services implements Catalog
func (mmServices *CatalogMock) Services(dc string) (m1 map[string][]string, err error) {
	mm_atomic.AddUint64(&mmServices.beforeServicesCounter, 1)
	defer mm_atomic.AddUint64(&mmServices.afterServicesCounter, 1)

	params := &CatalogMockServicesParams{dc}

	// Record call args
	mmServices.ServicesMock.mutex.Lock()
	mmServices.ServicesMock.callArgs = append(mmServices.ServicesMock.callArgs, params)
	mmServices.ServicesMock.mutex.Unlock()

	for _, e := range mmServices.ServicesMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmServices.ServicesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmServices.ServicesMock.defaultExpectation.Counter, 1)
		want := mmServices.ServicesMock.defaultExpectation.params
		got := CatalogMockServicesParams{dc}
		if want != nil && !minimock.Equal(*want, got) {
			mmServices.t.Errorf("CatalogMock.Services got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmServices.ServicesMock.defaultExpectation.results
		if results == nil {
			mmServices.t.Fatal("No results are set for the CatalogMock.Services")
		}
		return (*results).m1, (*results).err
	}
	if mmServices.funcServices != nil {
		return mmServices.funcServices(dc)
	}
	mmServices.t.Fatalf("Unexpected call to CatalogMock.Services. %v", dc)
	return
}

// ServicesAfterCounter returns a count of finished CatalogMock.Services invocations
func (mmServices *CatalogMock) ServicesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmServices.afterServicesCounter)
}

// ServicesBeforeCounter returns a count of CatalogMock.Services invocations
func (mmServices *CatalogMock) ServicesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmServices.beforeServicesCounter)
}

// Calls returns a list of arguments used in each call to CatalogMock.Services.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmServices *mCatalogMockServices) Calls() []*CatalogMockServicesParams {
	mmServices.mutex.RLock()

	argCopy := make([]*CatalogMockServicesParams, len(mmServices.callArgs))
	copy(argCopy, mmServices.callArgs)

	mmServices.mutex.RUnlock()

	return argCopy
}

// MinimockServicesDone returns true if the count of the Services invocations corresponds
// the number of defined expectations
func (m *CatalogMock) MinimockServicesDone() bool {
	for _, e := range m.ServicesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ServicesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterServicesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcServices != nil && mm_atomic.LoadUint64(&m.afterServicesCounter) < 1 {
		return false
	}
	return true
}

// MinimockServicesInspect logs each unmet expectation
func (m *CatalogMock) MinimockServicesInspect() {
	for _, e := range m.ServicesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CatalogMock.Services with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ServicesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterServicesCounter) < 1 {
		if m.ServicesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CatalogMock.Services")
		} else {
			m.t.Errorf("Expected call to CatalogMock.Services with params: %#v", *m.ServicesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcServices != nil && mm_atomic.LoadUint64(&m.afterServicesCounter) < 1 {
		m.t.Error("Expected call to CatalogMock.Services")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CatalogMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockDatacentersInspect()

		m.MinimockNodeInspect()

		m.MinimockNodesInspect()

		m.MinimockServiceInspect()

		m.MinimockServicesInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CatalogMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CatalogMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDatacentersDone() &&
		m.MinimockNodeDone() &&
		m.MinimockNodesDone() &&
		m.MinimockServiceDone() &&
		m.MinimockServicesDone()
}
