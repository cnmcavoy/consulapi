package consulapi

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CatalogMock implements Catalog
type CatalogMock struct {
	t minimock.Tester

	funcConnect          func(c1 Ctx, s1 string, s2 ServiceQuery) (ia1 []Instance, err error)
	inspectFuncConnect   func(c1 Ctx, s1 string, s2 ServiceQuery)
	afterConnectCounter  uint64
	beforeConnectCounter uint64
	ConnectMock          mCatalogMockConnect

	funcDataCenters          func(c1 Ctx) (sa1 []string, err error)
	inspectFuncDataCenters   func(c1 Ctx)
	afterDataCentersCounter  uint64
	beforeDataCentersCounter uint64
	DataCentersMock          mCatalogMockDataCenters

	funcNode          func(c1 Ctx, s1 string, n1 NodeQuery) (n2 NodeInfo, err error)
	inspectFuncNode   func(c1 Ctx, s1 string, n1 NodeQuery)
	afterNodeCounter  uint64
	beforeNodeCounter uint64
	NodeMock          mCatalogMockNode

	funcNodes          func(c1 Ctx, n1 NodesQuery) (na1 []Node, err error)
	inspectFuncNodes   func(c1 Ctx, n1 NodesQuery)
	afterNodesCounter  uint64
	beforeNodesCounter uint64
	NodesMock          mCatalogMockNodes

	funcService          func(c1 Ctx, s1 string, s2 ServiceQuery) (ia1 []Instance, err error)
	inspectFuncService   func(c1 Ctx, s1 string, s2 ServiceQuery)
	afterServiceCounter  uint64
	beforeServiceCounter uint64
	ServiceMock          mCatalogMockService

	funcServices          func(c1 Ctx, s1 ServicesQuery) (m1 map[string][]string, err error)
	inspectFuncServices   func(c1 Ctx, s1 ServicesQuery)
	afterServicesCounter  uint64
	beforeServicesCounter uint64
	ServicesMock          mCatalogMockServices
}

// NewCatalogMock returns a mock for Catalog
func NewCatalogMock(t minimock.Tester) *CatalogMock {
	m := &CatalogMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ConnectMock = mCatalogMockConnect{mock: m}
	m.ConnectMock.callArgs = []*CatalogMockConnectParams{}

	m.DataCentersMock = mCatalogMockDataCenters{mock: m}
	m.DataCentersMock.callArgs = []*CatalogMockDataCentersParams{}

	m.NodeMock = mCatalogMockNode{mock: m}
	m.NodeMock.callArgs = []*CatalogMockNodeParams{}

	m.NodesMock = mCatalogMockNodes{mock: m}
	m.NodesMock.callArgs = []*CatalogMockNodesParams{}

	m.ServiceMock = mCatalogMockService{mock: m}
	m.ServiceMock.callArgs = []*CatalogMockServiceParams{}

	m.ServicesMock = mCatalogMockServices{mock: m}
	m.ServicesMock.callArgs = []*CatalogMockServicesParams{}

	return m
}

type mCatalogMockConnect struct {
	mock               *CatalogMock
	defaultExpectation *CatalogMockConnectExpectation
	expectations       []*CatalogMockConnectExpectation

	callArgs []*CatalogMockConnectParams
	mutex    sync.RWMutex
}

// CatalogMockConnectExpectation specifies expectation struct of the Catalog.Connect
type CatalogMockConnectExpectation struct {
	mock    *CatalogMock
	params  *CatalogMockConnectParams
	results *CatalogMockConnectResults
	Counter uint64
}

// CatalogMockConnectParams contains parameters of the Catalog.Connect
type CatalogMockConnectParams struct {
	c1 Ctx
	s1 string
	s2 ServiceQuery
}

// CatalogMockConnectResults contains results of the Catalog.Connect
type CatalogMockConnectResults struct {
	ia1 []Instance
	err error
}

// Expect sets up expected params for Catalog.Connect
func (mmConnect *mCatalogMockConnect) Expect(c1 Ctx, s1 string, s2 ServiceQuery) *mCatalogMockConnect {
	if mmConnect.mock.funcConnect != nil {
		mmConnect.mock.t.Fatalf("CatalogMock.Connect mock is already set by Set")
	}

	if mmConnect.defaultExpectation == nil {
		mmConnect.defaultExpectation = &CatalogMockConnectExpectation{}
	}

	mmConnect.defaultExpectation.params = &CatalogMockConnectParams{c1, s1, s2}
	for _, e := range mmConnect.expectations {
		if minimock.Equal(e.params, mmConnect.defaultExpectation.params) {
			mmConnect.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConnect.defaultExpectation.params)
		}
	}

	return mmConnect
}

// Inspect accepts an inspector function that has same arguments as the Catalog.Connect
func (mmConnect *mCatalogMockConnect) Inspect(f func(c1 Ctx, s1 string, s2 ServiceQuery)) *mCatalogMockConnect {
	if mmConnect.mock.inspectFuncConnect != nil {
		mmConnect.mock.t.Fatalf("Inspect function is already set for CatalogMock.Connect")
	}

	mmConnect.mock.inspectFuncConnect = f

	return mmConnect
}

// Return sets up results that will be returned by Catalog.Connect
func (mmConnect *mCatalogMockConnect) Return(ia1 []Instance, err error) *CatalogMock {
	if mmConnect.mock.funcConnect != nil {
		mmConnect.mock.t.Fatalf("CatalogMock.Connect mock is already set by Set")
	}

	if mmConnect.defaultExpectation == nil {
		mmConnect.defaultExpectation = &CatalogMockConnectExpectation{mock: mmConnect.mock}
	}
	mmConnect.defaultExpectation.results = &CatalogMockConnectResults{ia1, err}
	return mmConnect.mock
}

//Set uses given function f to mock the Catalog.Connect method
func (mmConnect *mCatalogMockConnect) Set(f func(c1 Ctx, s1 string, s2 ServiceQuery) (ia1 []Instance, err error)) *CatalogMock {
	if mmConnect.defaultExpectation != nil {
		mmConnect.mock.t.Fatalf("Default expectation is already set for the Catalog.Connect method")
	}

	if len(mmConnect.expectations) > 0 {
		mmConnect.mock.t.Fatalf("Some expectations are already set for the Catalog.Connect method")
	}

	mmConnect.mock.funcConnect = f
	return mmConnect.mock
}

// When sets expectation for the Catalog.Connect which will trigger the result defined by the following
// Then helper
func (mmConnect *mCatalogMockConnect) When(c1 Ctx, s1 string, s2 ServiceQuery) *CatalogMockConnectExpectation {
	if mmConnect.mock.funcConnect != nil {
		mmConnect.mock.t.Fatalf("CatalogMock.Connect mock is already set by Set")
	}

	expectation := &CatalogMockConnectExpectation{
		mock:   mmConnect.mock,
		params: &CatalogMockConnectParams{c1, s1, s2},
	}
	mmConnect.expectations = append(mmConnect.expectations, expectation)
	return expectation
}

// Then sets up Catalog.Connect return parameters for the expectation previously defined by the When method
func (e *CatalogMockConnectExpectation) Then(ia1 []Instance, err error) *CatalogMock {
	e.results = &CatalogMockConnectResults{ia1, err}
	return e.mock
}

// Connect implements Catalog
func (mmConnect *CatalogMock) Connect(c1 Ctx, s1 string, s2 ServiceQuery) (ia1 []Instance, err error) {
	mm_atomic.AddUint64(&mmConnect.beforeConnectCounter, 1)
	defer mm_atomic.AddUint64(&mmConnect.afterConnectCounter, 1)

	if mmConnect.inspectFuncConnect != nil {
		mmConnect.inspectFuncConnect(c1, s1, s2)
	}

	mm_params := &CatalogMockConnectParams{c1, s1, s2}

	// Record call args
	mmConnect.ConnectMock.mutex.Lock()
	mmConnect.ConnectMock.callArgs = append(mmConnect.ConnectMock.callArgs, mm_params)
	mmConnect.ConnectMock.mutex.Unlock()

	for _, e := range mmConnect.ConnectMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ia1, e.results.err
		}
	}

	if mmConnect.ConnectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConnect.ConnectMock.defaultExpectation.Counter, 1)
		mm_want := mmConnect.ConnectMock.defaultExpectation.params
		mm_got := CatalogMockConnectParams{c1, s1, s2}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConnect.t.Errorf("CatalogMock.Connect got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConnect.ConnectMock.defaultExpectation.results
		if mm_results == nil {
			mmConnect.t.Fatal("No results are set for the CatalogMock.Connect")
		}
		return (*mm_results).ia1, (*mm_results).err
	}
	if mmConnect.funcConnect != nil {
		return mmConnect.funcConnect(c1, s1, s2)
	}
	mmConnect.t.Fatalf("Unexpected call to CatalogMock.Connect. %v %v %v", c1, s1, s2)
	return
}

// ConnectAfterCounter returns a count of finished CatalogMock.Connect invocations
func (mmConnect *CatalogMock) ConnectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConnect.afterConnectCounter)
}

// ConnectBeforeCounter returns a count of CatalogMock.Connect invocations
func (mmConnect *CatalogMock) ConnectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConnect.beforeConnectCounter)
}

// Calls returns a list of arguments used in each call to CatalogMock.Connect.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConnect *mCatalogMockConnect) Calls() []*CatalogMockConnectParams {
	mmConnect.mutex.RLock()

	argCopy := make([]*CatalogMockConnectParams, len(mmConnect.callArgs))
	copy(argCopy, mmConnect.callArgs)

	mmConnect.mutex.RUnlock()

	return argCopy
}

// MinimockConnectDone returns true if the count of the Connect invocations corresponds
// the number of defined expectations
func (m *CatalogMock) MinimockConnectDone() bool {
	for _, e := range m.ConnectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ConnectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterConnectCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConnect != nil && mm_atomic.LoadUint64(&m.afterConnectCounter) < 1 {
		return false
	}
	return true
}

// MinimockConnectInspect logs each unmet expectation
func (m *CatalogMock) MinimockConnectInspect() {
	for _, e := range m.ConnectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CatalogMock.Connect with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ConnectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterConnectCounter) < 1 {
		if m.ConnectMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CatalogMock.Connect")
		} else {
			m.t.Errorf("Expected call to CatalogMock.Connect with params: %#v", *m.ConnectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConnect != nil && mm_atomic.LoadUint64(&m.afterConnectCounter) < 1 {
		m.t.Error("Expected call to CatalogMock.Connect")
	}
}

type mCatalogMockDataCenters struct {
	mock               *CatalogMock
	defaultExpectation *CatalogMockDataCentersExpectation
	expectations       []*CatalogMockDataCentersExpectation

	callArgs []*CatalogMockDataCentersParams
	mutex    sync.RWMutex
}

// CatalogMockDataCentersExpectation specifies expectation struct of the Catalog.DataCenters
type CatalogMockDataCentersExpectation struct {
	mock    *CatalogMock
	params  *CatalogMockDataCentersParams
	results *CatalogMockDataCentersResults
	Counter uint64
}

// CatalogMockDataCentersParams contains parameters of the Catalog.DataCenters
type CatalogMockDataCentersParams struct {
	c1 Ctx
}

// CatalogMockDataCentersResults contains results of the Catalog.DataCenters
type CatalogMockDataCentersResults struct {
	sa1 []string
	err error
}

// Expect sets up expected params for Catalog.DataCenters
func (mmDataCenters *mCatalogMockDataCenters) Expect(c1 Ctx) *mCatalogMockDataCenters {
	if mmDataCenters.mock.funcDataCenters != nil {
		mmDataCenters.mock.t.Fatalf("CatalogMock.DataCenters mock is already set by Set")
	}

	if mmDataCenters.defaultExpectation == nil {
		mmDataCenters.defaultExpectation = &CatalogMockDataCentersExpectation{}
	}

	mmDataCenters.defaultExpectation.params = &CatalogMockDataCentersParams{c1}
	for _, e := range mmDataCenters.expectations {
		if minimock.Equal(e.params, mmDataCenters.defaultExpectation.params) {
			mmDataCenters.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDataCenters.defaultExpectation.params)
		}
	}

	return mmDataCenters
}

// Inspect accepts an inspector function that has same arguments as the Catalog.DataCenters
func (mmDataCenters *mCatalogMockDataCenters) Inspect(f func(c1 Ctx)) *mCatalogMockDataCenters {
	if mmDataCenters.mock.inspectFuncDataCenters != nil {
		mmDataCenters.mock.t.Fatalf("Inspect function is already set for CatalogMock.DataCenters")
	}

	mmDataCenters.mock.inspectFuncDataCenters = f

	return mmDataCenters
}

// Return sets up results that will be returned by Catalog.DataCenters
func (mmDataCenters *mCatalogMockDataCenters) Return(sa1 []string, err error) *CatalogMock {
	if mmDataCenters.mock.funcDataCenters != nil {
		mmDataCenters.mock.t.Fatalf("CatalogMock.DataCenters mock is already set by Set")
	}

	if mmDataCenters.defaultExpectation == nil {
		mmDataCenters.defaultExpectation = &CatalogMockDataCentersExpectation{mock: mmDataCenters.mock}
	}
	mmDataCenters.defaultExpectation.results = &CatalogMockDataCentersResults{sa1, err}
	return mmDataCenters.mock
}

//Set uses given function f to mock the Catalog.DataCenters method
func (mmDataCenters *mCatalogMockDataCenters) Set(f func(c1 Ctx) (sa1 []string, err error)) *CatalogMock {
	if mmDataCenters.defaultExpectation != nil {
		mmDataCenters.mock.t.Fatalf("Default expectation is already set for the Catalog.DataCenters method")
	}

	if len(mmDataCenters.expectations) > 0 {
		mmDataCenters.mock.t.Fatalf("Some expectations are already set for the Catalog.DataCenters method")
	}

	mmDataCenters.mock.funcDataCenters = f
	return mmDataCenters.mock
}

// When sets expectation for the Catalog.DataCenters which will trigger the result defined by the following
// Then helper
func (mmDataCenters *mCatalogMockDataCenters) When(c1 Ctx) *CatalogMockDataCentersExpectation {
	if mmDataCenters.mock.funcDataCenters != nil {
		mmDataCenters.mock.t.Fatalf("CatalogMock.DataCenters mock is already set by Set")
	}

	expectation := &CatalogMockDataCentersExpectation{
		mock:   mmDataCenters.mock,
		params: &CatalogMockDataCentersParams{c1},
	}
	mmDataCenters.expectations = append(mmDataCenters.expectations, expectation)
	return expectation
}

// Then sets up Catalog.DataCenters return parameters for the expectation previously defined by the When method
func (e *CatalogMockDataCentersExpectation) Then(sa1 []string, err error) *CatalogMock {
	e.results = &CatalogMockDataCentersResults{sa1, err}
	return e.mock
}

// DataCenters implements Catalog
func (mmDataCenters *CatalogMock) DataCenters(c1 Ctx) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmDataCenters.beforeDataCentersCounter, 1)
	defer mm_atomic.AddUint64(&mmDataCenters.afterDataCentersCounter, 1)

	if mmDataCenters.inspectFuncDataCenters != nil {
		mmDataCenters.inspectFuncDataCenters(c1)
	}

	mm_params := &CatalogMockDataCentersParams{c1}

	// Record call args
	mmDataCenters.DataCentersMock.mutex.Lock()
	mmDataCenters.DataCentersMock.callArgs = append(mmDataCenters.DataCentersMock.callArgs, mm_params)
	mmDataCenters.DataCentersMock.mutex.Unlock()

	for _, e := range mmDataCenters.DataCentersMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmDataCenters.DataCentersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDataCenters.DataCentersMock.defaultExpectation.Counter, 1)
		mm_want := mmDataCenters.DataCentersMock.defaultExpectation.params
		mm_got := CatalogMockDataCentersParams{c1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDataCenters.t.Errorf("CatalogMock.DataCenters got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDataCenters.DataCentersMock.defaultExpectation.results
		if mm_results == nil {
			mmDataCenters.t.Fatal("No results are set for the CatalogMock.DataCenters")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmDataCenters.funcDataCenters != nil {
		return mmDataCenters.funcDataCenters(c1)
	}
	mmDataCenters.t.Fatalf("Unexpected call to CatalogMock.DataCenters. %v", c1)
	return
}

// DataCentersAfterCounter returns a count of finished CatalogMock.DataCenters invocations
func (mmDataCenters *CatalogMock) DataCentersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDataCenters.afterDataCentersCounter)
}

// DataCentersBeforeCounter returns a count of CatalogMock.DataCenters invocations
func (mmDataCenters *CatalogMock) DataCentersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDataCenters.beforeDataCentersCounter)
}

// Calls returns a list of arguments used in each call to CatalogMock.DataCenters.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDataCenters *mCatalogMockDataCenters) Calls() []*CatalogMockDataCentersParams {
	mmDataCenters.mutex.RLock()

	argCopy := make([]*CatalogMockDataCentersParams, len(mmDataCenters.callArgs))
	copy(argCopy, mmDataCenters.callArgs)

	mmDataCenters.mutex.RUnlock()

	return argCopy
}

// MinimockDataCentersDone returns true if the count of the DataCenters invocations corresponds
// the number of defined expectations
func (m *CatalogMock) MinimockDataCentersDone() bool {
	for _, e := range m.DataCentersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DataCentersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDataCentersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDataCenters != nil && mm_atomic.LoadUint64(&m.afterDataCentersCounter) < 1 {
		return false
	}
	return true
}

// MinimockDataCentersInspect logs each unmet expectation
func (m *CatalogMock) MinimockDataCentersInspect() {
	for _, e := range m.DataCentersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CatalogMock.DataCenters with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DataCentersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDataCentersCounter) < 1 {
		if m.DataCentersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CatalogMock.DataCenters")
		} else {
			m.t.Errorf("Expected call to CatalogMock.DataCenters with params: %#v", *m.DataCentersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDataCenters != nil && mm_atomic.LoadUint64(&m.afterDataCentersCounter) < 1 {
		m.t.Error("Expected call to CatalogMock.DataCenters")
	}
}

type mCatalogMockNode struct {
	mock               *CatalogMock
	defaultExpectation *CatalogMockNodeExpectation
	expectations       []*CatalogMockNodeExpectation

	callArgs []*CatalogMockNodeParams
	mutex    sync.RWMutex
}

// CatalogMockNodeExpectation specifies expectation struct of the Catalog.Node
type CatalogMockNodeExpectation struct {
	mock    *CatalogMock
	params  *CatalogMockNodeParams
	results *CatalogMockNodeResults
	Counter uint64
}

// CatalogMockNodeParams contains parameters of the Catalog.Node
type CatalogMockNodeParams struct {
	c1 Ctx
	s1 string
	n1 NodeQuery
}

// CatalogMockNodeResults contains results of the Catalog.Node
type CatalogMockNodeResults struct {
	n2  NodeInfo
	err error
}

// Expect sets up expected params for Catalog.Node
func (mmNode *mCatalogMockNode) Expect(c1 Ctx, s1 string, n1 NodeQuery) *mCatalogMockNode {
	if mmNode.mock.funcNode != nil {
		mmNode.mock.t.Fatalf("CatalogMock.Node mock is already set by Set")
	}

	if mmNode.defaultExpectation == nil {
		mmNode.defaultExpectation = &CatalogMockNodeExpectation{}
	}

	mmNode.defaultExpectation.params = &CatalogMockNodeParams{c1, s1, n1}
	for _, e := range mmNode.expectations {
		if minimock.Equal(e.params, mmNode.defaultExpectation.params) {
			mmNode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNode.defaultExpectation.params)
		}
	}

	return mmNode
}

// Inspect accepts an inspector function that has same arguments as the Catalog.Node
func (mmNode *mCatalogMockNode) Inspect(f func(c1 Ctx, s1 string, n1 NodeQuery)) *mCatalogMockNode {
	if mmNode.mock.inspectFuncNode != nil {
		mmNode.mock.t.Fatalf("Inspect function is already set for CatalogMock.Node")
	}

	mmNode.mock.inspectFuncNode = f

	return mmNode
}

// Return sets up results that will be returned by Catalog.Node
func (mmNode *mCatalogMockNode) Return(n2 NodeInfo, err error) *CatalogMock {
	if mmNode.mock.funcNode != nil {
		mmNode.mock.t.Fatalf("CatalogMock.Node mock is already set by Set")
	}

	if mmNode.defaultExpectation == nil {
		mmNode.defaultExpectation = &CatalogMockNodeExpectation{mock: mmNode.mock}
	}
	mmNode.defaultExpectation.results = &CatalogMockNodeResults{n2, err}
	return mmNode.mock
}

//Set uses given function f to mock the Catalog.Node method
func (mmNode *mCatalogMockNode) Set(f func(c1 Ctx, s1 string, n1 NodeQuery) (n2 NodeInfo, err error)) *CatalogMock {
	if mmNode.defaultExpectation != nil {
		mmNode.mock.t.Fatalf("Default expectation is already set for the Catalog.Node method")
	}

	if len(mmNode.expectations) > 0 {
		mmNode.mock.t.Fatalf("Some expectations are already set for the Catalog.Node method")
	}

	mmNode.mock.funcNode = f
	return mmNode.mock
}

// When sets expectation for the Catalog.Node which will trigger the result defined by the following
// Then helper
func (mmNode *mCatalogMockNode) When(c1 Ctx, s1 string, n1 NodeQuery) *CatalogMockNodeExpectation {
	if mmNode.mock.funcNode != nil {
		mmNode.mock.t.Fatalf("CatalogMock.Node mock is already set by Set")
	}

	expectation := &CatalogMockNodeExpectation{
		mock:   mmNode.mock,
		params: &CatalogMockNodeParams{c1, s1, n1},
	}
	mmNode.expectations = append(mmNode.expectations, expectation)
	return expectation
}

// Then sets up Catalog.Node return parameters for the expectation previously defined by the When method
func (e *CatalogMockNodeExpectation) Then(n2 NodeInfo, err error) *CatalogMock {
	e.results = &CatalogMockNodeResults{n2, err}
	return e.mock
}

// Node implements Catalog
func (mmNode *CatalogMock) Node(c1 Ctx, s1 string, n1 NodeQuery) (n2 NodeInfo, err error) {
	mm_atomic.AddUint64(&mmNode.beforeNodeCounter, 1)
	defer mm_atomic.AddUint64(&mmNode.afterNodeCounter, 1)

	if mmNode.inspectFuncNode != nil {
		mmNode.inspectFuncNode(c1, s1, n1)
	}

	mm_params := &CatalogMockNodeParams{c1, s1, n1}

	// Record call args
	mmNode.NodeMock.mutex.Lock()
	mmNode.NodeMock.callArgs = append(mmNode.NodeMock.callArgs, mm_params)
	mmNode.NodeMock.mutex.Unlock()

	for _, e := range mmNode.NodeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n2, e.results.err
		}
	}

	if mmNode.NodeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNode.NodeMock.defaultExpectation.Counter, 1)
		mm_want := mmNode.NodeMock.defaultExpectation.params
		mm_got := CatalogMockNodeParams{c1, s1, n1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmNode.t.Errorf("CatalogMock.Node got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmNode.NodeMock.defaultExpectation.results
		if mm_results == nil {
			mmNode.t.Fatal("No results are set for the CatalogMock.Node")
		}
		return (*mm_results).n2, (*mm_results).err
	}
	if mmNode.funcNode != nil {
		return mmNode.funcNode(c1, s1, n1)
	}
	mmNode.t.Fatalf("Unexpected call to CatalogMock.Node. %v %v %v", c1, s1, n1)
	return
}

// NodeAfterCounter returns a count of finished CatalogMock.Node invocations
func (mmNode *CatalogMock) NodeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNode.afterNodeCounter)
}

// NodeBeforeCounter returns a count of CatalogMock.Node invocations
func (mmNode *CatalogMock) NodeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNode.beforeNodeCounter)
}

// Calls returns a list of arguments used in each call to CatalogMock.Node.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNode *mCatalogMockNode) Calls() []*CatalogMockNodeParams {
	mmNode.mutex.RLock()

	argCopy := make([]*CatalogMockNodeParams, len(mmNode.callArgs))
	copy(argCopy, mmNode.callArgs)

	mmNode.mutex.RUnlock()

	return argCopy
}

// MinimockNodeDone returns true if the count of the Node invocations corresponds
// the number of defined expectations
func (m *CatalogMock) MinimockNodeDone() bool {
	for _, e := range m.NodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNodeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNode != nil && mm_atomic.LoadUint64(&m.afterNodeCounter) < 1 {
		return false
	}
	return true
}

// MinimockNodeInspect logs each unmet expectation
func (m *CatalogMock) MinimockNodeInspect() {
	for _, e := range m.NodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CatalogMock.Node with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNodeCounter) < 1 {
		if m.NodeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CatalogMock.Node")
		} else {
			m.t.Errorf("Expected call to CatalogMock.Node with params: %#v", *m.NodeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNode != nil && mm_atomic.LoadUint64(&m.afterNodeCounter) < 1 {
		m.t.Error("Expected call to CatalogMock.Node")
	}
}

type mCatalogMockNodes struct {
	mock               *CatalogMock
	defaultExpectation *CatalogMockNodesExpectation
	expectations       []*CatalogMockNodesExpectation

	callArgs []*CatalogMockNodesParams
	mutex    sync.RWMutex
}

// CatalogMockNodesExpectation specifies expectation struct of the Catalog.Nodes
type CatalogMockNodesExpectation struct {
	mock    *CatalogMock
	params  *CatalogMockNodesParams
	results *CatalogMockNodesResults
	Counter uint64
}

// CatalogMockNodesParams contains parameters of the Catalog.Nodes
type CatalogMockNodesParams struct {
	c1 Ctx
	n1 NodesQuery
}

// CatalogMockNodesResults contains results of the Catalog.Nodes
type CatalogMockNodesResults struct {
	na1 []Node
	err error
}

// Expect sets up expected params for Catalog.Nodes
func (mmNodes *mCatalogMockNodes) Expect(c1 Ctx, n1 NodesQuery) *mCatalogMockNodes {
	if mmNodes.mock.funcNodes != nil {
		mmNodes.mock.t.Fatalf("CatalogMock.Nodes mock is already set by Set")
	}

	if mmNodes.defaultExpectation == nil {
		mmNodes.defaultExpectation = &CatalogMockNodesExpectation{}
	}

	mmNodes.defaultExpectation.params = &CatalogMockNodesParams{c1, n1}
	for _, e := range mmNodes.expectations {
		if minimock.Equal(e.params, mmNodes.defaultExpectation.params) {
			mmNodes.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNodes.defaultExpectation.params)
		}
	}

	return mmNodes
}

// Inspect accepts an inspector function that has same arguments as the Catalog.Nodes
func (mmNodes *mCatalogMockNodes) Inspect(f func(c1 Ctx, n1 NodesQuery)) *mCatalogMockNodes {
	if mmNodes.mock.inspectFuncNodes != nil {
		mmNodes.mock.t.Fatalf("Inspect function is already set for CatalogMock.Nodes")
	}

	mmNodes.mock.inspectFuncNodes = f

	return mmNodes
}

// Return sets up results that will be returned by Catalog.Nodes
func (mmNodes *mCatalogMockNodes) Return(na1 []Node, err error) *CatalogMock {
	if mmNodes.mock.funcNodes != nil {
		mmNodes.mock.t.Fatalf("CatalogMock.Nodes mock is already set by Set")
	}

	if mmNodes.defaultExpectation == nil {
		mmNodes.defaultExpectation = &CatalogMockNodesExpectation{mock: mmNodes.mock}
	}
	mmNodes.defaultExpectation.results = &CatalogMockNodesResults{na1, err}
	return mmNodes.mock
}

//Set uses given function f to mock the Catalog.Nodes method
func (mmNodes *mCatalogMockNodes) Set(f func(c1 Ctx, n1 NodesQuery) (na1 []Node, err error)) *CatalogMock {
	if mmNodes.defaultExpectation != nil {
		mmNodes.mock.t.Fatalf("Default expectation is already set for the Catalog.Nodes method")
	}

	if len(mmNodes.expectations) > 0 {
		mmNodes.mock.t.Fatalf("Some expectations are already set for the Catalog.Nodes method")
	}

	mmNodes.mock.funcNodes = f
	return mmNodes.mock
}

// When sets expectation for the Catalog.Nodes which will trigger the result defined by the following
// Then helper
func (mmNodes *mCatalogMockNodes) When(c1 Ctx, n1 NodesQuery) *CatalogMockNodesExpectation {
	if mmNodes.mock.funcNodes != nil {
		mmNodes.mock.t.Fatalf("CatalogMock.Nodes mock is already set by Set")
	}

	expectation := &CatalogMockNodesExpectation{
		mock:   mmNodes.mock,
		params: &CatalogMockNodesParams{c1, n1},
	}
	mmNodes.expectations = append(mmNodes.expectations, expectation)
	return expectation
}

// Then sets up Catalog.Nodes return parameters for the expectation previously defined by the When method
func (e *CatalogMockNodesExpectation) Then(na1 []Node, err error) *CatalogMock {
	e.results = &CatalogMockNodesResults{na1, err}
	return e.mock
}

// Nodes implements Catalog
func (mmNodes *CatalogMock) Nodes(c1 Ctx, n1 NodesQuery) (na1 []Node, err error) {
	mm_atomic.AddUint64(&mmNodes.beforeNodesCounter, 1)
	defer mm_atomic.AddUint64(&mmNodes.afterNodesCounter, 1)

	if mmNodes.inspectFuncNodes != nil {
		mmNodes.inspectFuncNodes(c1, n1)
	}

	mm_params := &CatalogMockNodesParams{c1, n1}

	// Record call args
	mmNodes.NodesMock.mutex.Lock()
	mmNodes.NodesMock.callArgs = append(mmNodes.NodesMock.callArgs, mm_params)
	mmNodes.NodesMock.mutex.Unlock()

	for _, e := range mmNodes.NodesMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.na1, e.results.err
		}
	}

	if mmNodes.NodesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNodes.NodesMock.defaultExpectation.Counter, 1)
		mm_want := mmNodes.NodesMock.defaultExpectation.params
		mm_got := CatalogMockNodesParams{c1, n1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmNodes.t.Errorf("CatalogMock.Nodes got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmNodes.NodesMock.defaultExpectation.results
		if mm_results == nil {
			mmNodes.t.Fatal("No results are set for the CatalogMock.Nodes")
		}
		return (*mm_results).na1, (*mm_results).err
	}
	if mmNodes.funcNodes != nil {
		return mmNodes.funcNodes(c1, n1)
	}
	mmNodes.t.Fatalf("Unexpected call to CatalogMock.Nodes. %v %v", c1, n1)
	return
}

// NodesAfterCounter returns a count of finished CatalogMock.Nodes invocations
func (mmNodes *CatalogMock) NodesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNodes.afterNodesCounter)
}

// NodesBeforeCounter returns a count of CatalogMock.Nodes invocations
func (mmNodes *CatalogMock) NodesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNodes.beforeNodesCounter)
}

// Calls returns a list of arguments used in each call to CatalogMock.Nodes.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNodes *mCatalogMockNodes) Calls() []*CatalogMockNodesParams {
	mmNodes.mutex.RLock()

	argCopy := make([]*CatalogMockNodesParams, len(mmNodes.callArgs))
	copy(argCopy, mmNodes.callArgs)

	mmNodes.mutex.RUnlock()

	return argCopy
}

// MinimockNodesDone returns true if the count of the Nodes invocations corresponds
// the number of defined expectations
func (m *CatalogMock) MinimockNodesDone() bool {
	for _, e := range m.NodesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NodesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNodesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNodes != nil && mm_atomic.LoadUint64(&m.afterNodesCounter) < 1 {
		return false
	}
	return true
}

// MinimockNodesInspect logs each unmet expectation
func (m *CatalogMock) MinimockNodesInspect() {
	for _, e := range m.NodesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CatalogMock.Nodes with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NodesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNodesCounter) < 1 {
		if m.NodesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CatalogMock.Nodes")
		} else {
			m.t.Errorf("Expected call to CatalogMock.Nodes with params: %#v", *m.NodesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNodes != nil && mm_atomic.LoadUint64(&m.afterNodesCounter) < 1 {
		m.t.Error("Expected call to CatalogMock.Nodes")
	}
}

type mCatalogMockService struct {
	mock               *CatalogMock
	defaultExpectation *CatalogMockServiceExpectation
	expectations       []*CatalogMockServiceExpectation

	callArgs []*CatalogMockServiceParams
	mutex    sync.RWMutex
}

// CatalogMockServiceExpectation specifies expectation struct of the Catalog.Service
type CatalogMockServiceExpectation struct {
	mock    *CatalogMock
	params  *CatalogMockServiceParams
	results *CatalogMockServiceResults
	Counter uint64
}

// CatalogMockServiceParams contains parameters of the Catalog.Service
type CatalogMockServiceParams struct {
	c1 Ctx
	s1 string
	s2 ServiceQuery
}

// CatalogMockServiceResults contains results of the Catalog.Service
type CatalogMockServiceResults struct {
	ia1 []Instance
	err error
}

// Expect sets up expected params for Catalog.Service
func (mmService *mCatalogMockService) Expect(c1 Ctx, s1 string, s2 ServiceQuery) *mCatalogMockService {
	if mmService.mock.funcService != nil {
		mmService.mock.t.Fatalf("CatalogMock.Service mock is already set by Set")
	}

	if mmService.defaultExpectation == nil {
		mmService.defaultExpectation = &CatalogMockServiceExpectation{}
	}

	mmService.defaultExpectation.params = &CatalogMockServiceParams{c1, s1, s2}
	for _, e := range mmService.expectations {
		if minimock.Equal(e.params, mmService.defaultExpectation.params) {
			mmService.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmService.defaultExpectation.params)
		}
	}

	return mmService
}

// Inspect accepts an inspector function that has same arguments as the Catalog.Service
func (mmService *mCatalogMockService) Inspect(f func(c1 Ctx, s1 string, s2 ServiceQuery)) *mCatalogMockService {
	if mmService.mock.inspectFuncService != nil {
		mmService.mock.t.Fatalf("Inspect function is already set for CatalogMock.Service")
	}

	mmService.mock.inspectFuncService = f

	return mmService
}

// Return sets up results that will be returned by Catalog.Service
func (mmService *mCatalogMockService) Return(ia1 []Instance, err error) *CatalogMock {
	if mmService.mock.funcService != nil {
		mmService.mock.t.Fatalf("CatalogMock.Service mock is already set by Set")
	}

	if mmService.defaultExpectation == nil {
		mmService.defaultExpectation = &CatalogMockServiceExpectation{mock: mmService.mock}
	}
	mmService.defaultExpectation.results = &CatalogMockServiceResults{ia1, err}
	return mmService.mock
}

//Set uses given function f to mock the Catalog.Service method
func (mmService *mCatalogMockService) Set(f func(c1 Ctx, s1 string, s2 ServiceQuery) (ia1 []Instance, err error)) *CatalogMock {
	if mmService.defaultExpectation != nil {
		mmService.mock.t.Fatalf("Default expectation is already set for the Catalog.Service method")
	}

	if len(mmService.expectations) > 0 {
		mmService.mock.t.Fatalf("Some expectations are already set for the Catalog.Service method")
	}

	mmService.mock.funcService = f
	return mmService.mock
}

// When sets expectation for the Catalog.Service which will trigger the result defined by the following
// Then helper
func (mmService *mCatalogMockService) When(c1 Ctx, s1 string, s2 ServiceQuery) *CatalogMockServiceExpectation {
	if mmService.mock.funcService != nil {
		mmService.mock.t.Fatalf("CatalogMock.Service mock is already set by Set")
	}

	expectation := &CatalogMockServiceExpectation{
		mock:   mmService.mock,
		params: &CatalogMockServiceParams{c1, s1, s2},
	}
	mmService.expectations = append(mmService.expectations, expectation)
	return expectation
}

// Then sets up Catalog.Service return parameters for the expectation previously defined by the When method
func (e *CatalogMockServiceExpectation) Then(ia1 []Instance, err error) *CatalogMock {
	e.results = &CatalogMockServiceResults{ia1, err}
	return e.mock
}

// Service implements Catalog
func (mmService *CatalogMock) Service(c1 Ctx, s1 string, s2 ServiceQuery) (ia1 []Instance, err error) {
	mm_atomic.AddUint64(&mmService.beforeServiceCounter, 1)
	defer mm_atomic.AddUint64(&mmService.afterServiceCounter, 1)

	if mmService.inspectFuncService != nil {
		mmService.inspectFuncService(c1, s1, s2)
	}

	mm_params := &CatalogMockServiceParams{c1, s1, s2}

	// Record call args
	mmService.ServiceMock.mutex.Lock()
	mmService.ServiceMock.callArgs = append(mmService.ServiceMock.callArgs, mm_params)
	mmService.ServiceMock.mutex.Unlock()

	for _, e := range mmService.ServiceMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ia1, e.results.err
		}
	}

	if mmService.ServiceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmService.ServiceMock.defaultExpectation.Counter, 1)
		mm_want := mmService.ServiceMock.defaultExpectation.params
		mm_got := CatalogMockServiceParams{c1, s1, s2}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmService.t.Errorf("CatalogMock.Service got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmService.ServiceMock.defaultExpectation.results
		if mm_results == nil {
			mmService.t.Fatal("No results are set for the CatalogMock.Service")
		}
		return (*mm_results).ia1, (*mm_results).err
	}
	if mmService.funcService != nil {
		return mmService.funcService(c1, s1, s2)
	}
	mmService.t.Fatalf("Unexpected call to CatalogMock.Service. %v %v %v", c1, s1, s2)
	return
}

// ServiceAfterCounter returns a count of finished CatalogMock.Service invocations
func (mmService *CatalogMock) ServiceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmService.afterServiceCounter)
}

// ServiceBeforeCounter returns a count of CatalogMock.Service invocations
func (mmService *CatalogMock) ServiceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmService.beforeServiceCounter)
}

// Calls returns a list of arguments used in each call to CatalogMock.Service.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmService *mCatalogMockService) Calls() []*CatalogMockServiceParams {
	mmService.mutex.RLock()

	argCopy := make([]*CatalogMockServiceParams, len(mmService.callArgs))
	copy(argCopy, mmService.callArgs)

	mmService.mutex.RUnlock()

	return argCopy
}

// MinimockServiceDone returns true if the count of the Service invocations corresponds
// the number of defined expectations
func (m *CatalogMock) MinimockServiceDone() bool {
	for _, e := range m.ServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ServiceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterServiceCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcService != nil && mm_atomic.LoadUint64(&m.afterServiceCounter) < 1 {
		return false
	}
	return true
}

// MinimockServiceInspect logs each unmet expectation
func (m *CatalogMock) MinimockServiceInspect() {
	for _, e := range m.ServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CatalogMock.Service with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ServiceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterServiceCounter) < 1 {
		if m.ServiceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CatalogMock.Service")
		} else {
			m.t.Errorf("Expected call to CatalogMock.Service with params: %#v", *m.ServiceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcService != nil && mm_atomic.LoadUint64(&m.afterServiceCounter) < 1 {
		m.t.Error("Expected call to CatalogMock.Service")
	}
}

type mCatalogMockServices struct {
	mock               *CatalogMock
	defaultExpectation *CatalogMockServicesExpectation
	expectations       []*CatalogMockServicesExpectation

	callArgs []*CatalogMockServicesParams
	mutex    sync.RWMutex
}

// CatalogMockServicesExpectation specifies expectation struct of the Catalog.Services
type CatalogMockServicesExpectation struct {
	mock    *CatalogMock
	params  *CatalogMockServicesParams
	results *CatalogMockServicesResults
	Counter uint64
}

// CatalogMockServicesParams contains parameters of the Catalog.Services
type CatalogMockServicesParams struct {
	c1 Ctx
	s1 ServicesQuery
}

// CatalogMockServicesResults contains results of the Catalog.Services
type CatalogMockServicesResults struct {
	m1  map[string][]string
	err error
}

// Expect sets up expected params for Catalog.Services
func (mmServices *mCatalogMockServices) Expect(c1 Ctx, s1 ServicesQuery) *mCatalogMockServices {
	if mmServices.mock.funcServices != nil {
		mmServices.mock.t.Fatalf("CatalogMock.Services mock is already set by Set")
	}

	if mmServices.defaultExpectation == nil {
		mmServices.defaultExpectation = &CatalogMockServicesExpectation{}
	}

	mmServices.defaultExpectation.params = &CatalogMockServicesParams{c1, s1}
	for _, e := range mmServices.expectations {
		if minimock.Equal(e.params, mmServices.defaultExpectation.params) {
			mmServices.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmServices.defaultExpectation.params)
		}
	}

	return mmServices
}

// Inspect accepts an inspector function that has same arguments as the Catalog.Services
func (mmServices *mCatalogMockServices) Inspect(f func(c1 Ctx, s1 ServicesQuery)) *mCatalogMockServices {
	if mmServices.mock.inspectFuncServices != nil {
		mmServices.mock.t.Fatalf("Inspect function is already set for CatalogMock.Services")
	}

	mmServices.mock.inspectFuncServices = f

	return mmServices
}

// Return sets up results that will be returned by Catalog.Services
func (mmServices *mCatalogMockServices) Return(m1 map[string][]string, err error) *CatalogMock {
	if mmServices.mock.funcServices != nil {
		mmServices.mock.t.Fatalf("CatalogMock.Services mock is already set by Set")
	}

	if mmServices.defaultExpectation == nil {
		mmServices.defaultExpectation = &CatalogMockServicesExpectation{mock: mmServices.mock}
	}
	mmServices.defaultExpectation.results = &CatalogMockServicesResults{m1, err}
	return mmServices.mock
}

//Set uses given function f to mock the Catalog.Services method
func (mmServices *mCatalogMockServices) Set(f func(c1 Ctx, s1 ServicesQuery) (m1 map[string][]string, err error)) *CatalogMock {
	if mmServices.defaultExpectation != nil {
		mmServices.mock.t.Fatalf("Default expectation is already set for the Catalog.Services method")
	}

	if len(mmServices.expectations) > 0 {
		mmServices.mock.t.Fatalf("Some expectations are already set for the Catalog.Services method")
	}

	mmServices.mock.funcServices = f
	return mmServices.mock
}

// When sets expectation for the Catalog.Services which will trigger the result defined by the following
// Then helper
func (mmServices *mCatalogMockServices) When(c1 Ctx, s1 ServicesQuery) *CatalogMockServicesExpectation {
	if mmServices.mock.funcServices != nil {
		mmServices.mock.t.Fatalf("CatalogMock.Services mock is already set by Set")
	}

	expectation := &CatalogMockServicesExpectation{
		mock:   mmServices.mock,
		params: &CatalogMockServicesParams{c1, s1},
	}
	mmServices.expectations = append(mmServices.expectations, expectation)
	return expectation
}

// Then sets up Catalog.Services return parameters for the expectation previously defined by the When method
func (e *CatalogMockServicesExpectation) Then(m1 map[string][]string, err error) *CatalogMock {
	e.results = &CatalogMockServicesResults{m1, err}
	return e.mock
}

// Services implements Catalog
func (mmServices *CatalogMock) Services(c1 Ctx, s1 ServicesQuery) (m1 map[string][]string, err error) {
	mm_atomic.AddUint64(&mmServices.beforeServicesCounter, 1)
	defer mm_atomic.AddUint64(&mmServices.afterServicesCounter, 1)

	if mmServices.inspectFuncServices != nil {
		mmServices.inspectFuncServices(c1, s1)
	}

	mm_params := &CatalogMockServicesParams{c1, s1}

	// Record call args
	mmServices.ServicesMock.mutex.Lock()
	mmServices.ServicesMock.callArgs = append(mmServices.ServicesMock.callArgs, mm_params)
	mmServices.ServicesMock.mutex.Unlock()

	for _, e := range mmServices.ServicesMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmServices.ServicesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmServices.ServicesMock.defaultExpectation.Counter, 1)
		mm_want := mmServices.ServicesMock.defaultExpectation.params
		mm_got := CatalogMockServicesParams{c1, s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmServices.t.Errorf("CatalogMock.Services got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmServices.ServicesMock.defaultExpectation.results
		if mm_results == nil {
			mmServices.t.Fatal("No results are set for the CatalogMock.Services")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmServices.funcServices != nil {
		return mmServices.funcServices(c1, s1)
	}
	mmServices.t.Fatalf("Unexpected call to CatalogMock.Services. %v %v", c1, s1)
	return
}

// ServicesAfterCounter returns a count of finished CatalogMock.Services invocations
func (mmServices *CatalogMock) ServicesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmServices.afterServicesCounter)
}

// ServicesBeforeCounter returns a count of CatalogMock.Services invocations
func (mmServices *CatalogMock) ServicesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmServices.beforeServicesCounter)
}

// Calls returns a list of arguments used in each call to CatalogMock.Services.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmServices *mCatalogMockServices) Calls() []*CatalogMockServicesParams {
	mmServices.mutex.RLock()

	argCopy := make([]*CatalogMockServicesParams, len(mmServices.callArgs))
	copy(argCopy, mmServices.callArgs)

	mmServices.mutex.RUnlock()

	return argCopy
}

// MinimockServicesDone returns true if the count of the Services invocations corresponds
// the number of defined expectations
func (m *CatalogMock) MinimockServicesDone() bool {
	for _, e := range m.ServicesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ServicesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterServicesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcServices != nil && mm_atomic.LoadUint64(&m.afterServicesCounter) < 1 {
		return false
	}
	return true
}

// MinimockServicesInspect logs each unmet expectation
func (m *CatalogMock) MinimockServicesInspect() {
	for _, e := range m.ServicesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CatalogMock.Services with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ServicesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterServicesCounter) < 1 {
		if m.ServicesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CatalogMock.Services")
		} else {
			m.t.Errorf("Expected call to CatalogMock.Services with params: %#v", *m.ServicesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcServices != nil && mm_atomic.LoadUint64(&m.afterServicesCounter) < 1 {
		m.t.Error("Expected call to CatalogMock.Services")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CatalogMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockConnectInspect()

		m.MinimockDataCentersInspect()

		m.MinimockNodeInspect()

		m.MinimockNodesInspect()

		m.MinimockServiceInspect()

		m.MinimockServicesInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CatalogMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CatalogMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockConnectDone() &&
		m.MinimockDataCentersDone() &&
		m.MinimockNodeDone() &&
		m.MinimockNodesDone() &&
		m.MinimockServiceDone() &&
		m.MinimockServicesDone()
}
