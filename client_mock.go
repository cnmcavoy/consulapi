package consulapi

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock"
)

// ClientMock implements Client
type ClientMock struct {
	t minimock.Tester

	funcCreateSession          func(dc string, config SessionConfig) (s1 SessionID, err error)
	afterCreateSessionCounter  uint64
	beforeCreateSessionCounter uint64
	CreateSessionMock          mClientMockCreateSession

	funcDatacenters          func() (sa1 []string, err error)
	afterDatacentersCounter  uint64
	beforeDatacentersCounter uint64
	DatacentersMock          mClientMockDatacenters

	funcDelete          func(dc string, path string) (err error)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mClientMockDelete

	funcDeleteSession          func(dc string, id SessionID) (err error)
	afterDeleteSessionCounter  uint64
	beforeDeleteSessionCounter uint64
	DeleteSessionMock          mClientMockDeleteSession

	funcGet          func(dc string, path string) (s1 string, err error)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mClientMockGet

	funcKeys          func(dc string, path string) (sa1 []string, err error)
	afterKeysCounter  uint64
	beforeKeysCounter uint64
	KeysMock          mClientMockKeys

	funcListSessions          func(dc string, node string) (m1 map[SessionID]SessionConfig, err error)
	afterListSessionsCounter  uint64
	beforeListSessionsCounter uint64
	ListSessionsMock          mClientMockListSessions

	funcMaintenanceMode          func(enabled bool, reason string) (err error)
	afterMaintenanceModeCounter  uint64
	beforeMaintenanceModeCounter uint64
	MaintenanceModeMock          mClientMockMaintenanceMode

	funcMembers          func(wan bool) (aa1 []AgentInfo, err error)
	afterMembersCounter  uint64
	beforeMembersCounter uint64
	MembersMock          mClientMockMembers

	funcNode          func(dc string, name string) (n1 NodeInfo, err error)
	afterNodeCounter  uint64
	beforeNodeCounter uint64
	NodeMock          mClientMockNode

	funcNodes          func(dc string) (na1 []Node, err error)
	afterNodesCounter  uint64
	beforeNodesCounter uint64
	NodesMock          mClientMockNodes

	funcParticipate          func(l1 LeadershipConfig, a1 AsLeaderFunc) (l2 LeaderSession, err error)
	afterParticipateCounter  uint64
	beforeParticipateCounter uint64
	ParticipateMock          mClientMockParticipate

	funcPut          func(dc string, path string, value string) (err error)
	afterPutCounter  uint64
	beforePutCounter uint64
	PutMock          mClientMockPut

	funcReadSession          func(dc string, id SessionID) (s1 SessionConfig, err error)
	afterReadSessionCounter  uint64
	beforeReadSessionCounter uint64
	ReadSessionMock          mClientMockReadSession

	funcRecurse          func(dc string, path string) (saa1 [][2]string, err error)
	afterRecurseCounter  uint64
	beforeRecurseCounter uint64
	RecurseMock          mClientMockRecurse

	funcReload          func() (err error)
	afterReloadCounter  uint64
	beforeReloadCounter uint64
	ReloadMock          mClientMockReload

	funcRenewSession          func(dc string, id SessionID) (d1 time.Duration, err error)
	afterRenewSessionCounter  uint64
	beforeRenewSessionCounter uint64
	RenewSessionMock          mClientMockRenewSession

	funcSelf          func() (a1 AgentInfo, err error)
	afterSelfCounter  uint64
	beforeSelfCounter uint64
	SelfMock          mClientMockSelf

	funcService          func(dc string, service string, tags ...string) (sa1 []Service, err error)
	afterServiceCounter  uint64
	beforeServiceCounter uint64
	ServiceMock          mClientMockService

	funcServices          func(dc string) (m1 map[string][]string, err error)
	afterServicesCounter  uint64
	beforeServicesCounter uint64
	ServicesMock          mClientMockServices
}

// NewClientMock returns a mock for Client
func NewClientMock(t minimock.Tester) *ClientMock {
	m := &ClientMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateSessionMock = mClientMockCreateSession{mock: m}
	m.CreateSessionMock.callArgs = []*ClientMockCreateSessionParams{}

	m.DatacentersMock = mClientMockDatacenters{mock: m}

	m.DeleteMock = mClientMockDelete{mock: m}
	m.DeleteMock.callArgs = []*ClientMockDeleteParams{}

	m.DeleteSessionMock = mClientMockDeleteSession{mock: m}
	m.DeleteSessionMock.callArgs = []*ClientMockDeleteSessionParams{}

	m.GetMock = mClientMockGet{mock: m}
	m.GetMock.callArgs = []*ClientMockGetParams{}

	m.KeysMock = mClientMockKeys{mock: m}
	m.KeysMock.callArgs = []*ClientMockKeysParams{}

	m.ListSessionsMock = mClientMockListSessions{mock: m}
	m.ListSessionsMock.callArgs = []*ClientMockListSessionsParams{}

	m.MaintenanceModeMock = mClientMockMaintenanceMode{mock: m}
	m.MaintenanceModeMock.callArgs = []*ClientMockMaintenanceModeParams{}

	m.MembersMock = mClientMockMembers{mock: m}
	m.MembersMock.callArgs = []*ClientMockMembersParams{}

	m.NodeMock = mClientMockNode{mock: m}
	m.NodeMock.callArgs = []*ClientMockNodeParams{}

	m.NodesMock = mClientMockNodes{mock: m}
	m.NodesMock.callArgs = []*ClientMockNodesParams{}

	m.ParticipateMock = mClientMockParticipate{mock: m}
	m.ParticipateMock.callArgs = []*ClientMockParticipateParams{}

	m.PutMock = mClientMockPut{mock: m}
	m.PutMock.callArgs = []*ClientMockPutParams{}

	m.ReadSessionMock = mClientMockReadSession{mock: m}
	m.ReadSessionMock.callArgs = []*ClientMockReadSessionParams{}

	m.RecurseMock = mClientMockRecurse{mock: m}
	m.RecurseMock.callArgs = []*ClientMockRecurseParams{}

	m.ReloadMock = mClientMockReload{mock: m}

	m.RenewSessionMock = mClientMockRenewSession{mock: m}
	m.RenewSessionMock.callArgs = []*ClientMockRenewSessionParams{}

	m.SelfMock = mClientMockSelf{mock: m}

	m.ServiceMock = mClientMockService{mock: m}
	m.ServiceMock.callArgs = []*ClientMockServiceParams{}

	m.ServicesMock = mClientMockServices{mock: m}
	m.ServicesMock.callArgs = []*ClientMockServicesParams{}

	return m
}

type mClientMockCreateSession struct {
	mock               *ClientMock
	defaultExpectation *ClientMockCreateSessionExpectation
	expectations       []*ClientMockCreateSessionExpectation

	callArgs []*ClientMockCreateSessionParams
	mutex    sync.RWMutex
}

// ClientMockCreateSessionExpectation specifies expectation struct of the Client.CreateSession
type ClientMockCreateSessionExpectation struct {
	mock    *ClientMock
	params  *ClientMockCreateSessionParams
	results *ClientMockCreateSessionResults
	Counter uint64
}

// ClientMockCreateSessionParams contains parameters of the Client.CreateSession
type ClientMockCreateSessionParams struct {
	dc     string
	config SessionConfig
}

// ClientMockCreateSessionResults contains results of the Client.CreateSession
type ClientMockCreateSessionResults struct {
	s1  SessionID
	err error
}

// Expect sets up expected params for Client.CreateSession
func (mmCreateSession *mClientMockCreateSession) Expect(dc string, config SessionConfig) *mClientMockCreateSession {
	if mmCreateSession.mock.funcCreateSession != nil {
		mmCreateSession.mock.t.Fatalf("ClientMock.CreateSession mock is already set by Set")
	}

	if mmCreateSession.defaultExpectation == nil {
		mmCreateSession.defaultExpectation = &ClientMockCreateSessionExpectation{}
	}

	mmCreateSession.defaultExpectation.params = &ClientMockCreateSessionParams{dc, config}
	for _, e := range mmCreateSession.expectations {
		if minimock.Equal(e.params, mmCreateSession.defaultExpectation.params) {
			mmCreateSession.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateSession.defaultExpectation.params)
		}
	}

	return mmCreateSession
}

// Return sets up results that will be returned by Client.CreateSession
func (mmCreateSession *mClientMockCreateSession) Return(s1 SessionID, err error) *ClientMock {
	if mmCreateSession.mock.funcCreateSession != nil {
		mmCreateSession.mock.t.Fatalf("ClientMock.CreateSession mock is already set by Set")
	}

	if mmCreateSession.defaultExpectation == nil {
		mmCreateSession.defaultExpectation = &ClientMockCreateSessionExpectation{mock: mmCreateSession.mock}
	}
	mmCreateSession.defaultExpectation.results = &ClientMockCreateSessionResults{s1, err}
	return mmCreateSession.mock
}

//Set uses given function f to mock the Client.CreateSession method
func (mmCreateSession *mClientMockCreateSession) Set(f func(dc string, config SessionConfig) (s1 SessionID, err error)) *ClientMock {
	if mmCreateSession.defaultExpectation != nil {
		mmCreateSession.mock.t.Fatalf("Default expectation is already set for the Client.CreateSession method")
	}

	if len(mmCreateSession.expectations) > 0 {
		mmCreateSession.mock.t.Fatalf("Some expectations are already set for the Client.CreateSession method")
	}

	mmCreateSession.mock.funcCreateSession = f
	return mmCreateSession.mock
}

// When sets expectation for the Client.CreateSession which will trigger the result defined by the following
// Then helper
func (mmCreateSession *mClientMockCreateSession) When(dc string, config SessionConfig) *ClientMockCreateSessionExpectation {
	if mmCreateSession.mock.funcCreateSession != nil {
		mmCreateSession.mock.t.Fatalf("ClientMock.CreateSession mock is already set by Set")
	}

	expectation := &ClientMockCreateSessionExpectation{
		mock:   mmCreateSession.mock,
		params: &ClientMockCreateSessionParams{dc, config},
	}
	mmCreateSession.expectations = append(mmCreateSession.expectations, expectation)
	return expectation
}

// Then sets up Client.CreateSession return parameters for the expectation previously defined by the When method
func (e *ClientMockCreateSessionExpectation) Then(s1 SessionID, err error) *ClientMock {
	e.results = &ClientMockCreateSessionResults{s1, err}
	return e.mock
}

// CreateSession implements Client
func (mmCreateSession *ClientMock) CreateSession(dc string, config SessionConfig) (s1 SessionID, err error) {
	mm_atomic.AddUint64(&mmCreateSession.beforeCreateSessionCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateSession.afterCreateSessionCounter, 1)

	params := &ClientMockCreateSessionParams{dc, config}

	// Record call args
	mmCreateSession.CreateSessionMock.mutex.Lock()
	mmCreateSession.CreateSessionMock.callArgs = append(mmCreateSession.CreateSessionMock.callArgs, params)
	mmCreateSession.CreateSessionMock.mutex.Unlock()

	for _, e := range mmCreateSession.CreateSessionMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmCreateSession.CreateSessionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateSession.CreateSessionMock.defaultExpectation.Counter, 1)
		want := mmCreateSession.CreateSessionMock.defaultExpectation.params
		got := ClientMockCreateSessionParams{dc, config}
		if want != nil && !minimock.Equal(*want, got) {
			mmCreateSession.t.Errorf("ClientMock.CreateSession got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmCreateSession.CreateSessionMock.defaultExpectation.results
		if results == nil {
			mmCreateSession.t.Fatal("No results are set for the ClientMock.CreateSession")
		}
		return (*results).s1, (*results).err
	}
	if mmCreateSession.funcCreateSession != nil {
		return mmCreateSession.funcCreateSession(dc, config)
	}
	mmCreateSession.t.Fatalf("Unexpected call to ClientMock.CreateSession. %v %v", dc, config)
	return
}

// CreateSessionAfterCounter returns a count of finished ClientMock.CreateSession invocations
func (mmCreateSession *ClientMock) CreateSessionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateSession.afterCreateSessionCounter)
}

// CreateSessionBeforeCounter returns a count of ClientMock.CreateSession invocations
func (mmCreateSession *ClientMock) CreateSessionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateSession.beforeCreateSessionCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.CreateSession.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateSession *mClientMockCreateSession) Calls() []*ClientMockCreateSessionParams {
	mmCreateSession.mutex.RLock()

	argCopy := make([]*ClientMockCreateSessionParams, len(mmCreateSession.callArgs))
	copy(argCopy, mmCreateSession.callArgs)

	mmCreateSession.mutex.RUnlock()

	return argCopy
}

// MinimockCreateSessionDone returns true if the count of the CreateSession invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockCreateSessionDone() bool {
	for _, e := range m.CreateSessionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateSessionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateSessionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateSession != nil && mm_atomic.LoadUint64(&m.afterCreateSessionCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateSessionInspect logs each unmet expectation
func (m *ClientMock) MinimockCreateSessionInspect() {
	for _, e := range m.CreateSessionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.CreateSession with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateSessionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateSessionCounter) < 1 {
		if m.CreateSessionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.CreateSession")
		} else {
			m.t.Errorf("Expected call to ClientMock.CreateSession with params: %#v", *m.CreateSessionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateSession != nil && mm_atomic.LoadUint64(&m.afterCreateSessionCounter) < 1 {
		m.t.Error("Expected call to ClientMock.CreateSession")
	}
}

type mClientMockDatacenters struct {
	mock               *ClientMock
	defaultExpectation *ClientMockDatacentersExpectation
	expectations       []*ClientMockDatacentersExpectation
}

// ClientMockDatacentersExpectation specifies expectation struct of the Client.Datacenters
type ClientMockDatacentersExpectation struct {
	mock *ClientMock

	results *ClientMockDatacentersResults
	Counter uint64
}

// ClientMockDatacentersResults contains results of the Client.Datacenters
type ClientMockDatacentersResults struct {
	sa1 []string
	err error
}

// Expect sets up expected params for Client.Datacenters
func (mmDatacenters *mClientMockDatacenters) Expect() *mClientMockDatacenters {
	if mmDatacenters.mock.funcDatacenters != nil {
		mmDatacenters.mock.t.Fatalf("ClientMock.Datacenters mock is already set by Set")
	}

	if mmDatacenters.defaultExpectation == nil {
		mmDatacenters.defaultExpectation = &ClientMockDatacentersExpectation{}
	}

	return mmDatacenters
}

// Return sets up results that will be returned by Client.Datacenters
func (mmDatacenters *mClientMockDatacenters) Return(sa1 []string, err error) *ClientMock {
	if mmDatacenters.mock.funcDatacenters != nil {
		mmDatacenters.mock.t.Fatalf("ClientMock.Datacenters mock is already set by Set")
	}

	if mmDatacenters.defaultExpectation == nil {
		mmDatacenters.defaultExpectation = &ClientMockDatacentersExpectation{mock: mmDatacenters.mock}
	}
	mmDatacenters.defaultExpectation.results = &ClientMockDatacentersResults{sa1, err}
	return mmDatacenters.mock
}

//Set uses given function f to mock the Client.Datacenters method
func (mmDatacenters *mClientMockDatacenters) Set(f func() (sa1 []string, err error)) *ClientMock {
	if mmDatacenters.defaultExpectation != nil {
		mmDatacenters.mock.t.Fatalf("Default expectation is already set for the Client.Datacenters method")
	}

	if len(mmDatacenters.expectations) > 0 {
		mmDatacenters.mock.t.Fatalf("Some expectations are already set for the Client.Datacenters method")
	}

	mmDatacenters.mock.funcDatacenters = f
	return mmDatacenters.mock
}

// Datacenters implements Client
func (mmDatacenters *ClientMock) Datacenters() (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmDatacenters.beforeDatacentersCounter, 1)
	defer mm_atomic.AddUint64(&mmDatacenters.afterDatacentersCounter, 1)

	if mmDatacenters.DatacentersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDatacenters.DatacentersMock.defaultExpectation.Counter, 1)

		results := mmDatacenters.DatacentersMock.defaultExpectation.results
		if results == nil {
			mmDatacenters.t.Fatal("No results are set for the ClientMock.Datacenters")
		}
		return (*results).sa1, (*results).err
	}
	if mmDatacenters.funcDatacenters != nil {
		return mmDatacenters.funcDatacenters()
	}
	mmDatacenters.t.Fatalf("Unexpected call to ClientMock.Datacenters.")
	return
}

// DatacentersAfterCounter returns a count of finished ClientMock.Datacenters invocations
func (mmDatacenters *ClientMock) DatacentersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDatacenters.afterDatacentersCounter)
}

// DatacentersBeforeCounter returns a count of ClientMock.Datacenters invocations
func (mmDatacenters *ClientMock) DatacentersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDatacenters.beforeDatacentersCounter)
}

// MinimockDatacentersDone returns true if the count of the Datacenters invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDatacentersDone() bool {
	for _, e := range m.DatacentersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DatacentersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDatacentersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDatacenters != nil && mm_atomic.LoadUint64(&m.afterDatacentersCounter) < 1 {
		return false
	}
	return true
}

// MinimockDatacentersInspect logs each unmet expectation
func (m *ClientMock) MinimockDatacentersInspect() {
	for _, e := range m.DatacentersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ClientMock.Datacenters")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DatacentersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDatacentersCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Datacenters")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDatacenters != nil && mm_atomic.LoadUint64(&m.afterDatacentersCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Datacenters")
	}
}

type mClientMockDelete struct {
	mock               *ClientMock
	defaultExpectation *ClientMockDeleteExpectation
	expectations       []*ClientMockDeleteExpectation

	callArgs []*ClientMockDeleteParams
	mutex    sync.RWMutex
}

// ClientMockDeleteExpectation specifies expectation struct of the Client.Delete
type ClientMockDeleteExpectation struct {
	mock    *ClientMock
	params  *ClientMockDeleteParams
	results *ClientMockDeleteResults
	Counter uint64
}

// ClientMockDeleteParams contains parameters of the Client.Delete
type ClientMockDeleteParams struct {
	dc   string
	path string
}

// ClientMockDeleteResults contains results of the Client.Delete
type ClientMockDeleteResults struct {
	err error
}

// Expect sets up expected params for Client.Delete
func (mmDelete *mClientMockDelete) Expect(dc string, path string) *mClientMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ClientMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ClientMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &ClientMockDeleteParams{dc, path}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Return sets up results that will be returned by Client.Delete
func (mmDelete *mClientMockDelete) Return(err error) *ClientMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ClientMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ClientMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &ClientMockDeleteResults{err}
	return mmDelete.mock
}

//Set uses given function f to mock the Client.Delete method
func (mmDelete *mClientMockDelete) Set(f func(dc string, path string) (err error)) *ClientMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the Client.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the Client.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the Client.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mClientMockDelete) When(dc string, path string) *ClientMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ClientMock.Delete mock is already set by Set")
	}

	expectation := &ClientMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &ClientMockDeleteParams{dc, path},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up Client.Delete return parameters for the expectation previously defined by the When method
func (e *ClientMockDeleteExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockDeleteResults{err}
	return e.mock
}

// Delete implements Client
func (mmDelete *ClientMock) Delete(dc string, path string) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	params := &ClientMockDeleteParams{dc, path}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		want := mmDelete.DeleteMock.defaultExpectation.params
		got := ClientMockDeleteParams{dc, path}
		if want != nil && !minimock.Equal(*want, got) {
			mmDelete.t.Errorf("ClientMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmDelete.DeleteMock.defaultExpectation.results
		if results == nil {
			mmDelete.t.Fatal("No results are set for the ClientMock.Delete")
		}
		return (*results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(dc, path)
	}
	mmDelete.t.Fatalf("Unexpected call to ClientMock.Delete. %v %v", dc, path)
	return
}

// DeleteAfterCounter returns a count of finished ClientMock.Delete invocations
func (mmDelete *ClientMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of ClientMock.Delete invocations
func (mmDelete *ClientMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mClientMockDelete) Calls() []*ClientMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*ClientMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *ClientMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Delete")
		} else {
			m.t.Errorf("Expected call to ClientMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Delete")
	}
}

type mClientMockDeleteSession struct {
	mock               *ClientMock
	defaultExpectation *ClientMockDeleteSessionExpectation
	expectations       []*ClientMockDeleteSessionExpectation

	callArgs []*ClientMockDeleteSessionParams
	mutex    sync.RWMutex
}

// ClientMockDeleteSessionExpectation specifies expectation struct of the Client.DeleteSession
type ClientMockDeleteSessionExpectation struct {
	mock    *ClientMock
	params  *ClientMockDeleteSessionParams
	results *ClientMockDeleteSessionResults
	Counter uint64
}

// ClientMockDeleteSessionParams contains parameters of the Client.DeleteSession
type ClientMockDeleteSessionParams struct {
	dc string
	id SessionID
}

// ClientMockDeleteSessionResults contains results of the Client.DeleteSession
type ClientMockDeleteSessionResults struct {
	err error
}

// Expect sets up expected params for Client.DeleteSession
func (mmDeleteSession *mClientMockDeleteSession) Expect(dc string, id SessionID) *mClientMockDeleteSession {
	if mmDeleteSession.mock.funcDeleteSession != nil {
		mmDeleteSession.mock.t.Fatalf("ClientMock.DeleteSession mock is already set by Set")
	}

	if mmDeleteSession.defaultExpectation == nil {
		mmDeleteSession.defaultExpectation = &ClientMockDeleteSessionExpectation{}
	}

	mmDeleteSession.defaultExpectation.params = &ClientMockDeleteSessionParams{dc, id}
	for _, e := range mmDeleteSession.expectations {
		if minimock.Equal(e.params, mmDeleteSession.defaultExpectation.params) {
			mmDeleteSession.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteSession.defaultExpectation.params)
		}
	}

	return mmDeleteSession
}

// Return sets up results that will be returned by Client.DeleteSession
func (mmDeleteSession *mClientMockDeleteSession) Return(err error) *ClientMock {
	if mmDeleteSession.mock.funcDeleteSession != nil {
		mmDeleteSession.mock.t.Fatalf("ClientMock.DeleteSession mock is already set by Set")
	}

	if mmDeleteSession.defaultExpectation == nil {
		mmDeleteSession.defaultExpectation = &ClientMockDeleteSessionExpectation{mock: mmDeleteSession.mock}
	}
	mmDeleteSession.defaultExpectation.results = &ClientMockDeleteSessionResults{err}
	return mmDeleteSession.mock
}

//Set uses given function f to mock the Client.DeleteSession method
func (mmDeleteSession *mClientMockDeleteSession) Set(f func(dc string, id SessionID) (err error)) *ClientMock {
	if mmDeleteSession.defaultExpectation != nil {
		mmDeleteSession.mock.t.Fatalf("Default expectation is already set for the Client.DeleteSession method")
	}

	if len(mmDeleteSession.expectations) > 0 {
		mmDeleteSession.mock.t.Fatalf("Some expectations are already set for the Client.DeleteSession method")
	}

	mmDeleteSession.mock.funcDeleteSession = f
	return mmDeleteSession.mock
}

// When sets expectation for the Client.DeleteSession which will trigger the result defined by the following
// Then helper
func (mmDeleteSession *mClientMockDeleteSession) When(dc string, id SessionID) *ClientMockDeleteSessionExpectation {
	if mmDeleteSession.mock.funcDeleteSession != nil {
		mmDeleteSession.mock.t.Fatalf("ClientMock.DeleteSession mock is already set by Set")
	}

	expectation := &ClientMockDeleteSessionExpectation{
		mock:   mmDeleteSession.mock,
		params: &ClientMockDeleteSessionParams{dc, id},
	}
	mmDeleteSession.expectations = append(mmDeleteSession.expectations, expectation)
	return expectation
}

// Then sets up Client.DeleteSession return parameters for the expectation previously defined by the When method
func (e *ClientMockDeleteSessionExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockDeleteSessionResults{err}
	return e.mock
}

// DeleteSession implements Client
func (mmDeleteSession *ClientMock) DeleteSession(dc string, id SessionID) (err error) {
	mm_atomic.AddUint64(&mmDeleteSession.beforeDeleteSessionCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteSession.afterDeleteSessionCounter, 1)

	params := &ClientMockDeleteSessionParams{dc, id}

	// Record call args
	mmDeleteSession.DeleteSessionMock.mutex.Lock()
	mmDeleteSession.DeleteSessionMock.callArgs = append(mmDeleteSession.DeleteSessionMock.callArgs, params)
	mmDeleteSession.DeleteSessionMock.mutex.Unlock()

	for _, e := range mmDeleteSession.DeleteSessionMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteSession.DeleteSessionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteSession.DeleteSessionMock.defaultExpectation.Counter, 1)
		want := mmDeleteSession.DeleteSessionMock.defaultExpectation.params
		got := ClientMockDeleteSessionParams{dc, id}
		if want != nil && !minimock.Equal(*want, got) {
			mmDeleteSession.t.Errorf("ClientMock.DeleteSession got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmDeleteSession.DeleteSessionMock.defaultExpectation.results
		if results == nil {
			mmDeleteSession.t.Fatal("No results are set for the ClientMock.DeleteSession")
		}
		return (*results).err
	}
	if mmDeleteSession.funcDeleteSession != nil {
		return mmDeleteSession.funcDeleteSession(dc, id)
	}
	mmDeleteSession.t.Fatalf("Unexpected call to ClientMock.DeleteSession. %v %v", dc, id)
	return
}

// DeleteSessionAfterCounter returns a count of finished ClientMock.DeleteSession invocations
func (mmDeleteSession *ClientMock) DeleteSessionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSession.afterDeleteSessionCounter)
}

// DeleteSessionBeforeCounter returns a count of ClientMock.DeleteSession invocations
func (mmDeleteSession *ClientMock) DeleteSessionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSession.beforeDeleteSessionCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.DeleteSession.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteSession *mClientMockDeleteSession) Calls() []*ClientMockDeleteSessionParams {
	mmDeleteSession.mutex.RLock()

	argCopy := make([]*ClientMockDeleteSessionParams, len(mmDeleteSession.callArgs))
	copy(argCopy, mmDeleteSession.callArgs)

	mmDeleteSession.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteSessionDone returns true if the count of the DeleteSession invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDeleteSessionDone() bool {
	for _, e := range m.DeleteSessionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSessionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteSessionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSession != nil && mm_atomic.LoadUint64(&m.afterDeleteSessionCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteSessionInspect logs each unmet expectation
func (m *ClientMock) MinimockDeleteSessionInspect() {
	for _, e := range m.DeleteSessionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.DeleteSession with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSessionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteSessionCounter) < 1 {
		if m.DeleteSessionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.DeleteSession")
		} else {
			m.t.Errorf("Expected call to ClientMock.DeleteSession with params: %#v", *m.DeleteSessionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSession != nil && mm_atomic.LoadUint64(&m.afterDeleteSessionCounter) < 1 {
		m.t.Error("Expected call to ClientMock.DeleteSession")
	}
}

type mClientMockGet struct {
	mock               *ClientMock
	defaultExpectation *ClientMockGetExpectation
	expectations       []*ClientMockGetExpectation

	callArgs []*ClientMockGetParams
	mutex    sync.RWMutex
}

// ClientMockGetExpectation specifies expectation struct of the Client.Get
type ClientMockGetExpectation struct {
	mock    *ClientMock
	params  *ClientMockGetParams
	results *ClientMockGetResults
	Counter uint64
}

// ClientMockGetParams contains parameters of the Client.Get
type ClientMockGetParams struct {
	dc   string
	path string
}

// ClientMockGetResults contains results of the Client.Get
type ClientMockGetResults struct {
	s1  string
	err error
}

// Expect sets up expected params for Client.Get
func (mmGet *mClientMockGet) Expect(dc string, path string) *mClientMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ClientMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &ClientMockGetExpectation{}
	}

	mmGet.defaultExpectation.params = &ClientMockGetParams{dc, path}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// Return sets up results that will be returned by Client.Get
func (mmGet *mClientMockGet) Return(s1 string, err error) *ClientMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ClientMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &ClientMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &ClientMockGetResults{s1, err}
	return mmGet.mock
}

//Set uses given function f to mock the Client.Get method
func (mmGet *mClientMockGet) Set(f func(dc string, path string) (s1 string, err error)) *ClientMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the Client.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the Client.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the Client.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mClientMockGet) When(dc string, path string) *ClientMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ClientMock.Get mock is already set by Set")
	}

	expectation := &ClientMockGetExpectation{
		mock:   mmGet.mock,
		params: &ClientMockGetParams{dc, path},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up Client.Get return parameters for the expectation previously defined by the When method
func (e *ClientMockGetExpectation) Then(s1 string, err error) *ClientMock {
	e.results = &ClientMockGetResults{s1, err}
	return e.mock
}

// Get implements Client
func (mmGet *ClientMock) Get(dc string, path string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	params := &ClientMockGetParams{dc, path}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		want := mmGet.GetMock.defaultExpectation.params
		got := ClientMockGetParams{dc, path}
		if want != nil && !minimock.Equal(*want, got) {
			mmGet.t.Errorf("ClientMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmGet.GetMock.defaultExpectation.results
		if results == nil {
			mmGet.t.Fatal("No results are set for the ClientMock.Get")
		}
		return (*results).s1, (*results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(dc, path)
	}
	mmGet.t.Fatalf("Unexpected call to ClientMock.Get. %v %v", dc, path)
	return
}

// GetAfterCounter returns a count of finished ClientMock.Get invocations
func (mmGet *ClientMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of ClientMock.Get invocations
func (mmGet *ClientMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mClientMockGet) Calls() []*ClientMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*ClientMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *ClientMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Get")
		} else {
			m.t.Errorf("Expected call to ClientMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Get")
	}
}

type mClientMockKeys struct {
	mock               *ClientMock
	defaultExpectation *ClientMockKeysExpectation
	expectations       []*ClientMockKeysExpectation

	callArgs []*ClientMockKeysParams
	mutex    sync.RWMutex
}

// ClientMockKeysExpectation specifies expectation struct of the Client.Keys
type ClientMockKeysExpectation struct {
	mock    *ClientMock
	params  *ClientMockKeysParams
	results *ClientMockKeysResults
	Counter uint64
}

// ClientMockKeysParams contains parameters of the Client.Keys
type ClientMockKeysParams struct {
	dc   string
	path string
}

// ClientMockKeysResults contains results of the Client.Keys
type ClientMockKeysResults struct {
	sa1 []string
	err error
}

// Expect sets up expected params for Client.Keys
func (mmKeys *mClientMockKeys) Expect(dc string, path string) *mClientMockKeys {
	if mmKeys.mock.funcKeys != nil {
		mmKeys.mock.t.Fatalf("ClientMock.Keys mock is already set by Set")
	}

	if mmKeys.defaultExpectation == nil {
		mmKeys.defaultExpectation = &ClientMockKeysExpectation{}
	}

	mmKeys.defaultExpectation.params = &ClientMockKeysParams{dc, path}
	for _, e := range mmKeys.expectations {
		if minimock.Equal(e.params, mmKeys.defaultExpectation.params) {
			mmKeys.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmKeys.defaultExpectation.params)
		}
	}

	return mmKeys
}

// Return sets up results that will be returned by Client.Keys
func (mmKeys *mClientMockKeys) Return(sa1 []string, err error) *ClientMock {
	if mmKeys.mock.funcKeys != nil {
		mmKeys.mock.t.Fatalf("ClientMock.Keys mock is already set by Set")
	}

	if mmKeys.defaultExpectation == nil {
		mmKeys.defaultExpectation = &ClientMockKeysExpectation{mock: mmKeys.mock}
	}
	mmKeys.defaultExpectation.results = &ClientMockKeysResults{sa1, err}
	return mmKeys.mock
}

//Set uses given function f to mock the Client.Keys method
func (mmKeys *mClientMockKeys) Set(f func(dc string, path string) (sa1 []string, err error)) *ClientMock {
	if mmKeys.defaultExpectation != nil {
		mmKeys.mock.t.Fatalf("Default expectation is already set for the Client.Keys method")
	}

	if len(mmKeys.expectations) > 0 {
		mmKeys.mock.t.Fatalf("Some expectations are already set for the Client.Keys method")
	}

	mmKeys.mock.funcKeys = f
	return mmKeys.mock
}

// When sets expectation for the Client.Keys which will trigger the result defined by the following
// Then helper
func (mmKeys *mClientMockKeys) When(dc string, path string) *ClientMockKeysExpectation {
	if mmKeys.mock.funcKeys != nil {
		mmKeys.mock.t.Fatalf("ClientMock.Keys mock is already set by Set")
	}

	expectation := &ClientMockKeysExpectation{
		mock:   mmKeys.mock,
		params: &ClientMockKeysParams{dc, path},
	}
	mmKeys.expectations = append(mmKeys.expectations, expectation)
	return expectation
}

// Then sets up Client.Keys return parameters for the expectation previously defined by the When method
func (e *ClientMockKeysExpectation) Then(sa1 []string, err error) *ClientMock {
	e.results = &ClientMockKeysResults{sa1, err}
	return e.mock
}

// Keys implements Client
func (mmKeys *ClientMock) Keys(dc string, path string) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmKeys.beforeKeysCounter, 1)
	defer mm_atomic.AddUint64(&mmKeys.afterKeysCounter, 1)

	params := &ClientMockKeysParams{dc, path}

	// Record call args
	mmKeys.KeysMock.mutex.Lock()
	mmKeys.KeysMock.callArgs = append(mmKeys.KeysMock.callArgs, params)
	mmKeys.KeysMock.mutex.Unlock()

	for _, e := range mmKeys.KeysMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmKeys.KeysMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmKeys.KeysMock.defaultExpectation.Counter, 1)
		want := mmKeys.KeysMock.defaultExpectation.params
		got := ClientMockKeysParams{dc, path}
		if want != nil && !minimock.Equal(*want, got) {
			mmKeys.t.Errorf("ClientMock.Keys got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmKeys.KeysMock.defaultExpectation.results
		if results == nil {
			mmKeys.t.Fatal("No results are set for the ClientMock.Keys")
		}
		return (*results).sa1, (*results).err
	}
	if mmKeys.funcKeys != nil {
		return mmKeys.funcKeys(dc, path)
	}
	mmKeys.t.Fatalf("Unexpected call to ClientMock.Keys. %v %v", dc, path)
	return
}

// KeysAfterCounter returns a count of finished ClientMock.Keys invocations
func (mmKeys *ClientMock) KeysAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmKeys.afterKeysCounter)
}

// KeysBeforeCounter returns a count of ClientMock.Keys invocations
func (mmKeys *ClientMock) KeysBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmKeys.beforeKeysCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Keys.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmKeys *mClientMockKeys) Calls() []*ClientMockKeysParams {
	mmKeys.mutex.RLock()

	argCopy := make([]*ClientMockKeysParams, len(mmKeys.callArgs))
	copy(argCopy, mmKeys.callArgs)

	mmKeys.mutex.RUnlock()

	return argCopy
}

// MinimockKeysDone returns true if the count of the Keys invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockKeysDone() bool {
	for _, e := range m.KeysMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.KeysMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterKeysCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcKeys != nil && mm_atomic.LoadUint64(&m.afterKeysCounter) < 1 {
		return false
	}
	return true
}

// MinimockKeysInspect logs each unmet expectation
func (m *ClientMock) MinimockKeysInspect() {
	for _, e := range m.KeysMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Keys with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.KeysMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterKeysCounter) < 1 {
		if m.KeysMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Keys")
		} else {
			m.t.Errorf("Expected call to ClientMock.Keys with params: %#v", *m.KeysMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcKeys != nil && mm_atomic.LoadUint64(&m.afterKeysCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Keys")
	}
}

type mClientMockListSessions struct {
	mock               *ClientMock
	defaultExpectation *ClientMockListSessionsExpectation
	expectations       []*ClientMockListSessionsExpectation

	callArgs []*ClientMockListSessionsParams
	mutex    sync.RWMutex
}

// ClientMockListSessionsExpectation specifies expectation struct of the Client.ListSessions
type ClientMockListSessionsExpectation struct {
	mock    *ClientMock
	params  *ClientMockListSessionsParams
	results *ClientMockListSessionsResults
	Counter uint64
}

// ClientMockListSessionsParams contains parameters of the Client.ListSessions
type ClientMockListSessionsParams struct {
	dc   string
	node string
}

// ClientMockListSessionsResults contains results of the Client.ListSessions
type ClientMockListSessionsResults struct {
	m1  map[SessionID]SessionConfig
	err error
}

// Expect sets up expected params for Client.ListSessions
func (mmListSessions *mClientMockListSessions) Expect(dc string, node string) *mClientMockListSessions {
	if mmListSessions.mock.funcListSessions != nil {
		mmListSessions.mock.t.Fatalf("ClientMock.ListSessions mock is already set by Set")
	}

	if mmListSessions.defaultExpectation == nil {
		mmListSessions.defaultExpectation = &ClientMockListSessionsExpectation{}
	}

	mmListSessions.defaultExpectation.params = &ClientMockListSessionsParams{dc, node}
	for _, e := range mmListSessions.expectations {
		if minimock.Equal(e.params, mmListSessions.defaultExpectation.params) {
			mmListSessions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListSessions.defaultExpectation.params)
		}
	}

	return mmListSessions
}

// Return sets up results that will be returned by Client.ListSessions
func (mmListSessions *mClientMockListSessions) Return(m1 map[SessionID]SessionConfig, err error) *ClientMock {
	if mmListSessions.mock.funcListSessions != nil {
		mmListSessions.mock.t.Fatalf("ClientMock.ListSessions mock is already set by Set")
	}

	if mmListSessions.defaultExpectation == nil {
		mmListSessions.defaultExpectation = &ClientMockListSessionsExpectation{mock: mmListSessions.mock}
	}
	mmListSessions.defaultExpectation.results = &ClientMockListSessionsResults{m1, err}
	return mmListSessions.mock
}

//Set uses given function f to mock the Client.ListSessions method
func (mmListSessions *mClientMockListSessions) Set(f func(dc string, node string) (m1 map[SessionID]SessionConfig, err error)) *ClientMock {
	if mmListSessions.defaultExpectation != nil {
		mmListSessions.mock.t.Fatalf("Default expectation is already set for the Client.ListSessions method")
	}

	if len(mmListSessions.expectations) > 0 {
		mmListSessions.mock.t.Fatalf("Some expectations are already set for the Client.ListSessions method")
	}

	mmListSessions.mock.funcListSessions = f
	return mmListSessions.mock
}

// When sets expectation for the Client.ListSessions which will trigger the result defined by the following
// Then helper
func (mmListSessions *mClientMockListSessions) When(dc string, node string) *ClientMockListSessionsExpectation {
	if mmListSessions.mock.funcListSessions != nil {
		mmListSessions.mock.t.Fatalf("ClientMock.ListSessions mock is already set by Set")
	}

	expectation := &ClientMockListSessionsExpectation{
		mock:   mmListSessions.mock,
		params: &ClientMockListSessionsParams{dc, node},
	}
	mmListSessions.expectations = append(mmListSessions.expectations, expectation)
	return expectation
}

// Then sets up Client.ListSessions return parameters for the expectation previously defined by the When method
func (e *ClientMockListSessionsExpectation) Then(m1 map[SessionID]SessionConfig, err error) *ClientMock {
	e.results = &ClientMockListSessionsResults{m1, err}
	return e.mock
}

// ListSessions implements Client
func (mmListSessions *ClientMock) ListSessions(dc string, node string) (m1 map[SessionID]SessionConfig, err error) {
	mm_atomic.AddUint64(&mmListSessions.beforeListSessionsCounter, 1)
	defer mm_atomic.AddUint64(&mmListSessions.afterListSessionsCounter, 1)

	params := &ClientMockListSessionsParams{dc, node}

	// Record call args
	mmListSessions.ListSessionsMock.mutex.Lock()
	mmListSessions.ListSessionsMock.callArgs = append(mmListSessions.ListSessionsMock.callArgs, params)
	mmListSessions.ListSessionsMock.mutex.Unlock()

	for _, e := range mmListSessions.ListSessionsMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmListSessions.ListSessionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListSessions.ListSessionsMock.defaultExpectation.Counter, 1)
		want := mmListSessions.ListSessionsMock.defaultExpectation.params
		got := ClientMockListSessionsParams{dc, node}
		if want != nil && !minimock.Equal(*want, got) {
			mmListSessions.t.Errorf("ClientMock.ListSessions got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmListSessions.ListSessionsMock.defaultExpectation.results
		if results == nil {
			mmListSessions.t.Fatal("No results are set for the ClientMock.ListSessions")
		}
		return (*results).m1, (*results).err
	}
	if mmListSessions.funcListSessions != nil {
		return mmListSessions.funcListSessions(dc, node)
	}
	mmListSessions.t.Fatalf("Unexpected call to ClientMock.ListSessions. %v %v", dc, node)
	return
}

// ListSessionsAfterCounter returns a count of finished ClientMock.ListSessions invocations
func (mmListSessions *ClientMock) ListSessionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSessions.afterListSessionsCounter)
}

// ListSessionsBeforeCounter returns a count of ClientMock.ListSessions invocations
func (mmListSessions *ClientMock) ListSessionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSessions.beforeListSessionsCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.ListSessions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListSessions *mClientMockListSessions) Calls() []*ClientMockListSessionsParams {
	mmListSessions.mutex.RLock()

	argCopy := make([]*ClientMockListSessionsParams, len(mmListSessions.callArgs))
	copy(argCopy, mmListSessions.callArgs)

	mmListSessions.mutex.RUnlock()

	return argCopy
}

// MinimockListSessionsDone returns true if the count of the ListSessions invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockListSessionsDone() bool {
	for _, e := range m.ListSessionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListSessionsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListSessionsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListSessions != nil && mm_atomic.LoadUint64(&m.afterListSessionsCounter) < 1 {
		return false
	}
	return true
}

// MinimockListSessionsInspect logs each unmet expectation
func (m *ClientMock) MinimockListSessionsInspect() {
	for _, e := range m.ListSessionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.ListSessions with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListSessionsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListSessionsCounter) < 1 {
		if m.ListSessionsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.ListSessions")
		} else {
			m.t.Errorf("Expected call to ClientMock.ListSessions with params: %#v", *m.ListSessionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListSessions != nil && mm_atomic.LoadUint64(&m.afterListSessionsCounter) < 1 {
		m.t.Error("Expected call to ClientMock.ListSessions")
	}
}

type mClientMockMaintenanceMode struct {
	mock               *ClientMock
	defaultExpectation *ClientMockMaintenanceModeExpectation
	expectations       []*ClientMockMaintenanceModeExpectation

	callArgs []*ClientMockMaintenanceModeParams
	mutex    sync.RWMutex
}

// ClientMockMaintenanceModeExpectation specifies expectation struct of the Client.MaintenanceMode
type ClientMockMaintenanceModeExpectation struct {
	mock    *ClientMock
	params  *ClientMockMaintenanceModeParams
	results *ClientMockMaintenanceModeResults
	Counter uint64
}

// ClientMockMaintenanceModeParams contains parameters of the Client.MaintenanceMode
type ClientMockMaintenanceModeParams struct {
	enabled bool
	reason  string
}

// ClientMockMaintenanceModeResults contains results of the Client.MaintenanceMode
type ClientMockMaintenanceModeResults struct {
	err error
}

// Expect sets up expected params for Client.MaintenanceMode
func (mmMaintenanceMode *mClientMockMaintenanceMode) Expect(enabled bool, reason string) *mClientMockMaintenanceMode {
	if mmMaintenanceMode.mock.funcMaintenanceMode != nil {
		mmMaintenanceMode.mock.t.Fatalf("ClientMock.MaintenanceMode mock is already set by Set")
	}

	if mmMaintenanceMode.defaultExpectation == nil {
		mmMaintenanceMode.defaultExpectation = &ClientMockMaintenanceModeExpectation{}
	}

	mmMaintenanceMode.defaultExpectation.params = &ClientMockMaintenanceModeParams{enabled, reason}
	for _, e := range mmMaintenanceMode.expectations {
		if minimock.Equal(e.params, mmMaintenanceMode.defaultExpectation.params) {
			mmMaintenanceMode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMaintenanceMode.defaultExpectation.params)
		}
	}

	return mmMaintenanceMode
}

// Return sets up results that will be returned by Client.MaintenanceMode
func (mmMaintenanceMode *mClientMockMaintenanceMode) Return(err error) *ClientMock {
	if mmMaintenanceMode.mock.funcMaintenanceMode != nil {
		mmMaintenanceMode.mock.t.Fatalf("ClientMock.MaintenanceMode mock is already set by Set")
	}

	if mmMaintenanceMode.defaultExpectation == nil {
		mmMaintenanceMode.defaultExpectation = &ClientMockMaintenanceModeExpectation{mock: mmMaintenanceMode.mock}
	}
	mmMaintenanceMode.defaultExpectation.results = &ClientMockMaintenanceModeResults{err}
	return mmMaintenanceMode.mock
}

//Set uses given function f to mock the Client.MaintenanceMode method
func (mmMaintenanceMode *mClientMockMaintenanceMode) Set(f func(enabled bool, reason string) (err error)) *ClientMock {
	if mmMaintenanceMode.defaultExpectation != nil {
		mmMaintenanceMode.mock.t.Fatalf("Default expectation is already set for the Client.MaintenanceMode method")
	}

	if len(mmMaintenanceMode.expectations) > 0 {
		mmMaintenanceMode.mock.t.Fatalf("Some expectations are already set for the Client.MaintenanceMode method")
	}

	mmMaintenanceMode.mock.funcMaintenanceMode = f
	return mmMaintenanceMode.mock
}

// When sets expectation for the Client.MaintenanceMode which will trigger the result defined by the following
// Then helper
func (mmMaintenanceMode *mClientMockMaintenanceMode) When(enabled bool, reason string) *ClientMockMaintenanceModeExpectation {
	if mmMaintenanceMode.mock.funcMaintenanceMode != nil {
		mmMaintenanceMode.mock.t.Fatalf("ClientMock.MaintenanceMode mock is already set by Set")
	}

	expectation := &ClientMockMaintenanceModeExpectation{
		mock:   mmMaintenanceMode.mock,
		params: &ClientMockMaintenanceModeParams{enabled, reason},
	}
	mmMaintenanceMode.expectations = append(mmMaintenanceMode.expectations, expectation)
	return expectation
}

// Then sets up Client.MaintenanceMode return parameters for the expectation previously defined by the When method
func (e *ClientMockMaintenanceModeExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockMaintenanceModeResults{err}
	return e.mock
}

// MaintenanceMode implements Client
func (mmMaintenanceMode *ClientMock) MaintenanceMode(enabled bool, reason string) (err error) {
	mm_atomic.AddUint64(&mmMaintenanceMode.beforeMaintenanceModeCounter, 1)
	defer mm_atomic.AddUint64(&mmMaintenanceMode.afterMaintenanceModeCounter, 1)

	params := &ClientMockMaintenanceModeParams{enabled, reason}

	// Record call args
	mmMaintenanceMode.MaintenanceModeMock.mutex.Lock()
	mmMaintenanceMode.MaintenanceModeMock.callArgs = append(mmMaintenanceMode.MaintenanceModeMock.callArgs, params)
	mmMaintenanceMode.MaintenanceModeMock.mutex.Unlock()

	for _, e := range mmMaintenanceMode.MaintenanceModeMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmMaintenanceMode.MaintenanceModeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMaintenanceMode.MaintenanceModeMock.defaultExpectation.Counter, 1)
		want := mmMaintenanceMode.MaintenanceModeMock.defaultExpectation.params
		got := ClientMockMaintenanceModeParams{enabled, reason}
		if want != nil && !minimock.Equal(*want, got) {
			mmMaintenanceMode.t.Errorf("ClientMock.MaintenanceMode got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmMaintenanceMode.MaintenanceModeMock.defaultExpectation.results
		if results == nil {
			mmMaintenanceMode.t.Fatal("No results are set for the ClientMock.MaintenanceMode")
		}
		return (*results).err
	}
	if mmMaintenanceMode.funcMaintenanceMode != nil {
		return mmMaintenanceMode.funcMaintenanceMode(enabled, reason)
	}
	mmMaintenanceMode.t.Fatalf("Unexpected call to ClientMock.MaintenanceMode. %v %v", enabled, reason)
	return
}

// MaintenanceModeAfterCounter returns a count of finished ClientMock.MaintenanceMode invocations
func (mmMaintenanceMode *ClientMock) MaintenanceModeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMaintenanceMode.afterMaintenanceModeCounter)
}

// MaintenanceModeBeforeCounter returns a count of ClientMock.MaintenanceMode invocations
func (mmMaintenanceMode *ClientMock) MaintenanceModeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMaintenanceMode.beforeMaintenanceModeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.MaintenanceMode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMaintenanceMode *mClientMockMaintenanceMode) Calls() []*ClientMockMaintenanceModeParams {
	mmMaintenanceMode.mutex.RLock()

	argCopy := make([]*ClientMockMaintenanceModeParams, len(mmMaintenanceMode.callArgs))
	copy(argCopy, mmMaintenanceMode.callArgs)

	mmMaintenanceMode.mutex.RUnlock()

	return argCopy
}

// MinimockMaintenanceModeDone returns true if the count of the MaintenanceMode invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockMaintenanceModeDone() bool {
	for _, e := range m.MaintenanceModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MaintenanceModeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMaintenanceModeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMaintenanceMode != nil && mm_atomic.LoadUint64(&m.afterMaintenanceModeCounter) < 1 {
		return false
	}
	return true
}

// MinimockMaintenanceModeInspect logs each unmet expectation
func (m *ClientMock) MinimockMaintenanceModeInspect() {
	for _, e := range m.MaintenanceModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.MaintenanceMode with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MaintenanceModeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMaintenanceModeCounter) < 1 {
		if m.MaintenanceModeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.MaintenanceMode")
		} else {
			m.t.Errorf("Expected call to ClientMock.MaintenanceMode with params: %#v", *m.MaintenanceModeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMaintenanceMode != nil && mm_atomic.LoadUint64(&m.afterMaintenanceModeCounter) < 1 {
		m.t.Error("Expected call to ClientMock.MaintenanceMode")
	}
}

type mClientMockMembers struct {
	mock               *ClientMock
	defaultExpectation *ClientMockMembersExpectation
	expectations       []*ClientMockMembersExpectation

	callArgs []*ClientMockMembersParams
	mutex    sync.RWMutex
}

// ClientMockMembersExpectation specifies expectation struct of the Client.Members
type ClientMockMembersExpectation struct {
	mock    *ClientMock
	params  *ClientMockMembersParams
	results *ClientMockMembersResults
	Counter uint64
}

// ClientMockMembersParams contains parameters of the Client.Members
type ClientMockMembersParams struct {
	wan bool
}

// ClientMockMembersResults contains results of the Client.Members
type ClientMockMembersResults struct {
	aa1 []AgentInfo
	err error
}

// Expect sets up expected params for Client.Members
func (mmMembers *mClientMockMembers) Expect(wan bool) *mClientMockMembers {
	if mmMembers.mock.funcMembers != nil {
		mmMembers.mock.t.Fatalf("ClientMock.Members mock is already set by Set")
	}

	if mmMembers.defaultExpectation == nil {
		mmMembers.defaultExpectation = &ClientMockMembersExpectation{}
	}

	mmMembers.defaultExpectation.params = &ClientMockMembersParams{wan}
	for _, e := range mmMembers.expectations {
		if minimock.Equal(e.params, mmMembers.defaultExpectation.params) {
			mmMembers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMembers.defaultExpectation.params)
		}
	}

	return mmMembers
}

// Return sets up results that will be returned by Client.Members
func (mmMembers *mClientMockMembers) Return(aa1 []AgentInfo, err error) *ClientMock {
	if mmMembers.mock.funcMembers != nil {
		mmMembers.mock.t.Fatalf("ClientMock.Members mock is already set by Set")
	}

	if mmMembers.defaultExpectation == nil {
		mmMembers.defaultExpectation = &ClientMockMembersExpectation{mock: mmMembers.mock}
	}
	mmMembers.defaultExpectation.results = &ClientMockMembersResults{aa1, err}
	return mmMembers.mock
}

//Set uses given function f to mock the Client.Members method
func (mmMembers *mClientMockMembers) Set(f func(wan bool) (aa1 []AgentInfo, err error)) *ClientMock {
	if mmMembers.defaultExpectation != nil {
		mmMembers.mock.t.Fatalf("Default expectation is already set for the Client.Members method")
	}

	if len(mmMembers.expectations) > 0 {
		mmMembers.mock.t.Fatalf("Some expectations are already set for the Client.Members method")
	}

	mmMembers.mock.funcMembers = f
	return mmMembers.mock
}

// When sets expectation for the Client.Members which will trigger the result defined by the following
// Then helper
func (mmMembers *mClientMockMembers) When(wan bool) *ClientMockMembersExpectation {
	if mmMembers.mock.funcMembers != nil {
		mmMembers.mock.t.Fatalf("ClientMock.Members mock is already set by Set")
	}

	expectation := &ClientMockMembersExpectation{
		mock:   mmMembers.mock,
		params: &ClientMockMembersParams{wan},
	}
	mmMembers.expectations = append(mmMembers.expectations, expectation)
	return expectation
}

// Then sets up Client.Members return parameters for the expectation previously defined by the When method
func (e *ClientMockMembersExpectation) Then(aa1 []AgentInfo, err error) *ClientMock {
	e.results = &ClientMockMembersResults{aa1, err}
	return e.mock
}

// Members implements Client
func (mmMembers *ClientMock) Members(wan bool) (aa1 []AgentInfo, err error) {
	mm_atomic.AddUint64(&mmMembers.beforeMembersCounter, 1)
	defer mm_atomic.AddUint64(&mmMembers.afterMembersCounter, 1)

	params := &ClientMockMembersParams{wan}

	// Record call args
	mmMembers.MembersMock.mutex.Lock()
	mmMembers.MembersMock.callArgs = append(mmMembers.MembersMock.callArgs, params)
	mmMembers.MembersMock.mutex.Unlock()

	for _, e := range mmMembers.MembersMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.aa1, e.results.err
		}
	}

	if mmMembers.MembersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMembers.MembersMock.defaultExpectation.Counter, 1)
		want := mmMembers.MembersMock.defaultExpectation.params
		got := ClientMockMembersParams{wan}
		if want != nil && !minimock.Equal(*want, got) {
			mmMembers.t.Errorf("ClientMock.Members got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmMembers.MembersMock.defaultExpectation.results
		if results == nil {
			mmMembers.t.Fatal("No results are set for the ClientMock.Members")
		}
		return (*results).aa1, (*results).err
	}
	if mmMembers.funcMembers != nil {
		return mmMembers.funcMembers(wan)
	}
	mmMembers.t.Fatalf("Unexpected call to ClientMock.Members. %v", wan)
	return
}

// MembersAfterCounter returns a count of finished ClientMock.Members invocations
func (mmMembers *ClientMock) MembersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMembers.afterMembersCounter)
}

// MembersBeforeCounter returns a count of ClientMock.Members invocations
func (mmMembers *ClientMock) MembersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMembers.beforeMembersCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Members.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMembers *mClientMockMembers) Calls() []*ClientMockMembersParams {
	mmMembers.mutex.RLock()

	argCopy := make([]*ClientMockMembersParams, len(mmMembers.callArgs))
	copy(argCopy, mmMembers.callArgs)

	mmMembers.mutex.RUnlock()

	return argCopy
}

// MinimockMembersDone returns true if the count of the Members invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockMembersDone() bool {
	for _, e := range m.MembersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MembersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMembersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMembers != nil && mm_atomic.LoadUint64(&m.afterMembersCounter) < 1 {
		return false
	}
	return true
}

// MinimockMembersInspect logs each unmet expectation
func (m *ClientMock) MinimockMembersInspect() {
	for _, e := range m.MembersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Members with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MembersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMembersCounter) < 1 {
		if m.MembersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Members")
		} else {
			m.t.Errorf("Expected call to ClientMock.Members with params: %#v", *m.MembersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMembers != nil && mm_atomic.LoadUint64(&m.afterMembersCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Members")
	}
}

type mClientMockNode struct {
	mock               *ClientMock
	defaultExpectation *ClientMockNodeExpectation
	expectations       []*ClientMockNodeExpectation

	callArgs []*ClientMockNodeParams
	mutex    sync.RWMutex
}

// ClientMockNodeExpectation specifies expectation struct of the Client.Node
type ClientMockNodeExpectation struct {
	mock    *ClientMock
	params  *ClientMockNodeParams
	results *ClientMockNodeResults
	Counter uint64
}

// ClientMockNodeParams contains parameters of the Client.Node
type ClientMockNodeParams struct {
	dc   string
	name string
}

// ClientMockNodeResults contains results of the Client.Node
type ClientMockNodeResults struct {
	n1  NodeInfo
	err error
}

// Expect sets up expected params for Client.Node
func (mmNode *mClientMockNode) Expect(dc string, name string) *mClientMockNode {
	if mmNode.mock.funcNode != nil {
		mmNode.mock.t.Fatalf("ClientMock.Node mock is already set by Set")
	}

	if mmNode.defaultExpectation == nil {
		mmNode.defaultExpectation = &ClientMockNodeExpectation{}
	}

	mmNode.defaultExpectation.params = &ClientMockNodeParams{dc, name}
	for _, e := range mmNode.expectations {
		if minimock.Equal(e.params, mmNode.defaultExpectation.params) {
			mmNode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNode.defaultExpectation.params)
		}
	}

	return mmNode
}

// Return sets up results that will be returned by Client.Node
func (mmNode *mClientMockNode) Return(n1 NodeInfo, err error) *ClientMock {
	if mmNode.mock.funcNode != nil {
		mmNode.mock.t.Fatalf("ClientMock.Node mock is already set by Set")
	}

	if mmNode.defaultExpectation == nil {
		mmNode.defaultExpectation = &ClientMockNodeExpectation{mock: mmNode.mock}
	}
	mmNode.defaultExpectation.results = &ClientMockNodeResults{n1, err}
	return mmNode.mock
}

//Set uses given function f to mock the Client.Node method
func (mmNode *mClientMockNode) Set(f func(dc string, name string) (n1 NodeInfo, err error)) *ClientMock {
	if mmNode.defaultExpectation != nil {
		mmNode.mock.t.Fatalf("Default expectation is already set for the Client.Node method")
	}

	if len(mmNode.expectations) > 0 {
		mmNode.mock.t.Fatalf("Some expectations are already set for the Client.Node method")
	}

	mmNode.mock.funcNode = f
	return mmNode.mock
}

// When sets expectation for the Client.Node which will trigger the result defined by the following
// Then helper
func (mmNode *mClientMockNode) When(dc string, name string) *ClientMockNodeExpectation {
	if mmNode.mock.funcNode != nil {
		mmNode.mock.t.Fatalf("ClientMock.Node mock is already set by Set")
	}

	expectation := &ClientMockNodeExpectation{
		mock:   mmNode.mock,
		params: &ClientMockNodeParams{dc, name},
	}
	mmNode.expectations = append(mmNode.expectations, expectation)
	return expectation
}

// Then sets up Client.Node return parameters for the expectation previously defined by the When method
func (e *ClientMockNodeExpectation) Then(n1 NodeInfo, err error) *ClientMock {
	e.results = &ClientMockNodeResults{n1, err}
	return e.mock
}

// Node implements Client
func (mmNode *ClientMock) Node(dc string, name string) (n1 NodeInfo, err error) {
	mm_atomic.AddUint64(&mmNode.beforeNodeCounter, 1)
	defer mm_atomic.AddUint64(&mmNode.afterNodeCounter, 1)

	params := &ClientMockNodeParams{dc, name}

	// Record call args
	mmNode.NodeMock.mutex.Lock()
	mmNode.NodeMock.callArgs = append(mmNode.NodeMock.callArgs, params)
	mmNode.NodeMock.mutex.Unlock()

	for _, e := range mmNode.NodeMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n1, e.results.err
		}
	}

	if mmNode.NodeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNode.NodeMock.defaultExpectation.Counter, 1)
		want := mmNode.NodeMock.defaultExpectation.params
		got := ClientMockNodeParams{dc, name}
		if want != nil && !minimock.Equal(*want, got) {
			mmNode.t.Errorf("ClientMock.Node got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmNode.NodeMock.defaultExpectation.results
		if results == nil {
			mmNode.t.Fatal("No results are set for the ClientMock.Node")
		}
		return (*results).n1, (*results).err
	}
	if mmNode.funcNode != nil {
		return mmNode.funcNode(dc, name)
	}
	mmNode.t.Fatalf("Unexpected call to ClientMock.Node. %v %v", dc, name)
	return
}

// NodeAfterCounter returns a count of finished ClientMock.Node invocations
func (mmNode *ClientMock) NodeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNode.afterNodeCounter)
}

// NodeBeforeCounter returns a count of ClientMock.Node invocations
func (mmNode *ClientMock) NodeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNode.beforeNodeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Node.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNode *mClientMockNode) Calls() []*ClientMockNodeParams {
	mmNode.mutex.RLock()

	argCopy := make([]*ClientMockNodeParams, len(mmNode.callArgs))
	copy(argCopy, mmNode.callArgs)

	mmNode.mutex.RUnlock()

	return argCopy
}

// MinimockNodeDone returns true if the count of the Node invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockNodeDone() bool {
	for _, e := range m.NodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNodeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNode != nil && mm_atomic.LoadUint64(&m.afterNodeCounter) < 1 {
		return false
	}
	return true
}

// MinimockNodeInspect logs each unmet expectation
func (m *ClientMock) MinimockNodeInspect() {
	for _, e := range m.NodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Node with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNodeCounter) < 1 {
		if m.NodeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Node")
		} else {
			m.t.Errorf("Expected call to ClientMock.Node with params: %#v", *m.NodeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNode != nil && mm_atomic.LoadUint64(&m.afterNodeCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Node")
	}
}

type mClientMockNodes struct {
	mock               *ClientMock
	defaultExpectation *ClientMockNodesExpectation
	expectations       []*ClientMockNodesExpectation

	callArgs []*ClientMockNodesParams
	mutex    sync.RWMutex
}

// ClientMockNodesExpectation specifies expectation struct of the Client.Nodes
type ClientMockNodesExpectation struct {
	mock    *ClientMock
	params  *ClientMockNodesParams
	results *ClientMockNodesResults
	Counter uint64
}

// ClientMockNodesParams contains parameters of the Client.Nodes
type ClientMockNodesParams struct {
	dc string
}

// ClientMockNodesResults contains results of the Client.Nodes
type ClientMockNodesResults struct {
	na1 []Node
	err error
}

// Expect sets up expected params for Client.Nodes
func (mmNodes *mClientMockNodes) Expect(dc string) *mClientMockNodes {
	if mmNodes.mock.funcNodes != nil {
		mmNodes.mock.t.Fatalf("ClientMock.Nodes mock is already set by Set")
	}

	if mmNodes.defaultExpectation == nil {
		mmNodes.defaultExpectation = &ClientMockNodesExpectation{}
	}

	mmNodes.defaultExpectation.params = &ClientMockNodesParams{dc}
	for _, e := range mmNodes.expectations {
		if minimock.Equal(e.params, mmNodes.defaultExpectation.params) {
			mmNodes.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNodes.defaultExpectation.params)
		}
	}

	return mmNodes
}

// Return sets up results that will be returned by Client.Nodes
func (mmNodes *mClientMockNodes) Return(na1 []Node, err error) *ClientMock {
	if mmNodes.mock.funcNodes != nil {
		mmNodes.mock.t.Fatalf("ClientMock.Nodes mock is already set by Set")
	}

	if mmNodes.defaultExpectation == nil {
		mmNodes.defaultExpectation = &ClientMockNodesExpectation{mock: mmNodes.mock}
	}
	mmNodes.defaultExpectation.results = &ClientMockNodesResults{na1, err}
	return mmNodes.mock
}

//Set uses given function f to mock the Client.Nodes method
func (mmNodes *mClientMockNodes) Set(f func(dc string) (na1 []Node, err error)) *ClientMock {
	if mmNodes.defaultExpectation != nil {
		mmNodes.mock.t.Fatalf("Default expectation is already set for the Client.Nodes method")
	}

	if len(mmNodes.expectations) > 0 {
		mmNodes.mock.t.Fatalf("Some expectations are already set for the Client.Nodes method")
	}

	mmNodes.mock.funcNodes = f
	return mmNodes.mock
}

// When sets expectation for the Client.Nodes which will trigger the result defined by the following
// Then helper
func (mmNodes *mClientMockNodes) When(dc string) *ClientMockNodesExpectation {
	if mmNodes.mock.funcNodes != nil {
		mmNodes.mock.t.Fatalf("ClientMock.Nodes mock is already set by Set")
	}

	expectation := &ClientMockNodesExpectation{
		mock:   mmNodes.mock,
		params: &ClientMockNodesParams{dc},
	}
	mmNodes.expectations = append(mmNodes.expectations, expectation)
	return expectation
}

// Then sets up Client.Nodes return parameters for the expectation previously defined by the When method
func (e *ClientMockNodesExpectation) Then(na1 []Node, err error) *ClientMock {
	e.results = &ClientMockNodesResults{na1, err}
	return e.mock
}

// Nodes implements Client
func (mmNodes *ClientMock) Nodes(dc string) (na1 []Node, err error) {
	mm_atomic.AddUint64(&mmNodes.beforeNodesCounter, 1)
	defer mm_atomic.AddUint64(&mmNodes.afterNodesCounter, 1)

	params := &ClientMockNodesParams{dc}

	// Record call args
	mmNodes.NodesMock.mutex.Lock()
	mmNodes.NodesMock.callArgs = append(mmNodes.NodesMock.callArgs, params)
	mmNodes.NodesMock.mutex.Unlock()

	for _, e := range mmNodes.NodesMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.na1, e.results.err
		}
	}

	if mmNodes.NodesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNodes.NodesMock.defaultExpectation.Counter, 1)
		want := mmNodes.NodesMock.defaultExpectation.params
		got := ClientMockNodesParams{dc}
		if want != nil && !minimock.Equal(*want, got) {
			mmNodes.t.Errorf("ClientMock.Nodes got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmNodes.NodesMock.defaultExpectation.results
		if results == nil {
			mmNodes.t.Fatal("No results are set for the ClientMock.Nodes")
		}
		return (*results).na1, (*results).err
	}
	if mmNodes.funcNodes != nil {
		return mmNodes.funcNodes(dc)
	}
	mmNodes.t.Fatalf("Unexpected call to ClientMock.Nodes. %v", dc)
	return
}

// NodesAfterCounter returns a count of finished ClientMock.Nodes invocations
func (mmNodes *ClientMock) NodesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNodes.afterNodesCounter)
}

// NodesBeforeCounter returns a count of ClientMock.Nodes invocations
func (mmNodes *ClientMock) NodesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNodes.beforeNodesCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Nodes.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNodes *mClientMockNodes) Calls() []*ClientMockNodesParams {
	mmNodes.mutex.RLock()

	argCopy := make([]*ClientMockNodesParams, len(mmNodes.callArgs))
	copy(argCopy, mmNodes.callArgs)

	mmNodes.mutex.RUnlock()

	return argCopy
}

// MinimockNodesDone returns true if the count of the Nodes invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockNodesDone() bool {
	for _, e := range m.NodesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NodesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNodesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNodes != nil && mm_atomic.LoadUint64(&m.afterNodesCounter) < 1 {
		return false
	}
	return true
}

// MinimockNodesInspect logs each unmet expectation
func (m *ClientMock) MinimockNodesInspect() {
	for _, e := range m.NodesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Nodes with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NodesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNodesCounter) < 1 {
		if m.NodesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Nodes")
		} else {
			m.t.Errorf("Expected call to ClientMock.Nodes with params: %#v", *m.NodesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNodes != nil && mm_atomic.LoadUint64(&m.afterNodesCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Nodes")
	}
}

type mClientMockParticipate struct {
	mock               *ClientMock
	defaultExpectation *ClientMockParticipateExpectation
	expectations       []*ClientMockParticipateExpectation

	callArgs []*ClientMockParticipateParams
	mutex    sync.RWMutex
}

// ClientMockParticipateExpectation specifies expectation struct of the Client.Participate
type ClientMockParticipateExpectation struct {
	mock    *ClientMock
	params  *ClientMockParticipateParams
	results *ClientMockParticipateResults
	Counter uint64
}

// ClientMockParticipateParams contains parameters of the Client.Participate
type ClientMockParticipateParams struct {
	l1 LeadershipConfig
	a1 AsLeaderFunc
}

// ClientMockParticipateResults contains results of the Client.Participate
type ClientMockParticipateResults struct {
	l2  LeaderSession
	err error
}

// Expect sets up expected params for Client.Participate
func (mmParticipate *mClientMockParticipate) Expect(l1 LeadershipConfig, a1 AsLeaderFunc) *mClientMockParticipate {
	if mmParticipate.mock.funcParticipate != nil {
		mmParticipate.mock.t.Fatalf("ClientMock.Participate mock is already set by Set")
	}

	if mmParticipate.defaultExpectation == nil {
		mmParticipate.defaultExpectation = &ClientMockParticipateExpectation{}
	}

	mmParticipate.defaultExpectation.params = &ClientMockParticipateParams{l1, a1}
	for _, e := range mmParticipate.expectations {
		if minimock.Equal(e.params, mmParticipate.defaultExpectation.params) {
			mmParticipate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmParticipate.defaultExpectation.params)
		}
	}

	return mmParticipate
}

// Return sets up results that will be returned by Client.Participate
func (mmParticipate *mClientMockParticipate) Return(l2 LeaderSession, err error) *ClientMock {
	if mmParticipate.mock.funcParticipate != nil {
		mmParticipate.mock.t.Fatalf("ClientMock.Participate mock is already set by Set")
	}

	if mmParticipate.defaultExpectation == nil {
		mmParticipate.defaultExpectation = &ClientMockParticipateExpectation{mock: mmParticipate.mock}
	}
	mmParticipate.defaultExpectation.results = &ClientMockParticipateResults{l2, err}
	return mmParticipate.mock
}

//Set uses given function f to mock the Client.Participate method
func (mmParticipate *mClientMockParticipate) Set(f func(l1 LeadershipConfig, a1 AsLeaderFunc) (l2 LeaderSession, err error)) *ClientMock {
	if mmParticipate.defaultExpectation != nil {
		mmParticipate.mock.t.Fatalf("Default expectation is already set for the Client.Participate method")
	}

	if len(mmParticipate.expectations) > 0 {
		mmParticipate.mock.t.Fatalf("Some expectations are already set for the Client.Participate method")
	}

	mmParticipate.mock.funcParticipate = f
	return mmParticipate.mock
}

// When sets expectation for the Client.Participate which will trigger the result defined by the following
// Then helper
func (mmParticipate *mClientMockParticipate) When(l1 LeadershipConfig, a1 AsLeaderFunc) *ClientMockParticipateExpectation {
	if mmParticipate.mock.funcParticipate != nil {
		mmParticipate.mock.t.Fatalf("ClientMock.Participate mock is already set by Set")
	}

	expectation := &ClientMockParticipateExpectation{
		mock:   mmParticipate.mock,
		params: &ClientMockParticipateParams{l1, a1},
	}
	mmParticipate.expectations = append(mmParticipate.expectations, expectation)
	return expectation
}

// Then sets up Client.Participate return parameters for the expectation previously defined by the When method
func (e *ClientMockParticipateExpectation) Then(l2 LeaderSession, err error) *ClientMock {
	e.results = &ClientMockParticipateResults{l2, err}
	return e.mock
}

// Participate implements Client
func (mmParticipate *ClientMock) Participate(l1 LeadershipConfig, a1 AsLeaderFunc) (l2 LeaderSession, err error) {
	mm_atomic.AddUint64(&mmParticipate.beforeParticipateCounter, 1)
	defer mm_atomic.AddUint64(&mmParticipate.afterParticipateCounter, 1)

	params := &ClientMockParticipateParams{l1, a1}

	// Record call args
	mmParticipate.ParticipateMock.mutex.Lock()
	mmParticipate.ParticipateMock.callArgs = append(mmParticipate.ParticipateMock.callArgs, params)
	mmParticipate.ParticipateMock.mutex.Unlock()

	for _, e := range mmParticipate.ParticipateMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.l2, e.results.err
		}
	}

	if mmParticipate.ParticipateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmParticipate.ParticipateMock.defaultExpectation.Counter, 1)
		want := mmParticipate.ParticipateMock.defaultExpectation.params
		got := ClientMockParticipateParams{l1, a1}
		if want != nil && !minimock.Equal(*want, got) {
			mmParticipate.t.Errorf("ClientMock.Participate got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmParticipate.ParticipateMock.defaultExpectation.results
		if results == nil {
			mmParticipate.t.Fatal("No results are set for the ClientMock.Participate")
		}
		return (*results).l2, (*results).err
	}
	if mmParticipate.funcParticipate != nil {
		return mmParticipate.funcParticipate(l1, a1)
	}
	mmParticipate.t.Fatalf("Unexpected call to ClientMock.Participate. %v %v", l1, a1)
	return
}

// ParticipateAfterCounter returns a count of finished ClientMock.Participate invocations
func (mmParticipate *ClientMock) ParticipateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmParticipate.afterParticipateCounter)
}

// ParticipateBeforeCounter returns a count of ClientMock.Participate invocations
func (mmParticipate *ClientMock) ParticipateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmParticipate.beforeParticipateCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Participate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmParticipate *mClientMockParticipate) Calls() []*ClientMockParticipateParams {
	mmParticipate.mutex.RLock()

	argCopy := make([]*ClientMockParticipateParams, len(mmParticipate.callArgs))
	copy(argCopy, mmParticipate.callArgs)

	mmParticipate.mutex.RUnlock()

	return argCopy
}

// MinimockParticipateDone returns true if the count of the Participate invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockParticipateDone() bool {
	for _, e := range m.ParticipateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ParticipateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterParticipateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcParticipate != nil && mm_atomic.LoadUint64(&m.afterParticipateCounter) < 1 {
		return false
	}
	return true
}

// MinimockParticipateInspect logs each unmet expectation
func (m *ClientMock) MinimockParticipateInspect() {
	for _, e := range m.ParticipateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Participate with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ParticipateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterParticipateCounter) < 1 {
		if m.ParticipateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Participate")
		} else {
			m.t.Errorf("Expected call to ClientMock.Participate with params: %#v", *m.ParticipateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcParticipate != nil && mm_atomic.LoadUint64(&m.afterParticipateCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Participate")
	}
}

type mClientMockPut struct {
	mock               *ClientMock
	defaultExpectation *ClientMockPutExpectation
	expectations       []*ClientMockPutExpectation

	callArgs []*ClientMockPutParams
	mutex    sync.RWMutex
}

// ClientMockPutExpectation specifies expectation struct of the Client.Put
type ClientMockPutExpectation struct {
	mock    *ClientMock
	params  *ClientMockPutParams
	results *ClientMockPutResults
	Counter uint64
}

// ClientMockPutParams contains parameters of the Client.Put
type ClientMockPutParams struct {
	dc    string
	path  string
	value string
}

// ClientMockPutResults contains results of the Client.Put
type ClientMockPutResults struct {
	err error
}

// Expect sets up expected params for Client.Put
func (mmPut *mClientMockPut) Expect(dc string, path string, value string) *mClientMockPut {
	if mmPut.mock.funcPut != nil {
		mmPut.mock.t.Fatalf("ClientMock.Put mock is already set by Set")
	}

	if mmPut.defaultExpectation == nil {
		mmPut.defaultExpectation = &ClientMockPutExpectation{}
	}

	mmPut.defaultExpectation.params = &ClientMockPutParams{dc, path, value}
	for _, e := range mmPut.expectations {
		if minimock.Equal(e.params, mmPut.defaultExpectation.params) {
			mmPut.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPut.defaultExpectation.params)
		}
	}

	return mmPut
}

// Return sets up results that will be returned by Client.Put
func (mmPut *mClientMockPut) Return(err error) *ClientMock {
	if mmPut.mock.funcPut != nil {
		mmPut.mock.t.Fatalf("ClientMock.Put mock is already set by Set")
	}

	if mmPut.defaultExpectation == nil {
		mmPut.defaultExpectation = &ClientMockPutExpectation{mock: mmPut.mock}
	}
	mmPut.defaultExpectation.results = &ClientMockPutResults{err}
	return mmPut.mock
}

//Set uses given function f to mock the Client.Put method
func (mmPut *mClientMockPut) Set(f func(dc string, path string, value string) (err error)) *ClientMock {
	if mmPut.defaultExpectation != nil {
		mmPut.mock.t.Fatalf("Default expectation is already set for the Client.Put method")
	}

	if len(mmPut.expectations) > 0 {
		mmPut.mock.t.Fatalf("Some expectations are already set for the Client.Put method")
	}

	mmPut.mock.funcPut = f
	return mmPut.mock
}

// When sets expectation for the Client.Put which will trigger the result defined by the following
// Then helper
func (mmPut *mClientMockPut) When(dc string, path string, value string) *ClientMockPutExpectation {
	if mmPut.mock.funcPut != nil {
		mmPut.mock.t.Fatalf("ClientMock.Put mock is already set by Set")
	}

	expectation := &ClientMockPutExpectation{
		mock:   mmPut.mock,
		params: &ClientMockPutParams{dc, path, value},
	}
	mmPut.expectations = append(mmPut.expectations, expectation)
	return expectation
}

// Then sets up Client.Put return parameters for the expectation previously defined by the When method
func (e *ClientMockPutExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockPutResults{err}
	return e.mock
}

// Put implements Client
func (mmPut *ClientMock) Put(dc string, path string, value string) (err error) {
	mm_atomic.AddUint64(&mmPut.beforePutCounter, 1)
	defer mm_atomic.AddUint64(&mmPut.afterPutCounter, 1)

	params := &ClientMockPutParams{dc, path, value}

	// Record call args
	mmPut.PutMock.mutex.Lock()
	mmPut.PutMock.callArgs = append(mmPut.PutMock.callArgs, params)
	mmPut.PutMock.mutex.Unlock()

	for _, e := range mmPut.PutMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPut.PutMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPut.PutMock.defaultExpectation.Counter, 1)
		want := mmPut.PutMock.defaultExpectation.params
		got := ClientMockPutParams{dc, path, value}
		if want != nil && !minimock.Equal(*want, got) {
			mmPut.t.Errorf("ClientMock.Put got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmPut.PutMock.defaultExpectation.results
		if results == nil {
			mmPut.t.Fatal("No results are set for the ClientMock.Put")
		}
		return (*results).err
	}
	if mmPut.funcPut != nil {
		return mmPut.funcPut(dc, path, value)
	}
	mmPut.t.Fatalf("Unexpected call to ClientMock.Put. %v %v %v", dc, path, value)
	return
}

// PutAfterCounter returns a count of finished ClientMock.Put invocations
func (mmPut *ClientMock) PutAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPut.afterPutCounter)
}

// PutBeforeCounter returns a count of ClientMock.Put invocations
func (mmPut *ClientMock) PutBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPut.beforePutCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Put.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPut *mClientMockPut) Calls() []*ClientMockPutParams {
	mmPut.mutex.RLock()

	argCopy := make([]*ClientMockPutParams, len(mmPut.callArgs))
	copy(argCopy, mmPut.callArgs)

	mmPut.mutex.RUnlock()

	return argCopy
}

// MinimockPutDone returns true if the count of the Put invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockPutDone() bool {
	for _, e := range m.PutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PutMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPut != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		return false
	}
	return true
}

// MinimockPutInspect logs each unmet expectation
func (m *ClientMock) MinimockPutInspect() {
	for _, e := range m.PutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Put with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PutMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		if m.PutMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Put")
		} else {
			m.t.Errorf("Expected call to ClientMock.Put with params: %#v", *m.PutMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPut != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Put")
	}
}

type mClientMockReadSession struct {
	mock               *ClientMock
	defaultExpectation *ClientMockReadSessionExpectation
	expectations       []*ClientMockReadSessionExpectation

	callArgs []*ClientMockReadSessionParams
	mutex    sync.RWMutex
}

// ClientMockReadSessionExpectation specifies expectation struct of the Client.ReadSession
type ClientMockReadSessionExpectation struct {
	mock    *ClientMock
	params  *ClientMockReadSessionParams
	results *ClientMockReadSessionResults
	Counter uint64
}

// ClientMockReadSessionParams contains parameters of the Client.ReadSession
type ClientMockReadSessionParams struct {
	dc string
	id SessionID
}

// ClientMockReadSessionResults contains results of the Client.ReadSession
type ClientMockReadSessionResults struct {
	s1  SessionConfig
	err error
}

// Expect sets up expected params for Client.ReadSession
func (mmReadSession *mClientMockReadSession) Expect(dc string, id SessionID) *mClientMockReadSession {
	if mmReadSession.mock.funcReadSession != nil {
		mmReadSession.mock.t.Fatalf("ClientMock.ReadSession mock is already set by Set")
	}

	if mmReadSession.defaultExpectation == nil {
		mmReadSession.defaultExpectation = &ClientMockReadSessionExpectation{}
	}

	mmReadSession.defaultExpectation.params = &ClientMockReadSessionParams{dc, id}
	for _, e := range mmReadSession.expectations {
		if minimock.Equal(e.params, mmReadSession.defaultExpectation.params) {
			mmReadSession.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadSession.defaultExpectation.params)
		}
	}

	return mmReadSession
}

// Return sets up results that will be returned by Client.ReadSession
func (mmReadSession *mClientMockReadSession) Return(s1 SessionConfig, err error) *ClientMock {
	if mmReadSession.mock.funcReadSession != nil {
		mmReadSession.mock.t.Fatalf("ClientMock.ReadSession mock is already set by Set")
	}

	if mmReadSession.defaultExpectation == nil {
		mmReadSession.defaultExpectation = &ClientMockReadSessionExpectation{mock: mmReadSession.mock}
	}
	mmReadSession.defaultExpectation.results = &ClientMockReadSessionResults{s1, err}
	return mmReadSession.mock
}

//Set uses given function f to mock the Client.ReadSession method
func (mmReadSession *mClientMockReadSession) Set(f func(dc string, id SessionID) (s1 SessionConfig, err error)) *ClientMock {
	if mmReadSession.defaultExpectation != nil {
		mmReadSession.mock.t.Fatalf("Default expectation is already set for the Client.ReadSession method")
	}

	if len(mmReadSession.expectations) > 0 {
		mmReadSession.mock.t.Fatalf("Some expectations are already set for the Client.ReadSession method")
	}

	mmReadSession.mock.funcReadSession = f
	return mmReadSession.mock
}

// When sets expectation for the Client.ReadSession which will trigger the result defined by the following
// Then helper
func (mmReadSession *mClientMockReadSession) When(dc string, id SessionID) *ClientMockReadSessionExpectation {
	if mmReadSession.mock.funcReadSession != nil {
		mmReadSession.mock.t.Fatalf("ClientMock.ReadSession mock is already set by Set")
	}

	expectation := &ClientMockReadSessionExpectation{
		mock:   mmReadSession.mock,
		params: &ClientMockReadSessionParams{dc, id},
	}
	mmReadSession.expectations = append(mmReadSession.expectations, expectation)
	return expectation
}

// Then sets up Client.ReadSession return parameters for the expectation previously defined by the When method
func (e *ClientMockReadSessionExpectation) Then(s1 SessionConfig, err error) *ClientMock {
	e.results = &ClientMockReadSessionResults{s1, err}
	return e.mock
}

// ReadSession implements Client
func (mmReadSession *ClientMock) ReadSession(dc string, id SessionID) (s1 SessionConfig, err error) {
	mm_atomic.AddUint64(&mmReadSession.beforeReadSessionCounter, 1)
	defer mm_atomic.AddUint64(&mmReadSession.afterReadSessionCounter, 1)

	params := &ClientMockReadSessionParams{dc, id}

	// Record call args
	mmReadSession.ReadSessionMock.mutex.Lock()
	mmReadSession.ReadSessionMock.callArgs = append(mmReadSession.ReadSessionMock.callArgs, params)
	mmReadSession.ReadSessionMock.mutex.Unlock()

	for _, e := range mmReadSession.ReadSessionMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmReadSession.ReadSessionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadSession.ReadSessionMock.defaultExpectation.Counter, 1)
		want := mmReadSession.ReadSessionMock.defaultExpectation.params
		got := ClientMockReadSessionParams{dc, id}
		if want != nil && !minimock.Equal(*want, got) {
			mmReadSession.t.Errorf("ClientMock.ReadSession got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmReadSession.ReadSessionMock.defaultExpectation.results
		if results == nil {
			mmReadSession.t.Fatal("No results are set for the ClientMock.ReadSession")
		}
		return (*results).s1, (*results).err
	}
	if mmReadSession.funcReadSession != nil {
		return mmReadSession.funcReadSession(dc, id)
	}
	mmReadSession.t.Fatalf("Unexpected call to ClientMock.ReadSession. %v %v", dc, id)
	return
}

// ReadSessionAfterCounter returns a count of finished ClientMock.ReadSession invocations
func (mmReadSession *ClientMock) ReadSessionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadSession.afterReadSessionCounter)
}

// ReadSessionBeforeCounter returns a count of ClientMock.ReadSession invocations
func (mmReadSession *ClientMock) ReadSessionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadSession.beforeReadSessionCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.ReadSession.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadSession *mClientMockReadSession) Calls() []*ClientMockReadSessionParams {
	mmReadSession.mutex.RLock()

	argCopy := make([]*ClientMockReadSessionParams, len(mmReadSession.callArgs))
	copy(argCopy, mmReadSession.callArgs)

	mmReadSession.mutex.RUnlock()

	return argCopy
}

// MinimockReadSessionDone returns true if the count of the ReadSession invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockReadSessionDone() bool {
	for _, e := range m.ReadSessionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadSessionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadSessionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadSession != nil && mm_atomic.LoadUint64(&m.afterReadSessionCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadSessionInspect logs each unmet expectation
func (m *ClientMock) MinimockReadSessionInspect() {
	for _, e := range m.ReadSessionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.ReadSession with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadSessionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadSessionCounter) < 1 {
		if m.ReadSessionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.ReadSession")
		} else {
			m.t.Errorf("Expected call to ClientMock.ReadSession with params: %#v", *m.ReadSessionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadSession != nil && mm_atomic.LoadUint64(&m.afterReadSessionCounter) < 1 {
		m.t.Error("Expected call to ClientMock.ReadSession")
	}
}

type mClientMockRecurse struct {
	mock               *ClientMock
	defaultExpectation *ClientMockRecurseExpectation
	expectations       []*ClientMockRecurseExpectation

	callArgs []*ClientMockRecurseParams
	mutex    sync.RWMutex
}

// ClientMockRecurseExpectation specifies expectation struct of the Client.Recurse
type ClientMockRecurseExpectation struct {
	mock    *ClientMock
	params  *ClientMockRecurseParams
	results *ClientMockRecurseResults
	Counter uint64
}

// ClientMockRecurseParams contains parameters of the Client.Recurse
type ClientMockRecurseParams struct {
	dc   string
	path string
}

// ClientMockRecurseResults contains results of the Client.Recurse
type ClientMockRecurseResults struct {
	saa1 [][2]string
	err  error
}

// Expect sets up expected params for Client.Recurse
func (mmRecurse *mClientMockRecurse) Expect(dc string, path string) *mClientMockRecurse {
	if mmRecurse.mock.funcRecurse != nil {
		mmRecurse.mock.t.Fatalf("ClientMock.Recurse mock is already set by Set")
	}

	if mmRecurse.defaultExpectation == nil {
		mmRecurse.defaultExpectation = &ClientMockRecurseExpectation{}
	}

	mmRecurse.defaultExpectation.params = &ClientMockRecurseParams{dc, path}
	for _, e := range mmRecurse.expectations {
		if minimock.Equal(e.params, mmRecurse.defaultExpectation.params) {
			mmRecurse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRecurse.defaultExpectation.params)
		}
	}

	return mmRecurse
}

// Return sets up results that will be returned by Client.Recurse
func (mmRecurse *mClientMockRecurse) Return(saa1 [][2]string, err error) *ClientMock {
	if mmRecurse.mock.funcRecurse != nil {
		mmRecurse.mock.t.Fatalf("ClientMock.Recurse mock is already set by Set")
	}

	if mmRecurse.defaultExpectation == nil {
		mmRecurse.defaultExpectation = &ClientMockRecurseExpectation{mock: mmRecurse.mock}
	}
	mmRecurse.defaultExpectation.results = &ClientMockRecurseResults{saa1, err}
	return mmRecurse.mock
}

//Set uses given function f to mock the Client.Recurse method
func (mmRecurse *mClientMockRecurse) Set(f func(dc string, path string) (saa1 [][2]string, err error)) *ClientMock {
	if mmRecurse.defaultExpectation != nil {
		mmRecurse.mock.t.Fatalf("Default expectation is already set for the Client.Recurse method")
	}

	if len(mmRecurse.expectations) > 0 {
		mmRecurse.mock.t.Fatalf("Some expectations are already set for the Client.Recurse method")
	}

	mmRecurse.mock.funcRecurse = f
	return mmRecurse.mock
}

// When sets expectation for the Client.Recurse which will trigger the result defined by the following
// Then helper
func (mmRecurse *mClientMockRecurse) When(dc string, path string) *ClientMockRecurseExpectation {
	if mmRecurse.mock.funcRecurse != nil {
		mmRecurse.mock.t.Fatalf("ClientMock.Recurse mock is already set by Set")
	}

	expectation := &ClientMockRecurseExpectation{
		mock:   mmRecurse.mock,
		params: &ClientMockRecurseParams{dc, path},
	}
	mmRecurse.expectations = append(mmRecurse.expectations, expectation)
	return expectation
}

// Then sets up Client.Recurse return parameters for the expectation previously defined by the When method
func (e *ClientMockRecurseExpectation) Then(saa1 [][2]string, err error) *ClientMock {
	e.results = &ClientMockRecurseResults{saa1, err}
	return e.mock
}

// Recurse implements Client
func (mmRecurse *ClientMock) Recurse(dc string, path string) (saa1 [][2]string, err error) {
	mm_atomic.AddUint64(&mmRecurse.beforeRecurseCounter, 1)
	defer mm_atomic.AddUint64(&mmRecurse.afterRecurseCounter, 1)

	params := &ClientMockRecurseParams{dc, path}

	// Record call args
	mmRecurse.RecurseMock.mutex.Lock()
	mmRecurse.RecurseMock.callArgs = append(mmRecurse.RecurseMock.callArgs, params)
	mmRecurse.RecurseMock.mutex.Unlock()

	for _, e := range mmRecurse.RecurseMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.saa1, e.results.err
		}
	}

	if mmRecurse.RecurseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRecurse.RecurseMock.defaultExpectation.Counter, 1)
		want := mmRecurse.RecurseMock.defaultExpectation.params
		got := ClientMockRecurseParams{dc, path}
		if want != nil && !minimock.Equal(*want, got) {
			mmRecurse.t.Errorf("ClientMock.Recurse got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmRecurse.RecurseMock.defaultExpectation.results
		if results == nil {
			mmRecurse.t.Fatal("No results are set for the ClientMock.Recurse")
		}
		return (*results).saa1, (*results).err
	}
	if mmRecurse.funcRecurse != nil {
		return mmRecurse.funcRecurse(dc, path)
	}
	mmRecurse.t.Fatalf("Unexpected call to ClientMock.Recurse. %v %v", dc, path)
	return
}

// RecurseAfterCounter returns a count of finished ClientMock.Recurse invocations
func (mmRecurse *ClientMock) RecurseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecurse.afterRecurseCounter)
}

// RecurseBeforeCounter returns a count of ClientMock.Recurse invocations
func (mmRecurse *ClientMock) RecurseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecurse.beforeRecurseCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Recurse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRecurse *mClientMockRecurse) Calls() []*ClientMockRecurseParams {
	mmRecurse.mutex.RLock()

	argCopy := make([]*ClientMockRecurseParams, len(mmRecurse.callArgs))
	copy(argCopy, mmRecurse.callArgs)

	mmRecurse.mutex.RUnlock()

	return argCopy
}

// MinimockRecurseDone returns true if the count of the Recurse invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockRecurseDone() bool {
	for _, e := range m.RecurseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RecurseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRecurseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecurse != nil && mm_atomic.LoadUint64(&m.afterRecurseCounter) < 1 {
		return false
	}
	return true
}

// MinimockRecurseInspect logs each unmet expectation
func (m *ClientMock) MinimockRecurseInspect() {
	for _, e := range m.RecurseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Recurse with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RecurseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRecurseCounter) < 1 {
		if m.RecurseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Recurse")
		} else {
			m.t.Errorf("Expected call to ClientMock.Recurse with params: %#v", *m.RecurseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecurse != nil && mm_atomic.LoadUint64(&m.afterRecurseCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Recurse")
	}
}

type mClientMockReload struct {
	mock               *ClientMock
	defaultExpectation *ClientMockReloadExpectation
	expectations       []*ClientMockReloadExpectation
}

// ClientMockReloadExpectation specifies expectation struct of the Client.Reload
type ClientMockReloadExpectation struct {
	mock *ClientMock

	results *ClientMockReloadResults
	Counter uint64
}

// ClientMockReloadResults contains results of the Client.Reload
type ClientMockReloadResults struct {
	err error
}

// Expect sets up expected params for Client.Reload
func (mmReload *mClientMockReload) Expect() *mClientMockReload {
	if mmReload.mock.funcReload != nil {
		mmReload.mock.t.Fatalf("ClientMock.Reload mock is already set by Set")
	}

	if mmReload.defaultExpectation == nil {
		mmReload.defaultExpectation = &ClientMockReloadExpectation{}
	}

	return mmReload
}

// Return sets up results that will be returned by Client.Reload
func (mmReload *mClientMockReload) Return(err error) *ClientMock {
	if mmReload.mock.funcReload != nil {
		mmReload.mock.t.Fatalf("ClientMock.Reload mock is already set by Set")
	}

	if mmReload.defaultExpectation == nil {
		mmReload.defaultExpectation = &ClientMockReloadExpectation{mock: mmReload.mock}
	}
	mmReload.defaultExpectation.results = &ClientMockReloadResults{err}
	return mmReload.mock
}

//Set uses given function f to mock the Client.Reload method
func (mmReload *mClientMockReload) Set(f func() (err error)) *ClientMock {
	if mmReload.defaultExpectation != nil {
		mmReload.mock.t.Fatalf("Default expectation is already set for the Client.Reload method")
	}

	if len(mmReload.expectations) > 0 {
		mmReload.mock.t.Fatalf("Some expectations are already set for the Client.Reload method")
	}

	mmReload.mock.funcReload = f
	return mmReload.mock
}

// Reload implements Client
func (mmReload *ClientMock) Reload() (err error) {
	mm_atomic.AddUint64(&mmReload.beforeReloadCounter, 1)
	defer mm_atomic.AddUint64(&mmReload.afterReloadCounter, 1)

	if mmReload.ReloadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReload.ReloadMock.defaultExpectation.Counter, 1)

		results := mmReload.ReloadMock.defaultExpectation.results
		if results == nil {
			mmReload.t.Fatal("No results are set for the ClientMock.Reload")
		}
		return (*results).err
	}
	if mmReload.funcReload != nil {
		return mmReload.funcReload()
	}
	mmReload.t.Fatalf("Unexpected call to ClientMock.Reload.")
	return
}

// ReloadAfterCounter returns a count of finished ClientMock.Reload invocations
func (mmReload *ClientMock) ReloadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReload.afterReloadCounter)
}

// ReloadBeforeCounter returns a count of ClientMock.Reload invocations
func (mmReload *ClientMock) ReloadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReload.beforeReloadCounter)
}

// MinimockReloadDone returns true if the count of the Reload invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockReloadDone() bool {
	for _, e := range m.ReloadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReloadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReloadCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReload != nil && mm_atomic.LoadUint64(&m.afterReloadCounter) < 1 {
		return false
	}
	return true
}

// MinimockReloadInspect logs each unmet expectation
func (m *ClientMock) MinimockReloadInspect() {
	for _, e := range m.ReloadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ClientMock.Reload")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReloadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReloadCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Reload")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReload != nil && mm_atomic.LoadUint64(&m.afterReloadCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Reload")
	}
}

type mClientMockRenewSession struct {
	mock               *ClientMock
	defaultExpectation *ClientMockRenewSessionExpectation
	expectations       []*ClientMockRenewSessionExpectation

	callArgs []*ClientMockRenewSessionParams
	mutex    sync.RWMutex
}

// ClientMockRenewSessionExpectation specifies expectation struct of the Client.RenewSession
type ClientMockRenewSessionExpectation struct {
	mock    *ClientMock
	params  *ClientMockRenewSessionParams
	results *ClientMockRenewSessionResults
	Counter uint64
}

// ClientMockRenewSessionParams contains parameters of the Client.RenewSession
type ClientMockRenewSessionParams struct {
	dc string
	id SessionID
}

// ClientMockRenewSessionResults contains results of the Client.RenewSession
type ClientMockRenewSessionResults struct {
	d1  time.Duration
	err error
}

// Expect sets up expected params for Client.RenewSession
func (mmRenewSession *mClientMockRenewSession) Expect(dc string, id SessionID) *mClientMockRenewSession {
	if mmRenewSession.mock.funcRenewSession != nil {
		mmRenewSession.mock.t.Fatalf("ClientMock.RenewSession mock is already set by Set")
	}

	if mmRenewSession.defaultExpectation == nil {
		mmRenewSession.defaultExpectation = &ClientMockRenewSessionExpectation{}
	}

	mmRenewSession.defaultExpectation.params = &ClientMockRenewSessionParams{dc, id}
	for _, e := range mmRenewSession.expectations {
		if minimock.Equal(e.params, mmRenewSession.defaultExpectation.params) {
			mmRenewSession.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRenewSession.defaultExpectation.params)
		}
	}

	return mmRenewSession
}

// Return sets up results that will be returned by Client.RenewSession
func (mmRenewSession *mClientMockRenewSession) Return(d1 time.Duration, err error) *ClientMock {
	if mmRenewSession.mock.funcRenewSession != nil {
		mmRenewSession.mock.t.Fatalf("ClientMock.RenewSession mock is already set by Set")
	}

	if mmRenewSession.defaultExpectation == nil {
		mmRenewSession.defaultExpectation = &ClientMockRenewSessionExpectation{mock: mmRenewSession.mock}
	}
	mmRenewSession.defaultExpectation.results = &ClientMockRenewSessionResults{d1, err}
	return mmRenewSession.mock
}

//Set uses given function f to mock the Client.RenewSession method
func (mmRenewSession *mClientMockRenewSession) Set(f func(dc string, id SessionID) (d1 time.Duration, err error)) *ClientMock {
	if mmRenewSession.defaultExpectation != nil {
		mmRenewSession.mock.t.Fatalf("Default expectation is already set for the Client.RenewSession method")
	}

	if len(mmRenewSession.expectations) > 0 {
		mmRenewSession.mock.t.Fatalf("Some expectations are already set for the Client.RenewSession method")
	}

	mmRenewSession.mock.funcRenewSession = f
	return mmRenewSession.mock
}

// When sets expectation for the Client.RenewSession which will trigger the result defined by the following
// Then helper
func (mmRenewSession *mClientMockRenewSession) When(dc string, id SessionID) *ClientMockRenewSessionExpectation {
	if mmRenewSession.mock.funcRenewSession != nil {
		mmRenewSession.mock.t.Fatalf("ClientMock.RenewSession mock is already set by Set")
	}

	expectation := &ClientMockRenewSessionExpectation{
		mock:   mmRenewSession.mock,
		params: &ClientMockRenewSessionParams{dc, id},
	}
	mmRenewSession.expectations = append(mmRenewSession.expectations, expectation)
	return expectation
}

// Then sets up Client.RenewSession return parameters for the expectation previously defined by the When method
func (e *ClientMockRenewSessionExpectation) Then(d1 time.Duration, err error) *ClientMock {
	e.results = &ClientMockRenewSessionResults{d1, err}
	return e.mock
}

// RenewSession implements Client
func (mmRenewSession *ClientMock) RenewSession(dc string, id SessionID) (d1 time.Duration, err error) {
	mm_atomic.AddUint64(&mmRenewSession.beforeRenewSessionCounter, 1)
	defer mm_atomic.AddUint64(&mmRenewSession.afterRenewSessionCounter, 1)

	params := &ClientMockRenewSessionParams{dc, id}

	// Record call args
	mmRenewSession.RenewSessionMock.mutex.Lock()
	mmRenewSession.RenewSessionMock.callArgs = append(mmRenewSession.RenewSessionMock.callArgs, params)
	mmRenewSession.RenewSessionMock.mutex.Unlock()

	for _, e := range mmRenewSession.RenewSessionMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.d1, e.results.err
		}
	}

	if mmRenewSession.RenewSessionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRenewSession.RenewSessionMock.defaultExpectation.Counter, 1)
		want := mmRenewSession.RenewSessionMock.defaultExpectation.params
		got := ClientMockRenewSessionParams{dc, id}
		if want != nil && !minimock.Equal(*want, got) {
			mmRenewSession.t.Errorf("ClientMock.RenewSession got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmRenewSession.RenewSessionMock.defaultExpectation.results
		if results == nil {
			mmRenewSession.t.Fatal("No results are set for the ClientMock.RenewSession")
		}
		return (*results).d1, (*results).err
	}
	if mmRenewSession.funcRenewSession != nil {
		return mmRenewSession.funcRenewSession(dc, id)
	}
	mmRenewSession.t.Fatalf("Unexpected call to ClientMock.RenewSession. %v %v", dc, id)
	return
}

// RenewSessionAfterCounter returns a count of finished ClientMock.RenewSession invocations
func (mmRenewSession *ClientMock) RenewSessionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRenewSession.afterRenewSessionCounter)
}

// RenewSessionBeforeCounter returns a count of ClientMock.RenewSession invocations
func (mmRenewSession *ClientMock) RenewSessionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRenewSession.beforeRenewSessionCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.RenewSession.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRenewSession *mClientMockRenewSession) Calls() []*ClientMockRenewSessionParams {
	mmRenewSession.mutex.RLock()

	argCopy := make([]*ClientMockRenewSessionParams, len(mmRenewSession.callArgs))
	copy(argCopy, mmRenewSession.callArgs)

	mmRenewSession.mutex.RUnlock()

	return argCopy
}

// MinimockRenewSessionDone returns true if the count of the RenewSession invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockRenewSessionDone() bool {
	for _, e := range m.RenewSessionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RenewSessionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRenewSessionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRenewSession != nil && mm_atomic.LoadUint64(&m.afterRenewSessionCounter) < 1 {
		return false
	}
	return true
}

// MinimockRenewSessionInspect logs each unmet expectation
func (m *ClientMock) MinimockRenewSessionInspect() {
	for _, e := range m.RenewSessionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.RenewSession with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RenewSessionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRenewSessionCounter) < 1 {
		if m.RenewSessionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.RenewSession")
		} else {
			m.t.Errorf("Expected call to ClientMock.RenewSession with params: %#v", *m.RenewSessionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRenewSession != nil && mm_atomic.LoadUint64(&m.afterRenewSessionCounter) < 1 {
		m.t.Error("Expected call to ClientMock.RenewSession")
	}
}

type mClientMockSelf struct {
	mock               *ClientMock
	defaultExpectation *ClientMockSelfExpectation
	expectations       []*ClientMockSelfExpectation
}

// ClientMockSelfExpectation specifies expectation struct of the Client.Self
type ClientMockSelfExpectation struct {
	mock *ClientMock

	results *ClientMockSelfResults
	Counter uint64
}

// ClientMockSelfResults contains results of the Client.Self
type ClientMockSelfResults struct {
	a1  AgentInfo
	err error
}

// Expect sets up expected params for Client.Self
func (mmSelf *mClientMockSelf) Expect() *mClientMockSelf {
	if mmSelf.mock.funcSelf != nil {
		mmSelf.mock.t.Fatalf("ClientMock.Self mock is already set by Set")
	}

	if mmSelf.defaultExpectation == nil {
		mmSelf.defaultExpectation = &ClientMockSelfExpectation{}
	}

	return mmSelf
}

// Return sets up results that will be returned by Client.Self
func (mmSelf *mClientMockSelf) Return(a1 AgentInfo, err error) *ClientMock {
	if mmSelf.mock.funcSelf != nil {
		mmSelf.mock.t.Fatalf("ClientMock.Self mock is already set by Set")
	}

	if mmSelf.defaultExpectation == nil {
		mmSelf.defaultExpectation = &ClientMockSelfExpectation{mock: mmSelf.mock}
	}
	mmSelf.defaultExpectation.results = &ClientMockSelfResults{a1, err}
	return mmSelf.mock
}

//Set uses given function f to mock the Client.Self method
func (mmSelf *mClientMockSelf) Set(f func() (a1 AgentInfo, err error)) *ClientMock {
	if mmSelf.defaultExpectation != nil {
		mmSelf.mock.t.Fatalf("Default expectation is already set for the Client.Self method")
	}

	if len(mmSelf.expectations) > 0 {
		mmSelf.mock.t.Fatalf("Some expectations are already set for the Client.Self method")
	}

	mmSelf.mock.funcSelf = f
	return mmSelf.mock
}

// Self implements Client
func (mmSelf *ClientMock) Self() (a1 AgentInfo, err error) {
	mm_atomic.AddUint64(&mmSelf.beforeSelfCounter, 1)
	defer mm_atomic.AddUint64(&mmSelf.afterSelfCounter, 1)

	if mmSelf.SelfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelf.SelfMock.defaultExpectation.Counter, 1)

		results := mmSelf.SelfMock.defaultExpectation.results
		if results == nil {
			mmSelf.t.Fatal("No results are set for the ClientMock.Self")
		}
		return (*results).a1, (*results).err
	}
	if mmSelf.funcSelf != nil {
		return mmSelf.funcSelf()
	}
	mmSelf.t.Fatalf("Unexpected call to ClientMock.Self.")
	return
}

// SelfAfterCounter returns a count of finished ClientMock.Self invocations
func (mmSelf *ClientMock) SelfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelf.afterSelfCounter)
}

// SelfBeforeCounter returns a count of ClientMock.Self invocations
func (mmSelf *ClientMock) SelfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelf.beforeSelfCounter)
}

// MinimockSelfDone returns true if the count of the Self invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockSelfDone() bool {
	for _, e := range m.SelfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SelfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSelfCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelf != nil && mm_atomic.LoadUint64(&m.afterSelfCounter) < 1 {
		return false
	}
	return true
}

// MinimockSelfInspect logs each unmet expectation
func (m *ClientMock) MinimockSelfInspect() {
	for _, e := range m.SelfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ClientMock.Self")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SelfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSelfCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Self")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelf != nil && mm_atomic.LoadUint64(&m.afterSelfCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Self")
	}
}

type mClientMockService struct {
	mock               *ClientMock
	defaultExpectation *ClientMockServiceExpectation
	expectations       []*ClientMockServiceExpectation

	callArgs []*ClientMockServiceParams
	mutex    sync.RWMutex
}

// ClientMockServiceExpectation specifies expectation struct of the Client.Service
type ClientMockServiceExpectation struct {
	mock    *ClientMock
	params  *ClientMockServiceParams
	results *ClientMockServiceResults
	Counter uint64
}

// ClientMockServiceParams contains parameters of the Client.Service
type ClientMockServiceParams struct {
	dc      string
	service string
	tags    []string
}

// ClientMockServiceResults contains results of the Client.Service
type ClientMockServiceResults struct {
	sa1 []Service
	err error
}

// Expect sets up expected params for Client.Service
func (mmService *mClientMockService) Expect(dc string, service string, tags ...string) *mClientMockService {
	if mmService.mock.funcService != nil {
		mmService.mock.t.Fatalf("ClientMock.Service mock is already set by Set")
	}

	if mmService.defaultExpectation == nil {
		mmService.defaultExpectation = &ClientMockServiceExpectation{}
	}

	mmService.defaultExpectation.params = &ClientMockServiceParams{dc, service, tags}
	for _, e := range mmService.expectations {
		if minimock.Equal(e.params, mmService.defaultExpectation.params) {
			mmService.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmService.defaultExpectation.params)
		}
	}

	return mmService
}

// Return sets up results that will be returned by Client.Service
func (mmService *mClientMockService) Return(sa1 []Service, err error) *ClientMock {
	if mmService.mock.funcService != nil {
		mmService.mock.t.Fatalf("ClientMock.Service mock is already set by Set")
	}

	if mmService.defaultExpectation == nil {
		mmService.defaultExpectation = &ClientMockServiceExpectation{mock: mmService.mock}
	}
	mmService.defaultExpectation.results = &ClientMockServiceResults{sa1, err}
	return mmService.mock
}

//Set uses given function f to mock the Client.Service method
func (mmService *mClientMockService) Set(f func(dc string, service string, tags ...string) (sa1 []Service, err error)) *ClientMock {
	if mmService.defaultExpectation != nil {
		mmService.mock.t.Fatalf("Default expectation is already set for the Client.Service method")
	}

	if len(mmService.expectations) > 0 {
		mmService.mock.t.Fatalf("Some expectations are already set for the Client.Service method")
	}

	mmService.mock.funcService = f
	return mmService.mock
}

// When sets expectation for the Client.Service which will trigger the result defined by the following
// Then helper
func (mmService *mClientMockService) When(dc string, service string, tags ...string) *ClientMockServiceExpectation {
	if mmService.mock.funcService != nil {
		mmService.mock.t.Fatalf("ClientMock.Service mock is already set by Set")
	}

	expectation := &ClientMockServiceExpectation{
		mock:   mmService.mock,
		params: &ClientMockServiceParams{dc, service, tags},
	}
	mmService.expectations = append(mmService.expectations, expectation)
	return expectation
}

// Then sets up Client.Service return parameters for the expectation previously defined by the When method
func (e *ClientMockServiceExpectation) Then(sa1 []Service, err error) *ClientMock {
	e.results = &ClientMockServiceResults{sa1, err}
	return e.mock
}

// Service implements Client
func (mmService *ClientMock) Service(dc string, service string, tags ...string) (sa1 []Service, err error) {
	mm_atomic.AddUint64(&mmService.beforeServiceCounter, 1)
	defer mm_atomic.AddUint64(&mmService.afterServiceCounter, 1)

	params := &ClientMockServiceParams{dc, service, tags}

	// Record call args
	mmService.ServiceMock.mutex.Lock()
	mmService.ServiceMock.callArgs = append(mmService.ServiceMock.callArgs, params)
	mmService.ServiceMock.mutex.Unlock()

	for _, e := range mmService.ServiceMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmService.ServiceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmService.ServiceMock.defaultExpectation.Counter, 1)
		want := mmService.ServiceMock.defaultExpectation.params
		got := ClientMockServiceParams{dc, service, tags}
		if want != nil && !minimock.Equal(*want, got) {
			mmService.t.Errorf("ClientMock.Service got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmService.ServiceMock.defaultExpectation.results
		if results == nil {
			mmService.t.Fatal("No results are set for the ClientMock.Service")
		}
		return (*results).sa1, (*results).err
	}
	if mmService.funcService != nil {
		return mmService.funcService(dc, service, tags...)
	}
	mmService.t.Fatalf("Unexpected call to ClientMock.Service. %v %v %v", dc, service, tags)
	return
}

// ServiceAfterCounter returns a count of finished ClientMock.Service invocations
func (mmService *ClientMock) ServiceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmService.afterServiceCounter)
}

// ServiceBeforeCounter returns a count of ClientMock.Service invocations
func (mmService *ClientMock) ServiceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmService.beforeServiceCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Service.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmService *mClientMockService) Calls() []*ClientMockServiceParams {
	mmService.mutex.RLock()

	argCopy := make([]*ClientMockServiceParams, len(mmService.callArgs))
	copy(argCopy, mmService.callArgs)

	mmService.mutex.RUnlock()

	return argCopy
}

// MinimockServiceDone returns true if the count of the Service invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockServiceDone() bool {
	for _, e := range m.ServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ServiceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterServiceCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcService != nil && mm_atomic.LoadUint64(&m.afterServiceCounter) < 1 {
		return false
	}
	return true
}

// MinimockServiceInspect logs each unmet expectation
func (m *ClientMock) MinimockServiceInspect() {
	for _, e := range m.ServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Service with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ServiceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterServiceCounter) < 1 {
		if m.ServiceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Service")
		} else {
			m.t.Errorf("Expected call to ClientMock.Service with params: %#v", *m.ServiceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcService != nil && mm_atomic.LoadUint64(&m.afterServiceCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Service")
	}
}

type mClientMockServices struct {
	mock               *ClientMock
	defaultExpectation *ClientMockServicesExpectation
	expectations       []*ClientMockServicesExpectation

	callArgs []*ClientMockServicesParams
	mutex    sync.RWMutex
}

// ClientMockServicesExpectation specifies expectation struct of the Client.Services
type ClientMockServicesExpectation struct {
	mock    *ClientMock
	params  *ClientMockServicesParams
	results *ClientMockServicesResults
	Counter uint64
}

// ClientMockServicesParams contains parameters of the Client.Services
type ClientMockServicesParams struct {
	dc string
}

// ClientMockServicesResults contains results of the Client.Services
type ClientMockServicesResults struct {
	m1  map[string][]string
	err error
}

// Expect sets up expected params for Client.Services
func (mmServices *mClientMockServices) Expect(dc string) *mClientMockServices {
	if mmServices.mock.funcServices != nil {
		mmServices.mock.t.Fatalf("ClientMock.Services mock is already set by Set")
	}

	if mmServices.defaultExpectation == nil {
		mmServices.defaultExpectation = &ClientMockServicesExpectation{}
	}

	mmServices.defaultExpectation.params = &ClientMockServicesParams{dc}
	for _, e := range mmServices.expectations {
		if minimock.Equal(e.params, mmServices.defaultExpectation.params) {
			mmServices.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmServices.defaultExpectation.params)
		}
	}

	return mmServices
}

// Return sets up results that will be returned by Client.Services
func (mmServices *mClientMockServices) Return(m1 map[string][]string, err error) *ClientMock {
	if mmServices.mock.funcServices != nil {
		mmServices.mock.t.Fatalf("ClientMock.Services mock is already set by Set")
	}

	if mmServices.defaultExpectation == nil {
		mmServices.defaultExpectation = &ClientMockServicesExpectation{mock: mmServices.mock}
	}
	mmServices.defaultExpectation.results = &ClientMockServicesResults{m1, err}
	return mmServices.mock
}

//Set uses given function f to mock the Client.Services method
func (mmServices *mClientMockServices) Set(f func(dc string) (m1 map[string][]string, err error)) *ClientMock {
	if mmServices.defaultExpectation != nil {
		mmServices.mock.t.Fatalf("Default expectation is already set for the Client.Services method")
	}

	if len(mmServices.expectations) > 0 {
		mmServices.mock.t.Fatalf("Some expectations are already set for the Client.Services method")
	}

	mmServices.mock.funcServices = f
	return mmServices.mock
}

// When sets expectation for the Client.Services which will trigger the result defined by the following
// Then helper
func (mmServices *mClientMockServices) When(dc string) *ClientMockServicesExpectation {
	if mmServices.mock.funcServices != nil {
		mmServices.mock.t.Fatalf("ClientMock.Services mock is already set by Set")
	}

	expectation := &ClientMockServicesExpectation{
		mock:   mmServices.mock,
		params: &ClientMockServicesParams{dc},
	}
	mmServices.expectations = append(mmServices.expectations, expectation)
	return expectation
}

// Then sets up Client.Services return parameters for the expectation previously defined by the When method
func (e *ClientMockServicesExpectation) Then(m1 map[string][]string, err error) *ClientMock {
	e.results = &ClientMockServicesResults{m1, err}
	return e.mock
}

// Services implements Client
func (mmServices *ClientMock) Services(dc string) (m1 map[string][]string, err error) {
	mm_atomic.AddUint64(&mmServices.beforeServicesCounter, 1)
	defer mm_atomic.AddUint64(&mmServices.afterServicesCounter, 1)

	params := &ClientMockServicesParams{dc}

	// Record call args
	mmServices.ServicesMock.mutex.Lock()
	mmServices.ServicesMock.callArgs = append(mmServices.ServicesMock.callArgs, params)
	mmServices.ServicesMock.mutex.Unlock()

	for _, e := range mmServices.ServicesMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmServices.ServicesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmServices.ServicesMock.defaultExpectation.Counter, 1)
		want := mmServices.ServicesMock.defaultExpectation.params
		got := ClientMockServicesParams{dc}
		if want != nil && !minimock.Equal(*want, got) {
			mmServices.t.Errorf("ClientMock.Services got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmServices.ServicesMock.defaultExpectation.results
		if results == nil {
			mmServices.t.Fatal("No results are set for the ClientMock.Services")
		}
		return (*results).m1, (*results).err
	}
	if mmServices.funcServices != nil {
		return mmServices.funcServices(dc)
	}
	mmServices.t.Fatalf("Unexpected call to ClientMock.Services. %v", dc)
	return
}

// ServicesAfterCounter returns a count of finished ClientMock.Services invocations
func (mmServices *ClientMock) ServicesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmServices.afterServicesCounter)
}

// ServicesBeforeCounter returns a count of ClientMock.Services invocations
func (mmServices *ClientMock) ServicesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmServices.beforeServicesCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Services.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmServices *mClientMockServices) Calls() []*ClientMockServicesParams {
	mmServices.mutex.RLock()

	argCopy := make([]*ClientMockServicesParams, len(mmServices.callArgs))
	copy(argCopy, mmServices.callArgs)

	mmServices.mutex.RUnlock()

	return argCopy
}

// MinimockServicesDone returns true if the count of the Services invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockServicesDone() bool {
	for _, e := range m.ServicesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ServicesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterServicesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcServices != nil && mm_atomic.LoadUint64(&m.afterServicesCounter) < 1 {
		return false
	}
	return true
}

// MinimockServicesInspect logs each unmet expectation
func (m *ClientMock) MinimockServicesInspect() {
	for _, e := range m.ServicesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Services with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ServicesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterServicesCounter) < 1 {
		if m.ServicesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Services")
		} else {
			m.t.Errorf("Expected call to ClientMock.Services with params: %#v", *m.ServicesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcServices != nil && mm_atomic.LoadUint64(&m.afterServicesCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Services")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ClientMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateSessionInspect()

		m.MinimockDatacentersInspect()

		m.MinimockDeleteInspect()

		m.MinimockDeleteSessionInspect()

		m.MinimockGetInspect()

		m.MinimockKeysInspect()

		m.MinimockListSessionsInspect()

		m.MinimockMaintenanceModeInspect()

		m.MinimockMembersInspect()

		m.MinimockNodeInspect()

		m.MinimockNodesInspect()

		m.MinimockParticipateInspect()

		m.MinimockPutInspect()

		m.MinimockReadSessionInspect()

		m.MinimockRecurseInspect()

		m.MinimockReloadInspect()

		m.MinimockRenewSessionInspect()

		m.MinimockSelfInspect()

		m.MinimockServiceInspect()

		m.MinimockServicesInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateSessionDone() &&
		m.MinimockDatacentersDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockDeleteSessionDone() &&
		m.MinimockGetDone() &&
		m.MinimockKeysDone() &&
		m.MinimockListSessionsDone() &&
		m.MinimockMaintenanceModeDone() &&
		m.MinimockMembersDone() &&
		m.MinimockNodeDone() &&
		m.MinimockNodesDone() &&
		m.MinimockParticipateDone() &&
		m.MinimockPutDone() &&
		m.MinimockReadSessionDone() &&
		m.MinimockRecurseDone() &&
		m.MinimockReloadDone() &&
		m.MinimockRenewSessionDone() &&
		m.MinimockSelfDone() &&
		m.MinimockServiceDone() &&
		m.MinimockServicesDone()
}
